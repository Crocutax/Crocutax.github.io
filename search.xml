<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java使用Separator替代符号拼接]]></title>
    <url>%2F2018%2F03%2F08%2FJava%E4%BD%BF%E7%94%A8Separator%E6%9B%BF%E4%BB%A3%E7%AC%A6%E5%8F%B7%E6%8B%BC%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[为了在Windows，Linux，Mac 等不同平台的适配性，在写代码的时候，文件之间的分隔符，比如D:/develop/Java，尽量不要直接写成死代码”/“，而是以代码代替，通过代码来获取系统的分隔符。 ‘/‘符号 File.separatorChar File.separator “:”符号 File.pathSeparatorChar File.pathSeparator 源码一览无余 123456789101112131415161718192021/** * The FileSystem object representing the platform's local file system. */private static final FileSystem fs = DefaultFileSystem.getFileSystem();/** * The system-dependent default name-separator character. This field is * initialized to contain the first character of the value of the system * property &lt;code&gt;file.separator&lt;/code&gt;. On UNIX systems the value of this * field is &lt;code&gt;'/'&lt;/code&gt;; on Microsoft Windows systems it is &lt;code&gt;'\\'&lt;/code&gt;. * * @see java.lang.System#getProperty(java.lang.String) */public static final char separatorChar = fs.getSeparator();/** * The system-dependent default name-separator character, represented as a * string for convenience. This string contains a single character, namely * &lt;code&gt;&#123;@link #separatorChar&#125;&lt;/code&gt;. */public static final String separator = "" + separatorChar;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows安装Redis]]></title>
    <url>%2F2018%2F03%2F08%2FWindows%E5%AE%89%E8%A3%85Redis%2F</url>
    <content type="text"><![CDATA[下载Redis Windows下载地址 https://github.com/MicrosoftArchive/redis/releases 启动Redis服务将下载的压缩包解压后,进入安装目录,打开DOS命令行 输入 1redis-server.exe redis.windows.conf 注意,如果使用的是Powershell,可能会提示: Suggestion [3,General]: 找不到命令 redis-server.exe，但它确实存在于当前位置。默认情况下，Windows PowerShell 不会从当前位置加载命令。如果信任此命令，请改为键入“.\redis-server.exe”。有关详细信息，请参阅 “get-help about_Command_Precedence”。 按照提示,在输入的命令前面添加.\即可 1.\redis-server.exe redis.windows.conf 控制台输出: 12345678910111213141516171819202122PS D:\Dev\Redis&gt; .\redis-server.exe redis.windows.conf _._ _.-``__ ''-._ _.-`` `. `_. ''-._ Redis 3.2.100 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ ''-._ ( ' , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'| Port: 6379 | `-._ `._ / _.-' | PID: 12536 `-._ `-._ `-./ _.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | http://redis.io `-._ `-._`-.__.-'_.-' _.-' |`-._`-._ `-.__.-' _.-'_.-'| | `-._`-._ _.-'_.-' | `-._ `-._`-.__.-'_.-' _.-' `-._ `-.__.-' _.-' `-._ _.-' `-.__.-'[12536] 07 Mar 13:30:03.324 # Server started, Redis version 3.2.100[12536] 07 Mar 13:30:03.324 * The server is now ready to accept connections on port 6379 注册为系统服务命令:1redis-server --service-install redis.windows.conf --loglevel verbose 控制台输出 123PS D:\Dev\Redis&gt; .\redis-server --service-install redis.windows.conf --loglevel verbose[3864] 07 Mar 13:33:08.458 # Granting read/write access to 'NT AUTHORITY\NetworkService' on: "D:\Dev\Redis" "D:\Dev\Redis\"[3864] 07 Mar 13:33:08.458 # Redis successfully installed as a service. 此时搜索service服务,即可发现redis服务,手动启动即可. 使用Redis在Redis根目录下,两种方式使用Redis命令行工具, CMD打开DOS窗口,输入 .\redis-cli.exe -h 127.0.0.1 -p 6379 登录 双击打开redis-cli.exe文件 使用示例: 12345127.0.0.1:6379&gt; set testKey CrocutaxOK127.0.0.1:6379&gt; get testKey"Crocutax"127.0.0.1:6379&gt; 官网 Redis 命令介绍 Redis桌面管理工具RedisDesktopManager (完) 参考链接: http://blog.csdn.net/u010935342/article/details/53112392 https://www.cnblogs.com/W-Yentl/p/7831671.html]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux连接局域网数据库服务器]]></title>
    <url>%2F2018%2F02%2F25%2FLinux%E8%BF%9E%E6%8E%A5%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[单体服务器的业务承载量有限，所以应用服务器和数据库服务器分开部署数据常规操作，这里记录下一些需要注意的点。 业务场景： A为应用服务器，Linux系统，有公网IP B为数据库服务器，Linux系统，只有内网IP 需要通过A服务器的公网IP连接A服务器，然后来管理B服务器上的数据库。 下载安装phpMyAdmin开源PHP数据库管理工具，官网下载链接： https://www.phpmyadmin.net/downloads/ 用到的命令： tar zxvf phpMyAdmin-4.7.8-all-languages.tar.gz mv phpMyAdmin-4.7.8-all-languages phpmyadmin cp -p config.sample.inc.php config.inc.php 配置Mysql数据库phpMyAdmin默认使用的是MySQL的帐户和密码。默认使用的是本机的mysql，默认如下 $cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;localhost&apos;; $cfg[&apos;Servers&apos;][$i][&apos;user&apos;] = &apos;root&apos;; $cfg[&apos;Servers&apos;][$i][&apos;password&apos;] = &apos;&apos;; MySQL默认用户名是root，密码是空。但是phpMyAdmin不允许空密码登录，所以需要在A服务器内网连接B服务器，然后在数据库服务器B上配置Mysql的密码，再从phpMyAdmin进行登录。 linux以ssh方式连接局域网服务器,执行命令ssh root@192.168.3.1,示例如下： [root@nginx phpmyadmin]# ssh root@192.168.3.1 root@192.168.11.7&apos;s password: Last login: Fri Feb 23 21:40:19 2018 from 192.168.3.2 [root@mysql56 ~]# 注意需要给Mysql开放远程连接的账号并配置防火墙规则，开放3306端口。 可以参考： 阿里云Centos7服务器-JavaWeb正式环境搭建 Mysql部分 Linux-Centos7防火墙配置 https://www.2cto.com/database/201412/359998.html 配置完毕后退出B服务器的SSH连接 [root@mysql56 ~]# exit 回到A服务器进行局域网连接测试: mysql -h 192.168.3.1 -utest -p 配置phpMyAdmin可以正常登录后，配置phpMyAdmin，修改phpmyadmin目录中libraries文件夹下的config.default.php文件，设置成刚刚设置的数据库参数即可，比如 $cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;192.168.3.1&apos;; $cfg[&apos;Servers&apos;][$i][&apos;user&apos;] = &apos;test&apos;; $cfg[&apos;Servers&apos;][$i][&apos;password&apos;] = &apos;123456&apos;; 常见异常: #2002 - 服务器没有响应 (或者本地 MySQL 服务器的套接字没有正确配置) 网上都是说把host的localhost改为127.0.0.1,由于是以局域网IP方式作为host，所以这个方式无效，最终通过去数据库服务器开放远程连接账户和防火墙端口解决。 配置Nginx关于PHP环境的搭建可参考 Centos7搭建PHP环境 配置完毕的nginx，输入http://yourIpAddress:8081/phpmyadmin可直接访问phpMyAdmin登录页面： server { listen 8081; server_name localhost; location /phpmyadmin { root html; index index.php index.html; } location ~* \.php$ { fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; } } （完） 参考链接： http://www.osyunwei.com/archives/869.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux-Centos7防火墙配置]]></title>
    <url>%2F2018%2F02%2F25%2FLinux-Centos7%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于防火墙管理工具，RHEL7之前使用iptables，7之后使用firewalld（Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器），二者都不是真正的防火墙，都只是用来定义防火墙策略的防火墙管理工具，真正的防火墙需要通过内核层面来实现。 目前对于防火墙只是处于入门阶段，随着理解的深入再逐渐完善本文，目前仅做工作记录。 FirewalldRHEL7默认的防火墙管理工具，新特性： 动态更新技术 加入区域(zone)管理 区域名称及策略规则区域 默认规则策略 trusted 允许所有的数据包 home 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、mdns、ipp-client、amba-client与dhcpv6-client服务相关，则允许流量 internal 等同于home区域 work 拒绝流入的流量，除非与流出的流量数相关；而如果流量与ssh、ipp-client与dhcpv6-client服务相关，则允许流量 public 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh、dhcpv6-client服务相关，则允许流量 external 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量 dmz 拒绝流入的流量，除非与流出的流量相关；而如果流量与ssh服务相关，则允许流量 block 拒绝流入的流量，除非与流出的流量相关 drop 拒绝流入的流量，除非与流出的流量相关 firewalld-cmd命令firewalld-cmd命令中使用的参数以及作用 参数 作用 --get-default-zone 查询默认的区域名称 --set-default-zone=&lt;区域名称&gt; 设置默认的区域，使其永久生效 --get-zones 显示可用的区域 --get-services 显示预先定义的服务 --get-active-zones 显示当前正在使用的区域与网卡名称 --remove-source= 将源自此IP或子网的流量导向指定的区域 --remove-source= 不再将源自此IP或子网的流量导向某个指定区域 --add-interface=&lt;网卡名称&gt; 将源自该网卡的所有流量都导向某个指定区域 --change-interface=&lt;网卡名称&gt; 将某个网卡与区域进行关联 --list-all 显示当前区域的网卡配置参数、资源、端口以及服务等信息 --list-all-zones 显示所有区域的网卡配置参数、资源、端口以及服务等信息 --add-service=&lt;服务名&gt; 设置默认区域允许该服务的流量 --add-port=&lt;端口号/协议&gt; 设置默认区域允许该端口的流量 --remove-service=&lt;服务名&gt; 设置默认区域不再允许该服务的流量 --remove-port=&lt;端口号/协议&gt; 设置默认区域不再允许该端口的流量 --reload 让“永久生效”的配置规则立即生效，并覆盖当前的配置规则 --panic-on 开启应急状况模式 --panic-off 关闭应急状况模式 常用命令： systemctl status firewalld.service 查看firewalld状态 systemctl start firewalld.service 开启firewalld systemctl stop firewalld.service 关闭firewalld firewall-cmd --zone=public --add-port=80/tcp --permanent 永久添加指定端口 firewall-cmd --zone=public --remove-port=8080/tcp --permanent 永久移除指定端口 firewall-cmd --query-port=3306/tcp 查看端口是否被开放，返回yes/no firewall-cmd --list-all 查看所有开放的端口 systemctl enable firewalld.service 开启自启 systemctl disable firewalld.service 禁止开机自启 systemctl is-enabled firewalld.service 查看是否开机自启 firewall-cmd --reload 更新防火墙规则（立即生效，永久添加时需要reload） 另外，查看已经开放的端口，也可以直接到/etc/firewalld/zones/目录下去查看指定文件，例如查看对外公开的防火墙端口： vim /etc/firewalld/zones/public.xml Iptables早期Linux系统的默认防火墙管理工具。 策略与规则链按照从上至下的顺序来读取配置进行匹配，找到匹配项后就立即结束匹配工作并去执行匹配项中定义的行为（放行或阻止）如果在读取完所有的策略规则之后没有匹配项，就去执行默认的策略。规则：放行 与 阻止。 iptables服务把用于处理或过滤流量的策略条目称之为规则，多条规则可以组成一个规则链，而规则链则依据数据包处理位置的不同进行分类，具体如下： 在进行路由选择前处理数据包（PREROUTING） 处理流入的数据包（INPUT） 处理流出的数据包（OUTPUT） 处理转发的数据包（FORWARD） 在进行路由选择后处理数据包（POSTROUTING） 使用最多的是INPUT规则链，即默认阻止，自定义放行规则。 处理方式： ACCEPT（允许流量通过） REJECT（拒绝流量通过，拒绝并回复） LOG（记录日志信息） DROP（拒绝流量通过，默默拒绝不回复） 基本命令参数参数 作用 -P 设置默认策略 -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D num 删除某一条规则 -s 匹配来源地址IP/MASK，加叹号“!”表示除这个IP外 -d 匹配目标地址 -i 网卡名称 匹配从这块网卡流入的数据 -o 网卡名称 匹配从这块网卡流出的数据 -p 匹配协议，如TCP、UDP、ICMP --dport num 匹配目标端口号 --sport num 匹配来源端口号 配置示例命令配置iptables -L 查看已有的防火墙规则链 iptables -F 清空已有的防火墙规则链 iptables -P INPUT DROP 设置默认的规则链 iptables -I INPUT -p icmp -j ACCEPT 添加允许ICMP流量进入的策略规则 iptables -I INPUT -s 192.168.10.0/24 -p tcp --dport 22 -j ACCEPT 只允许指定网段的主机访问本机22端口 iptables -A INPUT -p tcp --dport 22 -j REJECT 拒绝其他所有主机流量访问22端口 iptables -I INPUT -p tcp --dport 12345 -j REJECT 拒绝所有人以TCP协议访问本机12345端口的策略规则 iptables -I INPUT -p udp --dport 12345 -j REJECT 拒绝所有人以UDP协议访问本机12345端口的策略规则 iptables -I INPUT -p tcp -s 192.168.10.5 --dport 80 -j REJECT 拒绝192.168.10.5主机访问本机80端口 注意：通过命令行配置的防火墙规则，系统重启后会失效，永久生效需要执行保存命令： service iptables save 编辑防火墙配置文件打开防火墙配置文件 vim /etc/sysconfig/iptables 文件内容如下： *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT -A INPUT -j REJECT --reject-with icmp-host-prohibited -A FORWARD -j REJECT --reject-with icmp-host-prohibited 注意： 1.匹配规则是从上至下，因此要把允许策略放在上面，拒绝策略放在下面。 2.必须重启防火墙，新的配置才能生效 service iptables restart (完) 参考链接： https://www.linuxprobe.com/chapter-08.html （推荐） https://www.linuxidc.com/Linux/2017-03/141434.htm http://blog.csdn.net/xlgen157387/article/details/52672988 http://blog.csdn.net/sunny05296/article/details/66004445 firewall命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统版本信息]]></title>
    <url>%2F2018%2F02%2F25%2FLinux%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[查看Linux内核版本: cat /proc/version [root@nginx web]# cat /proc/version Linux version 3.10.0-693.11.6.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC) ) #1 SMP Thu Jan 4 01:06:37 UTC 2018 查看Redhat系列的Linux发行版本信息:cat /etc/redhat-release [root@nginx web]# cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) 参考链接： https://www.linuxidc.com/Linux/2016-05/131749.htm]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux系统用户管理]]></title>
    <url>%2F2018%2F02%2F25%2FLinux%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户管理增删改查： cat /etc/passwd 查询用户信息 useradd 选项 用户名 （添加用户） usermod 选项 用户名 （修改用户） userdel 选项 用户名 （删除用户） 例如： useradd -d /usr/local/web/ -g dev -m testuser usermod -d /user/local/ -g manager testuser 修改用户组和主目录 userdel -r testuser 用户+用户主目录一起删除 选项： -c comment 指定一段注释性描述。 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 口令管理设置口令： passwd 选项 用户名 （设置用户密码） 选项： -l 锁定口令，即禁用账号。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 用户组管理 groupadd 选项 用户组 （添加用户组） 选项 -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 例如： groupadd testuser groupdel 用户组名 （删除用户组） groupdel testuser groupmod 选项 用户组 (修改用户组) 选项： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 例如： groupmod testuser 用户权限chown -R testuser:dev /usr/local/java/ 赋予用户指定目录的权限,testuser是用户名，dev是用户组 参考链接： http://www.runoob.com/linux/linux-user-manage.html https://www.cnblogs.com/clicli/p/5943788.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建PHP环境]]></title>
    <url>%2F2018%2F02%2F25%2FCentos7%E6%90%AD%E5%BB%BAPHP%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装PHP下载PHP包PHP官网下载链接： https://secure.php.net/downloads.php 选择最新的tar.gz包，通过FTP上传至linux服务器，解压PHP压缩包 tar zxvf php-7.2.2.tar.gz 编译进入php7文件夹 cd php-7.2.2 输入命令： ./configure --enable-fpm --enable-mbstring 自己在安装的过程中出现了如下异常: configure: error: xml2-config not found. Please check your libxml2 installation. 提示找不到xml2-config文件，让检查libxml2的安装情况。 检测libxml2是否安装，显示已安装 [root@nginx php-7.2.2]# rpm -qa|grep libxml2 libxml2-2.9.1-6.el7_2.3.x86_64 重复安装无效 [root@nginx php-7.2.2]# yum install libxml2 Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com Package libxml2-2.9.1-6.el7_2.3.x86_64 already installed and latest version Nothing to do 但查找xml2-config文件，还是提示没有 [root@nginx php-7.2.2]# find/-name &quot;xml2-config&quot; -bash: find/-name: No such file or directory 通过搜索引擎找到解决方案：检测libxml2-devel的安装情况，通过rpm -qa |grep libxml2-devel命令发现没有安装，于是开始安装。 [root@nginx php-7.2.2]# yum install libxml2-devel -y Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: mirrors.aliyun.com * epel: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.aliyun.com Resolving Dependencies --&gt; Running transaction check ---&gt; Package libxml2-devel.x86_64 0:2.9.1-6.el7_2.3 will be installed --&gt; Finished Dependency Resolution Dependencies Resolved ======================================================================================================================================================== Package Arch Version Repository Size ======================================================================================================================================================== Installing: libxml2-devel x86_64 2.9.1-6.el7_2.3 base 1.0 M Transaction Summary ======================================================================================================================================================== Install 1 Package Total download size: 1.0 M Installed size: 8.8 M Downloading packages: libxml2-devel-2.9.1-6.el7_2.3.x86_64.rpm | 1.0 MB 00:00:01 Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : libxml2-devel-2.9.1-6.el7_2.3.x86_64 1/1 Verifying : libxml2-devel-2.9.1-6.el7_2.3.x86_64 1/1 Installed: libxml2-devel.x86_64 0:2.9.1-6.el7_2.3 Complete! 此时再次检测libxml2安装情况和xml2-config文件，发现都没问题了： [root@nginx php-7.2.2]# rpm -qa |grep libxml2 libxml2-2.9.1-6.el7_2.3.x86_64 libxml2-devel-2.9.1-6.el7_2.3.x86_64 [root@nginx php-7.2.2]# find / -name &quot;xml2-config&quot; /usr/bin/xml2-config 于是重新 ./configure --enable-fpm --enable-mbstring 成功： Generating files configure: creating ./config.status creating main/internal_functions.c creating main/internal_functions_cli.c +--------------------------------------------------------------------+ | License: | | This software is subject to the PHP License, available in this | | distribution in the file LICENSE. By continuing this installation | | process, you are bound by the terms of this license agreement. | | If you do not agree with the terms of this license, you must abort | | the installation process at this point. | +--------------------------------------------------------------------+ Thank you for using PHP. 安装make make install 测试安装结果： [root@nginx web]# php -v PHP 7.2.2 (cli) (built: Feb 24 2018 15:17:15) ( NTS ) Copyright (c) 1997-2018 The PHP Group Zend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies 配置FPM只安装了PHP还不能直接访问PHP文件，需要配置PHP-FPM，并启动FPM服务,让FPM和Nginx可以正常通信。 按照PHP官网的配置说明，创建配置文件 cp php.ini-development /usr/local/php/php.ini cp /usr/local/etc/php-fpm.conf.default /usr/local/etc/php-fpm.conf cp sapi/fpm/php-fpm /usr/local/bin 然后启动 php-fpm 服务： /usr/local/bin/php-fpm 报如下异常： ERROR: Unable to globalize ‘/usr/local/NONE/etc/php-fpm.d/*.conf’ (ret=2) from /usr/local/etc/php-fpm.conf 编辑php-fpm.conf配置文件 vim /usr/local/etc/php-fpm.conf 将最后一行include=NONE/etc/php-fpm.d/*.conf修改为include=etc/php.fpm.d/*.conf include=NONE/etc/php-fpm.d/*.conf #修改前 include=etc/php.fpm.d/*.conf #修改后 继续启动php-fpm 服务： /usr/local/bin/php-fpm 报如下异常： [root@nginx php]# /usr/local/bin/php-fpm[24-Feb-2018 16:04:17] WARNING: Nothing matches the include pattern ‘/usr/local/etc/php-fpm.d/*.conf’ from /usr/local/etc/php-fpm.conf at line 125.[24-Feb-2018 16:04:17] ERROR: No pool defined. at least one pool section must be specified in config file[24-Feb-2018 16:04:17] ERROR: failed to post process the configuration[24-Feb-2018 16:04:17] ERROR: FPM initialization failed 进入目录进入目录/usr/local/etc/php-fpm.d，执行 cp www.conf.default www.conf 再起启动php-fpm服务，通过netstat -tunlp |grep 9000命令，发现启动成功了: [root@nginx sbin]# netstat -tunlp |grep 9000 tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 118470/php-fpm: mas 配置Nginx这里直接记录已经正常运行phpMyAdmin的Nginx配置，此时phpMyAdmin放在了Nginx的html目录下。 server { listen 8081; server_name localhost; location /phpmyadmin { root html; index index.php index.html; } location ~* \.php$ { fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; } } 配置完成以后，记得: service nginx restart 输入:http://yourIpAddress:8081/phpmyadmin可直接访问phpMyAdmin登录页面。 Nginx常见异常403 Forbidden检查 html目录的访问权限ls -l File not found把index.php添加到location节点的index处。 location / { root html; index index.php index.html; } 另外，如果报出File not found异常，记得 (完) 参考链接： http://blog.csdn.net/etwo123/article/details/54582088 (重点感谢) http://php.net/manual/zh/install.unix.nginx.php http://blog.csdn.net/u010647316/article/details/56489795 http://blog.csdn.net/dabao1989/article/details/22898857]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设置Mysql字符集编码为UTF-8,解决中文乱码]]></title>
    <url>%2F2018%2F02%2F25%2F%E8%AE%BE%E7%BD%AEMysql%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E4%B8%BAUTF-8%2C%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[微信公众号开发，获取到的用户昵称为乱码，排查结果为Mysql数据库的默认字符集编码问题，要解决中文乱码，必须设置默认字符集为UTF-8。 登录mysql，通过命令查看字符集编码： mysql&gt; show variables like &quot;char%&quot;; 结果如下： +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.00 sec) 发现character_set_database和character_set_server的编码默认为latin1，因此需要修改为UTF-8。 修改Mysql配置文件 vim /etc/my.cnf 在【mysqld】下方添加character_set_server=utf8，位置如下： [mysqld] ... datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock character_set_server=utf8 设置完成后，:wq保存，并重启mysql服务 sudo systemctl restart mysqld 再次查看数据库字符集编码，发现已经全部改成UTF-8了： mysql&gt; show variables like &apos;character%&apos;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.01 sec) （完） 参考链接： http://www.2cto.com/database/201311/255324.html]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Composer]]></title>
    <url>%2F2018%2F02%2F20%2FComposer%2F</url>
    <content type="text"><![CDATA[安装Composer是PHP的一个依赖管理工具，正如gradle之于Android，maven之于Java，当然后两者除了依赖管理，还有项目构建作用。 中文学习文档： http://docs.phpcomposer.com/ 安装连接直达： http://docs.phpcomposer.com/00-intro.html 安装完毕后，用命令行检测安装结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364C:\Users\wangx&gt;composer ______ / ____/___ ____ ___ ____ ____ ________ _____ / / / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___// /___/ /_/ / / / / / / /_/ / /_/ (__ ) __/ /\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/ /_/Composer version 1.6.2 2018-01-05 15:28:41Usage: command [options] [arguments]Options: -h, --help Display this help message -q, --quiet Do not output any message -V, --version Display this application version --ansi Force ANSI output --no-ansi Disable ANSI output -n, --no-interaction Do not ask any interactive question --profile Display timing and memory usage information --no-plugins Whether to disable plugins. -d, --working-dir=WORKING-DIR If specified, use the given directory as working directory. -v|vv|vvv, --verbose Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debugAvailable commands: about Shows the short information about Composer. archive Creates an archive of this composer package. browse Opens the package's repository URL or homepage in your browser. check-platform-reqs Check that platform requirements are satisfied. clear-cache Clears composer's internal package cache. clearcache Clears composer's internal package cache. config Sets config options. create-project Creates new project from a package into given directory. depends Shows which packages cause the given package to be installed. diagnose Diagnoses the system to identify common errors. dump-autoload Dumps the autoloader. dumpautoload Dumps the autoloader. exec Executes a vendored binary/script. global Allows running commands in the global composer dir ($COMPOSER_HOME). help Displays help for a command home Opens the package's repository URL or homepage in your browser. info Shows information about packages. init Creates a basic composer.json file in current directory. install Installs the project dependencies from the composer.lock file if present, or falls back on the composer.json. licenses Shows information about licenses of dependencies. list Lists commands outdated Shows a list of installed packages that have updates available, including their latest version. prohibits Shows which packages prevent the given package from being installed. remove Removes a package from the require or require-dev. require Adds required packages to your composer.json and installs them. run-script Runs the scripts defined in composer.json. search Searches for packages. self-update Updates composer.phar to the latest version. selfupdate Updates composer.phar to the latest version. show Shows information about packages. status Shows a list of locally modified packages. suggests Shows package suggestions. update Upgrades your dependencies to the latest version according to composer.json, and updates the composer.lock file. upgrade Upgrades your dependencies to the latest version according to composer.json, and updates the composer.lock file. validate Validates a composer.json and composer.lock. why Shows which packages cause the given package to be installed. why-not Shows which packages prevent the given package from being installed.C:\Users\wangx&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[win10修改host]]></title>
    <url>%2F2018%2F02%2F20%2Fwin10%E4%BF%AE%E6%94%B9host%2F</url>
    <content type="text"><![CDATA[什么是hosts文件hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 需要注意的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。 hosts文件在哪hosts文件在不同操作系统的位置都不大一样，Windows XP/vista/8/8.1/10的HOSTS文件在: C:\windows\system32\drivers\etc\ Linux及其他类Unix操作系统：/etc/ Mac OS X：/private/etc 如何修改hosts修改hosts需要系统管理员权限。在winXP及win7中可以直接编辑修改，但是win10之后会提示需要管理员权限。 解决方案: 赋予普通账户更多的权限，如：修改和写入权限。 方法: 1.定位到hosts文件目录，右键选择属性，如图所示，授予普通用户权限。 保存时会有安全提示： 您将要更改系统文件夹的权限设置,这样会降低计算机的安全性,并导致用户访问文件时出现问题。要继续吗？ 如果出于安全性考虑，可以修完之后，再取消新增的权限即可。 2.复制一份host文件其他普通目录（非系统目录，比如桌面），编辑hosts文件并保存，比如将0.0.0.0 account.jetbrains.com添加到文件中。 3.将修改后的文件替换掉C:\Windows\System32\drivers\etc\hosts文件 （完） 参考链接: http://www.oyksoft.com/article/527.html http://www.xitongcheng.com/jiaocheng/win10_article_12937.html]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阿里云Centos7服务器-JavaWeb正式环境搭建]]></title>
    <url>%2F2018%2F01%2F15%2F%E9%98%BF%E9%87%8C%E4%BA%91Centos7%E6%9C%8D%E5%8A%A1%E5%99%A8-JavaWeb%E6%AD%A3%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[服务器系统为阿里云Centos7的linux系统，用于部署JavaWeb项目，记录下搭建步骤: 挂载数据盘 安装MySQL 安装JDK 安装Tomcat Nginx配置 挂载数据盘这部分内容阿里云官方已有详尽的教程，链接直达： Linux 格式化和挂载数据盘 MySQL通过YUM方式安装MySQL5.7版本 1.下载YUM库 命令： wget http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm 在/usr/local/创建一个空文件夹，比如dev，命令：mkdir dev,然后cd进入该目录，执行下载YUM库的命令。控制台输出记录: 1234567891011121314151617181920[root@iZbp1in0wc4jzpx7hkho6sZ dev]# wget http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm--2018-01-15 14:41:41-- http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpmResolving dev.mysql.com (dev.mysql.com)... 137.254.60.11Connecting to dev.mysql.com (dev.mysql.com)|137.254.60.11|:80... connected.HTTP request sent, awaiting response... 301 Moved PermanentlyLocation: https://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm [following]--2018-01-15 14:41:41-- https://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpmConnecting to dev.mysql.com (dev.mysql.com)|137.254.60.11|:443... connected.HTTP request sent, awaiting response... 302 FoundLocation: https://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpm [following]--2018-01-15 14:41:44-- https://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpmResolving repo.mysql.com (repo.mysql.com)... 23.211.97.88Connecting to repo.mysql.com (repo.mysql.com)|23.211.97.88|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 8984 (8.8K) [application/x-redhat-package-manager]Saving to: ‘mysql57-community-release-el7-7.noarch.rpm’100%[====================================================================================================&gt;] 8,984 --.-K/s in 0s 2018-01-15 14:41:44 (196 MB/s) - ‘mysql57-community-release-el7-7.noarch.rpm’ saved [8984/8984] 下载完成后，通过ls命令，可以查看到当前目录已经有MySQL5.7的rpm包 12[root@iZbp1in0wc4jzpx7hkho6sZ dev]# lsmysql57-community-release-el7-7.noarch.rpm 2.安装YUM库 命令:yum localinstall -y mysql57-community-release-el7-7.noarch.rpm 123456789101112131415161718192021222324252627282930313233343536[root@iZbp1in0wc4jzpx7hkho6sZ dev]# yum localinstall -y mysql57-community-release-el7-7.noarch.rpm Loaded plugins: fastestmirrorExamining mysql57-community-release-el7-7.noarch.rpm: mysql57-community-release-el7-7.noarchMarking mysql57-community-release-el7-7.noarch.rpm to be installedResolving Dependencies--&gt; Running transaction check---&gt; Package mysql57-community-release.noarch 0:el7-7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved============================================================================================================================================== Package Arch Version Repository Size==============================================================================================================================================Installing: mysql57-community-release noarch el7-7 /mysql57-community-release-el7-7.noarch 7.8 kTransaction Summary==============================================================================================================================================Install 1 PackageTotal size: 7.8 kInstalled size: 7.8 kDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : mysql57-community-release-el7-7.noarch 1/1 Verifying : mysql57-community-release-el7-7.noarch 1/1 Installed: mysql57-community-release.noarch 0:el7-7 Complete![root@iZbp1in0wc4jzpx7hkho6sZ dev]# 3.安装MySQL数据库 命令：yum install -y mysql-community-server 控制台输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110[root@iZbp1in0wc4jzpx7hkho6sZ dev]# yum install -y mysql-community-serverLoaded plugins: fastestmirrorbase | 3.6 kB 00:00:00 epel | 4.7 kB 00:00:00 extras | 3.4 kB 00:00:00 mysql-connectors-community | 2.5 kB 00:00:00 mysql-tools-community | 2.5 kB 00:00:00 mysql57-community | 2.5 kB 00:00:00 updates | 3.4 kB 00:00:00 (1/10): base/7/x86_64/group_gz | 156 kB 00:00:00 (2/10): epel/x86_64/group_gz | 266 kB 00:00:00 (3/10): epel/x86_64/updateinfo | 869 kB 00:00:00 (4/10): extras/7/x86_64/primary_db | 145 kB 00:00:00 (5/10): mysql-connectors-community/x86_64/primary_db | 16 kB 00:00:00 (6/10): epel/x86_64/primary_db | 6.2 MB 00:00:00 (7/10): mysql-tools-community/x86_64/primary_db | 37 kB 00:00:00 (8/10): mysql57-community/x86_64/primary_db | 124 kB 00:00:00 (9/10): updates/7/x86_64/primary_db | 5.2 MB 00:00:00 (10/10): base/7/x86_64/primary_db | 5.7 MB 00:00:00 Determining fastest mirrorsResolving Dependencies--&gt; Running transaction check---&gt; Package mysql-community-server.x86_64 0:5.7.20-1.el7 will be installed--&gt; Processing Dependency: mysql-community-common(x86-64) = 5.7.20-1.el7 for package: mysql-community-server-5.7.20-1.el7.x86_64--&gt; Processing Dependency: mysql-community-client(x86-64) &gt;= 5.7.9 for package: mysql-community-server-5.7.20-1.el7.x86_64--&gt; Processing Dependency: libaio.so.1(LIBAIO_0.4)(64bit) for package: mysql-community-server-5.7.20-1.el7.x86_64--&gt; Processing Dependency: libaio.so.1(LIBAIO_0.1)(64bit) for package: mysql-community-server-5.7.20-1.el7.x86_64--&gt; Processing Dependency: libaio.so.1()(64bit) for package: mysql-community-server-5.7.20-1.el7.x86_64--&gt; Running transaction check---&gt; Package libaio.x86_64 0:0.3.109-13.el7 will be installed---&gt; Package mysql-community-client.x86_64 0:5.7.20-1.el7 will be installed--&gt; Processing Dependency: mysql-community-libs(x86-64) &gt;= 5.7.9 for package: mysql-community-client-5.7.20-1.el7.x86_64---&gt; Package mysql-community-common.x86_64 0:5.7.20-1.el7 will be installed--&gt; Running transaction check---&gt; Package mariadb-libs.x86_64 1:5.5.56-2.el7 will be obsoleted--&gt; Processing Dependency: libmysqlclient.so.18()(64bit) for package: 2:postfix-2.10.1-6.el7.x86_64--&gt; Processing Dependency: libmysqlclient.so.18(libmysqlclient_18)(64bit) for package: 2:postfix-2.10.1-6.el7.x86_64---&gt; Package mysql-community-libs.x86_64 0:5.7.20-1.el7 will be obsoleting--&gt; Running transaction check---&gt; Package mysql-community-libs-compat.x86_64 0:5.7.20-1.el7 will be obsoleting--&gt; Finished Dependency ResolutionDependencies Resolved============================================================================================================================================== Package Arch Version Repository Size==============================================================================================================================================Installing: mysql-community-libs x86_64 5.7.20-1.el7 mysql57-community 2.1 M replacing mariadb-libs.x86_64 1:5.5.56-2.el7 mysql-community-libs-compat x86_64 5.7.20-1.el7 mysql57-community 2.0 M replacing mariadb-libs.x86_64 1:5.5.56-2.el7 mysql-community-server x86_64 5.7.20-1.el7 mysql57-community 164 MInstalling for dependencies: libaio x86_64 0.3.109-13.el7 base 24 k mysql-community-client x86_64 5.7.20-1.el7 mysql57-community 24 M mysql-community-common x86_64 5.7.20-1.el7 mysql57-community 272 kTransaction Summary==============================================================================================================================================Install 3 Packages (+3 Dependent packages)Total download size: 192 MDownloading packages:(1/6): libaio-0.3.109-13.el7.x86_64.rpm | 24 kB 00:00:00 warning: /var/cache/yum/x86_64/7/mysql57-community/packages/mysql-community-common-5.7.20-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEYPublic key for mysql-community-common-5.7.20-1.el7.x86_64.rpm is not installed(2/6): mysql-community-common-5.7.20-1.el7.x86_64.rpm | 272 kB 00:00:00 (3/6): mysql-community-libs-5.7.20-1.el7.x86_64.rpm | 2.1 MB 00:00:00 (4/6): mysql-community-libs-compat-5.7.20-1.el7.x86_64.rpm | 2.0 MB 00:00:00 (5/6): mysql-community-client-5.7.20-1.el7.x86_64.rpm | 24 MB 00:00:02 (6/6): mysql-community-server-5.7.20-1.el7.x86_64.rpm | 164 MB 00:00:23 ----------------------------------------------------------------------------------------------------------------------------------------------Total 7.9 MB/s | 192 MB 00:00:24 Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysqlImporting GPG key 0x5072E1F5: Userid : "MySQL Release Engineering &lt;mysql-build@oss.oracle.com&gt;" Fingerprint: a4a9 4068 76fc bd3c 4567 70c8 8c71 8d3b 5072 e1f5 Package : mysql57-community-release-el7-7.noarch (installed) From : /etc/pki/rpm-gpg/RPM-GPG-KEY-mysqlRunning transaction checkRunning transaction testTransaction test succeededRunning transaction Installing : mysql-community-common-5.7.20-1.el7.x86_64 1/7 Installing : mysql-community-libs-5.7.20-1.el7.x86_64 2/7 Installing : mysql-community-client-5.7.20-1.el7.x86_64 3/7 Installing : libaio-0.3.109-13.el7.x86_64 4/7 Installing : mysql-community-server-5.7.20-1.el7.x86_64 5/7 Installing : mysql-community-libs-compat-5.7.20-1.el7.x86_64 6/7 Erasing : 1:mariadb-libs-5.5.56-2.el7.x86_64 7/7 Verifying : mysql-community-libs-5.7.20-1.el7.x86_64 1/7 Verifying : mysql-community-server-5.7.20-1.el7.x86_64 2/7 Verifying : mysql-community-common-5.7.20-1.el7.x86_64 3/7 Verifying : mysql-community-client-5.7.20-1.el7.x86_64 4/7 Verifying : mysql-community-libs-compat-5.7.20-1.el7.x86_64 5/7 Verifying : libaio-0.3.109-13.el7.x86_64 6/7 Verifying : 1:mariadb-libs-5.5.56-2.el7.x86_64 7/7 Installed: mysql-community-libs.x86_64 0:5.7.20-1.el7 mysql-community-libs-compat.x86_64 0:5.7.20-1.el7 mysql-community-server.x86_64 0:5.7.20-1.el7 Dependency Installed: libaio.x86_64 0:0.3.109-13.el7 mysql-community-client.x86_64 0:5.7.20-1.el7 mysql-community-common.x86_64 0:5.7.20-1.el7 Replaced: mariadb-libs.x86_64 1:5.5.56-2.el7 Complete![root@iZbp1in0wc4jzpx7hkho6sZ dev]# 查看MySQL是否安装成功 命令:yum repolist enabled | grep &quot;mysql.*-community.*&quot; 控制台输出: 1234[root@iZbp1in0wc4jzpx7hkho6sZ dev]# yum repolist enabled | grep "mysql.*-community.*"mysql-connectors-community/x86_64 MySQL Connectors Community 42mysql-tools-community/x86_64 MySQL Tools Community 55mysql57-community/x86_64 MySQL 5.7 Community Server 227 4.启动MySQL服务 启动命令：systemctl start mysqld.service 启动完毕后，通过命令systemctl status mysqld查看MySQL的启动状态，控制台输出 1234567891011121314[root@iZbp1in0wc4jzpx7hkho6sZ dev]# systemctl status mysqld● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since Mon 2018-01-15 14:45:39 CST; 1min 47s ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 25374 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS) Process: 25300 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 25378 (mysqld) CGroup: /system.slice/mysqld.service └─25378 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidJan 15 14:45:32 iZbp1in0wc4jzpx7hkho6sZ systemd[1]: Starting MySQL Server...Jan 15 14:45:39 iZbp1in0wc4jzpx7hkho6sZ systemd[1]: Started MySQL Server. 5.修改MySQL默认密码MySQL安装完毕后，会默认提供一个临时密码，查看MySQL的临时密码: grep &#39;temporary password&#39; /var/log/mysqld.log 控制台输出； 12[root@iZbp1in0wc4jzpx7hkho6sZ dev]# grep 'temporary password' /var/log/mysqld.log2018-01-15T06:45:35.070084Z 1 [Note] A temporary password is generated for root@localhost: lyZmjDrcj0(q 这个lyZmjDrcj0(q就是MySQL的临时密码，用这个密码进行数据库登录，并修改密码。 12&gt; mysql -uroot -p&gt; Enterpassword：lyZmjDrcj0(q 登录成功后修改密码：1mysql &gt; set password=password('Longke&amp;Crocutax2018'); 注意： 密码格式规则：大写字母+小写字母+数字+特殊字符 也可以修改密码规则，让MySQL不再检查密码强度，有很多同学上来就想设置个root或者123456，不推荐。 此外，不推荐使用root账号管理数据库，应该从访问地址，数据库访问权限，操作权限等角度缩小单个用户的权限范围。 添加数据库管理员这里记录下给 【单个用户】从【任何地址】对【某个数据库】进行【所有操作】的权限。 12mysql&gt; grant all privileges on factory.* to 'crocutax'@'%' identified by 'Longke&amp;180101';Query OK, 0 rows affected, 1 warning (0.00 sec) 其他情况的调整，修改里面的参数即可。 另外，上面这句命令，同时也创建了一个用户。用户名为crocutax，密码为Longke&amp;180101，可以用这个数据库账号从【本机】及【远程】访问factory数据库 修改MySQL默认端口号MySQL数据库默认的访问端口号是3306，如果在阿里云后台安全规则组中，没有将此端口号添加为入网规则的话，那么从外网是无法访问的。不排除需要修改MySQL默认端口号的情况，这里记录下。 修改默认端口号需要编辑 /etc/my.conf配置文件，因为该文件是只读(read only)文件,所以必须以如下方式打开 sudo /etc/my.conf 在[mysqld]下方,添加自定义的端口号即可,比如123[mysqld]port=8180... 当然，还要确保该端口已经在阿里云后台入网安全规则中添加. 之后重启mysql服务即可 service mysqld restart 至此，MySQL部署完毕。 参考链接，感谢前辈： http://www.linuxidc.com/Linux/2016-08/134790.htm http://blog.csdn.net/csdn2193714269/article/details/72897815 JDKJDK的安装非常简单，三步骤： 下载安装包 解压 配置环境变量 下载和解压就不说了，记录下环境变量配置： 1.编辑配置文件，命令：vim /etc/profile 在配置文件底部添加12345678JAVA_HOME=/usr/local/dev/jdk1.8.0_152JRE_HOME=$JAVA_HOME/jrePATH=$PATH:$JAVA_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOMEexport JRE_HOMEexport PATHexport CLASSPATH ESC+:wq保存 2.刷新配置文件，命令：source /etc/profile 注意:非常关键，必须刷新，修改的配置才能生效。 3.查看是否配置成功,命令：java -version 1234[root@iZbp1in0wc4jzpx7hkho6sZ dev]# java -versionjava version "1.8.0_152"Java(TM) SE Runtime Environment (build 1.8.0_152-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode) 参考链接：极客学院-JDK安装 Tomcat必须先安装JDK，再安装Tomcat，否则即使安装了Tomcat，由于缺少Java环境，也无法正常启动 三步骤： 下载安装包 解压 启动tomcat tomcat的启动和关闭 1234//启动/usr/local/dev/tomcat8_erp/bin/startup.sh //关闭/usr/local/dev/tomcat8_erp/bin/shutdown.sh 启动成功 1234567[root@iZbp1in0wc4jzpx7hkho6sZ dev]# /usr/local/dev/tomcat8_erp/bin/startup.sh Using CATALINA_BASE: /usr/local/dev/tomcat8_erpUsing CATALINA_HOME: /usr/local/dev/tomcat8_erpUsing CATALINA_TMPDIR: /usr/local/dev/tomcat8_erp/tempUsing JRE_HOME: /usr/local/dev/jdk1.8.0_152/jreUsing CLASSPATH: /usr/local/dev/tomcat8_erp/bin/bootstrap.jar:/usr/local/dev/tomcat8_erp/bin/tomcat-juli.jarTomcat started. 之后就可以通过【公网IP+端口号】来访问tomcat首页了,比如：http://1.2.3.4.:8080 如果发现tomcat已启动，但是外网无法访问tomcat，可参考 linux下启动tomcat后-浏览器无法访问 参考链接：http://www.cnblogs.com/hanyinglong/p/5024643.html Nginx这里记录的是yum源安装，编译安装可参考： https://www.linuxidc.com/Linux/2016-09/134907.htm 配置YUM源,下载rpm包12wget http://dl.Fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -ivh epel-release-latest-7.noarch.rpm 查看下载结果： 12[root@izbp109iqt20o2h63tpcuvz java]# lsepel-release-latest-7.noarch.rpm 安装Nginx1yum install nginx -y 安装过程中的log输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215[root@izbp109iqt20o2h63tpcuvz java]# yum install nginx -yLoaded plugins: fastestmirrorbase | 3.6 kB 00:00:00 epel | 4.7 kB 00:00:00 extras | 3.4 kB 00:00:00 mysql-connectors-community | 2.5 kB 00:00:00 mysql-tools-community | 2.5 kB 00:00:00 mysql57-community | 2.5 kB 00:00:00 updates | 3.4 kB 00:00:00 (1/7): epel/x86_64/group_gz | 266 kB 00:00:00 (2/7): epel/x86_64/updateinfo | 874 kB 00:00:00 (3/7): extras/7/x86_64/primary_db | 145 kB 00:00:00 (4/7): epel/x86_64/primary_db | 6.2 MB 00:00:00 (5/7): updates/7/x86_64/primary_db | 5.2 MB 00:00:00 (6/7): mysql-tools-community/x86_64/primary_db | 37 kB 00:00:00 (7/7): mysql57-community/x86_64/primary_db | 134 kB 00:00:01 Determining fastest mirrorsResolving Dependencies--&gt; Running transaction check---&gt; Package nginx.x86_64 1:1.12.2-1.el7 will be installed--&gt; Processing Dependency: nginx-all-modules = 1:1.12.2-1.el7 for package: 1:nginx-1.12.2-1.el7.x86_64--&gt; Processing Dependency: nginx-filesystem = 1:1.12.2-1.el7 for package: 1:nginx-1.12.2-1.el7.x86_64--&gt; Processing Dependency: nginx-filesystem for package: 1:nginx-1.12.2-1.el7.x86_64--&gt; Processing Dependency: libprofiler.so.0()(64bit) for package: 1:nginx-1.12.2-1.el7.x86_64--&gt; Running transaction check---&gt; Package gperftools-libs.x86_64 0:2.4-8.el7 will be installed--&gt; Processing Dependency: libunwind.so.8()(64bit) for package: gperftools-libs-2.4-8.el7.x86_64---&gt; Package nginx-all-modules.noarch 1:1.12.2-1.el7 will be installed--&gt; Processing Dependency: nginx-mod-http-geoip = 1:1.12.2-1.el7 for package: 1:nginx-all-modules-1.12.2-1.el7.noarch--&gt; Processing Dependency: nginx-mod-http-image-filter = 1:1.12.2-1.el7 for package: 1:nginx-all-modules-1.12.2-1.el7.noarch--&gt; Processing Dependency: nginx-mod-http-perl = 1:1.12.2-1.el7 for package: 1:nginx-all-modules-1.12.2-1.el7.noarch--&gt; Processing Dependency: nginx-mod-http-xslt-filter = 1:1.12.2-1.el7 for package: 1:nginx-all-modules-1.12.2-1.el7.noarch--&gt; Processing Dependency: nginx-mod-mail = 1:1.12.2-1.el7 for package: 1:nginx-all-modules-1.12.2-1.el7.noarch--&gt; Processing Dependency: nginx-mod-stream = 1:1.12.2-1.el7 for package: 1:nginx-all-modules-1.12.2-1.el7.noarch---&gt; Package nginx-filesystem.noarch 1:1.12.2-1.el7 will be installed--&gt; Running transaction check---&gt; Package libunwind.x86_64 2:1.2-2.el7 will be installed---&gt; Package nginx-mod-http-geoip.x86_64 1:1.12.2-1.el7 will be installed---&gt; Package nginx-mod-http-image-filter.x86_64 1:1.12.2-1.el7 will be installed--&gt; Processing Dependency: gd for package: 1:nginx-mod-http-image-filter-1.12.2-1.el7.x86_64--&gt; Processing Dependency: libgd.so.2()(64bit) for package: 1:nginx-mod-http-image-filter-1.12.2-1.el7.x86_64---&gt; Package nginx-mod-http-perl.x86_64 1:1.12.2-1.el7 will be installed---&gt; Package nginx-mod-http-xslt-filter.x86_64 1:1.12.2-1.el7 will be installed--&gt; Processing Dependency: libxslt.so.1(LIBXML2_1.0.11)(64bit) for package: 1:nginx-mod-http-xslt-filter-1.12.2-1.el7.x86_64--&gt; Processing Dependency: libxslt.so.1(LIBXML2_1.0.18)(64bit) for package: 1:nginx-mod-http-xslt-filter-1.12.2-1.el7.x86_64--&gt; Processing Dependency: libexslt.so.0()(64bit) for package: 1:nginx-mod-http-xslt-filter-1.12.2-1.el7.x86_64--&gt; Processing Dependency: libxslt.so.1()(64bit) for package: 1:nginx-mod-http-xslt-filter-1.12.2-1.el7.x86_64---&gt; Package nginx-mod-mail.x86_64 1:1.12.2-1.el7 will be installed---&gt; Package nginx-mod-stream.x86_64 1:1.12.2-1.el7 will be installed--&gt; Running transaction check---&gt; Package gd.x86_64 0:2.0.35-26.el7 will be installed--&gt; Processing Dependency: libpng15.so.15(PNG15_0)(64bit) for package: gd-2.0.35-26.el7.x86_64--&gt; Processing Dependency: libjpeg.so.62(LIBJPEG_6.2)(64bit) for package: gd-2.0.35-26.el7.x86_64--&gt; Processing Dependency: libpng15.so.15()(64bit) for package: gd-2.0.35-26.el7.x86_64--&gt; Processing Dependency: libjpeg.so.62()(64bit) for package: gd-2.0.35-26.el7.x86_64--&gt; Processing Dependency: libfontconfig.so.1()(64bit) for package: gd-2.0.35-26.el7.x86_64--&gt; Processing Dependency: libXpm.so.4()(64bit) for package: gd-2.0.35-26.el7.x86_64--&gt; Processing Dependency: libX11.so.6()(64bit) for package: gd-2.0.35-26.el7.x86_64---&gt; Package libxslt.x86_64 0:1.1.28-5.el7 will be installed--&gt; Running transaction check---&gt; Package fontconfig.x86_64 0:2.10.95-11.el7 will be installed--&gt; Processing Dependency: fontpackages-filesystem for package: fontconfig-2.10.95-11.el7.x86_64--&gt; Processing Dependency: font(:lang=en) for package: fontconfig-2.10.95-11.el7.x86_64---&gt; Package libX11.x86_64 0:1.6.5-1.el7 will be installed--&gt; Processing Dependency: libX11-common &gt;= 1.6.5-1.el7 for package: libX11-1.6.5-1.el7.x86_64--&gt; Processing Dependency: libxcb.so.1()(64bit) for package: libX11-1.6.5-1.el7.x86_64---&gt; Package libXpm.x86_64 0:3.5.12-1.el7 will be installed---&gt; Package libjpeg-turbo.x86_64 0:1.2.90-5.el7 will be installed---&gt; Package libpng.x86_64 2:1.5.13-7.el7_2 will be installed--&gt; Running transaction check---&gt; Package fontpackages-filesystem.noarch 0:1.44-8.el7 will be installed---&gt; Package libX11-common.noarch 0:1.6.5-1.el7 will be installed---&gt; Package libxcb.x86_64 0:1.12-1.el7 will be installed--&gt; Processing Dependency: libXau.so.6()(64bit) for package: libxcb-1.12-1.el7.x86_64---&gt; Package lyx-fonts.noarch 0:2.2.3-1.el7 will be installed--&gt; Running transaction check---&gt; Package libXau.x86_64 0:1.0.8-2.1.el7 will be installed--&gt; Finished Dependency ResolutionDependencies Resolved============================================================================================================================================== Package Arch Version Repository Size==============================================================================================================================================Installing: nginx x86_64 1:1.12.2-1.el7 epel 529 kInstalling for dependencies: fontconfig x86_64 2.10.95-11.el7 base 229 k fontpackages-filesystem noarch 1.44-8.el7 base 9.9 k gd x86_64 2.0.35-26.el7 base 146 k gperftools-libs x86_64 2.4-8.el7 base 272 k libX11 x86_64 1.6.5-1.el7 base 606 k libX11-common noarch 1.6.5-1.el7 base 164 k libXau x86_64 1.0.8-2.1.el7 base 29 k libXpm x86_64 3.5.12-1.el7 base 55 k libjpeg-turbo x86_64 1.2.90-5.el7 base 134 k libpng x86_64 2:1.5.13-7.el7_2 base 213 k libunwind x86_64 2:1.2-2.el7 base 57 k libxcb x86_64 1.12-1.el7 base 211 k libxslt x86_64 1.1.28-5.el7 base 242 k lyx-fonts noarch 2.2.3-1.el7 epel 159 k nginx-all-modules noarch 1:1.12.2-1.el7 epel 16 k nginx-filesystem noarch 1:1.12.2-1.el7 epel 17 k nginx-mod-http-geoip x86_64 1:1.12.2-1.el7 epel 23 k nginx-mod-http-image-filter x86_64 1:1.12.2-1.el7 epel 26 k nginx-mod-http-perl x86_64 1:1.12.2-1.el7 epel 35 k nginx-mod-http-xslt-filter x86_64 1:1.12.2-1.el7 epel 25 k nginx-mod-mail x86_64 1:1.12.2-1.el7 epel 53 k nginx-mod-stream x86_64 1:1.12.2-1.el7 epel 76 kTransaction Summary==============================================================================================================================================Install 1 Package (+22 Dependent packages)Total download size: 3.3 MInstalled size: 9.8 MDownloading packages:(1/23): fontpackages-filesystem-1.44-8.el7.noarch.rpm | 9.9 kB 00:00:00 (2/23): fontconfig-2.10.95-11.el7.x86_64.rpm | 229 kB 00:00:00 (3/23): gd-2.0.35-26.el7.x86_64.rpm | 146 kB 00:00:00 (4/23): gperftools-libs-2.4-8.el7.x86_64.rpm | 272 kB 00:00:00 (5/23): libX11-1.6.5-1.el7.x86_64.rpm | 606 kB 00:00:00 (6/23): libX11-common-1.6.5-1.el7.noarch.rpm | 164 kB 00:00:00 (7/23): libXau-1.0.8-2.1.el7.x86_64.rpm | 29 kB 00:00:00 (8/23): libXpm-3.5.12-1.el7.x86_64.rpm | 55 kB 00:00:00 (9/23): libjpeg-turbo-1.2.90-5.el7.x86_64.rpm | 134 kB 00:00:00 (10/23): libpng-1.5.13-7.el7_2.x86_64.rpm | 213 kB 00:00:00 (11/23): libunwind-1.2-2.el7.x86_64.rpm | 57 kB 00:00:00 (12/23): libxcb-1.12-1.el7.x86_64.rpm | 211 kB 00:00:00 (13/23): libxslt-1.1.28-5.el7.x86_64.rpm | 242 kB 00:00:00 (14/23): lyx-fonts-2.2.3-1.el7.noarch.rpm | 159 kB 00:00:00 (15/23): nginx-all-modules-1.12.2-1.el7.noarch.rpm | 16 kB 00:00:00 (16/23): nginx-filesystem-1.12.2-1.el7.noarch.rpm | 17 kB 00:00:00 (17/23): nginx-mod-http-geoip-1.12.2-1.el7.x86_64.rpm | 23 kB 00:00:00 (18/23): nginx-1.12.2-1.el7.x86_64.rpm | 529 kB 00:00:00 (19/23): nginx-mod-http-image-filter-1.12.2-1.el7.x86_64.rpm | 26 kB 00:00:00 (20/23): nginx-mod-http-perl-1.12.2-1.el7.x86_64.rpm | 35 kB 00:00:00 (21/23): nginx-mod-http-xslt-filter-1.12.2-1.el7.x86_64.rpm | 25 kB 00:00:00 (22/23): nginx-mod-stream-1.12.2-1.el7.x86_64.rpm | 76 kB 00:00:00 (23/23): nginx-mod-mail-1.12.2-1.el7.x86_64.rpm | 53 kB 00:00:00 ----------------------------------------------------------------------------------------------------------------------------------------------Total 9.2 MB/s | 3.3 MB 00:00:00 Running transaction checkRunning transaction testTransaction test succeededRunning transactionWarning: RPMDB altered outside of yum.** Found 2 pre-existing rpmdb problem(s), 'yum check' output follows:2:postfix-2.10.1-6.el7.x86_64 has missing requires of libmysqlclient.so.18()(64bit)2:postfix-2.10.1-6.el7.x86_64 has missing requires of libmysqlclient.so.18(libmysqlclient_18)(64bit) Installing : fontpackages-filesystem-1.44-8.el7.noarch 1/23 Installing : lyx-fonts-2.2.3-1.el7.noarch 2/23 Installing : fontconfig-2.10.95-11.el7.x86_64 3/23 Installing : libXau-1.0.8-2.1.el7.x86_64 4/23 Installing : libxcb-1.12-1.el7.x86_64 5/23 Installing : libX11-common-1.6.5-1.el7.noarch 6/23 Installing : libX11-1.6.5-1.el7.x86_64 7/23 Installing : libXpm-3.5.12-1.el7.x86_64 8/23 Installing : 2:libunwind-1.2-2.el7.x86_64 9/23 Installing : gperftools-libs-2.4-8.el7.x86_64 10/23 Installing : libxslt-1.1.28-5.el7.x86_64 11/23 Installing : 2:libpng-1.5.13-7.el7_2.x86_64 12/23 Installing : 1:nginx-filesystem-1.12.2-1.el7.noarch 13/23 Installing : libjpeg-turbo-1.2.90-5.el7.x86_64 14/23 Installing : gd-2.0.35-26.el7.x86_64 15/23 Installing : 1:nginx-mod-http-xslt-filter-1.12.2-1.el7.x86_64 16/23 Installing : 1:nginx-mod-stream-1.12.2-1.el7.x86_64 17/23 Installing : 1:nginx-mod-http-geoip-1.12.2-1.el7.x86_64 18/23 Installing : 1:nginx-mod-http-perl-1.12.2-1.el7.x86_64 19/23 Installing : 1:nginx-mod-mail-1.12.2-1.el7.x86_64 20/23 Installing : 1:nginx-1.12.2-1.el7.x86_64 21/23 Installing : 1:nginx-mod-http-image-filter-1.12.2-1.el7.x86_64 22/23 Installing : 1:nginx-all-modules-1.12.2-1.el7.noarch 23/23 Verifying : libX11-1.6.5-1.el7.x86_64 1/23 Verifying : lyx-fonts-2.2.3-1.el7.noarch 2/23 Verifying : libjpeg-turbo-1.2.90-5.el7.x86_64 3/23 Verifying : 1:nginx-filesystem-1.12.2-1.el7.noarch 4/23 Verifying : 2:libpng-1.5.13-7.el7_2.x86_64 5/23 Verifying : 1:nginx-mod-http-xslt-filter-1.12.2-1.el7.x86_64 6/23 Verifying : 1:nginx-all-modules-1.12.2-1.el7.noarch 7/23 Verifying : fontpackages-filesystem-1.44-8.el7.noarch 8/23 Verifying : 1:nginx-1.12.2-1.el7.x86_64 9/23 Verifying : 1:nginx-mod-stream-1.12.2-1.el7.x86_64 10/23 Verifying : 1:nginx-mod-http-image-filter-1.12.2-1.el7.x86_64 11/23 Verifying : libXpm-3.5.12-1.el7.x86_64 12/23 Verifying : 1:nginx-mod-http-geoip-1.12.2-1.el7.x86_64 13/23 Verifying : libxcb-1.12-1.el7.x86_64 14/23 Verifying : gperftools-libs-2.4-8.el7.x86_64 15/23 Verifying : libxslt-1.1.28-5.el7.x86_64 16/23 Verifying : gd-2.0.35-26.el7.x86_64 17/23 Verifying : 2:libunwind-1.2-2.el7.x86_64 18/23 Verifying : 1:nginx-mod-http-perl-1.12.2-1.el7.x86_64 19/23 Verifying : libX11-common-1.6.5-1.el7.noarch 20/23 Verifying : libXau-1.0.8-2.1.el7.x86_64 21/23 Verifying : fontconfig-2.10.95-11.el7.x86_64 22/23 Verifying : 1:nginx-mod-mail-1.12.2-1.el7.x86_64 23/23 Installed: nginx.x86_64 1:1.12.2-1.el7 Dependency Installed: fontconfig.x86_64 0:2.10.95-11.el7 fontpackages-filesystem.noarch 0:1.44-8.el7 gd.x86_64 0:2.0.35-26.el7 gperftools-libs.x86_64 0:2.4-8.el7 libX11.x86_64 0:1.6.5-1.el7 libX11-common.noarch 0:1.6.5-1.el7 libXau.x86_64 0:1.0.8-2.1.el7 libXpm.x86_64 0:3.5.12-1.el7 libjpeg-turbo.x86_64 0:1.2.90-5.el7 libpng.x86_64 2:1.5.13-7.el7_2 libunwind.x86_64 2:1.2-2.el7 libxcb.x86_64 0:1.12-1.el7 libxslt.x86_64 0:1.1.28-5.el7 lyx-fonts.noarch 0:2.2.3-1.el7 nginx-all-modules.noarch 1:1.12.2-1.el7 nginx-filesystem.noarch 1:1.12.2-1.el7 nginx-mod-http-geoip.x86_64 1:1.12.2-1.el7 nginx-mod-http-image-filter.x86_64 1:1.12.2-1.el7 nginx-mod-http-perl.x86_64 1:1.12.2-1.el7 nginx-mod-http-xslt-filter.x86_64 1:1.12.2-1.el7 nginx-mod-mail.x86_64 1:1.12.2-1.el7 nginx-mod-stream.x86_64 1:1.12.2-1.el7 Complete![root@izbp109iqt20o2h63tpcuvz java]# 查看安装结果1rpm -qa | grep nginx 控制台输出:12345678910[root@izbp109iqt20o2h63tpcuvz java]# rpm -qa | grep nginxnginx-mod-http-perl-1.12.2-1.el7.x86_64nginx-all-modules-1.12.2-1.el7.noarchnginx-mod-http-xslt-filter-1.12.2-1.el7.x86_64nginx-mod-mail-1.12.2-1.el7.x86_64nginx-filesystem-1.12.2-1.el7.noarchnginx-mod-stream-1.12.2-1.el7.x86_64nginx-1.12.2-1.el7.x86_64nginx-mod-http-geoip-1.12.2-1.el7.x86_64nginx-mod-http-image-filter-1.12.2-1.el7.x86_64 配置 启动Nginx 1[root@izbp109iqt20o2h63tpcuvz java]# systemctl start nginx 查看启动结果 注意绿色的 active (running)，表明启动成功123456789101112131415161718查看启动状态[root@izbp109iqt20o2h63tpcuvz java]# systemctl status nginx● nginx.service - The nginx HTTP and reverse proxy server Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled) Active: active (running) since Tue 2018-01-23 19:36:18 CST; 29s ago Main PID: 24724 (nginx) CGroup: /system.slice/nginx.service ├─24724 nginx: master process /usr/sbin/nginx ├─24725 nginx: worker process ├─24726 nginx: worker process ├─24727 nginx: worker process └─24728 nginx: worker processJan 23 19:36:18 izbp109iqt20o2h63tpcuvz systemd[1]: Starting The nginx HTTP and reverse proxy server...Jan 23 19:36:18 izbp109iqt20o2h63tpcuvz nginx[24719]: nginx: the configuration file /etc/nginx/nginx.conf syntax is okJan 23 19:36:18 izbp109iqt20o2h63tpcuvz nginx[24719]: nginx: configuration file /etc/nginx/nginx.conf test is successfulJan 23 19:36:18 izbp109iqt20o2h63tpcuvz systemd[1]: Started The nginx HTTP and reverse proxy server.[root@izbp109iqt20o2h63tpcuvz java]# 设置Nginx开机启动 12[root@izbp109iqt20o2h63tpcuvz java]# systemctl enable nginxCreated symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service. 测试NginxNginx默认端口号为80，一般情况下服务器的80端口也是开放的，因此在直接输入主机公网IP地址即可看见Nginx的主界面 Welcome to nginx on Fedora! 表明配置成功。 默认页面位于/usr/share/nginx/html/index.html,而/usr/share/nginx/html是Nginx默认的根目录。如果觉得不方便，可以在配置文件中修改根目录位置，同时注意由于目录权限问题导致的403Forbidden。 配置文件说明配置文件路径 /etc/nginx/nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#运行用户user nginx;#启动进程,通常设置成和 cpu 的数量相等worker_processes 1;#全局错误日志及 PID 文件#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;#工作模式及连接数上限events &#123;#epoll 是多路复用 IO(I/O Multiplexing)中的一种方式,#仅用于 linux2.6 以上内核,可以大大提高 nginx 的性能use epoll;#单个后台 worker process 进程的最大并发链接数worker_connections 1024;# 并发总数是 worker_processes 和 worker_connections 的乘积# 即 max_clients = worker_processes * worker_connections# 在设置了反向代理的情况下， max_clients = worker_processes * worker_connections / 4为什么# 为什么上面反向代理要除以 4，应该说是一个经验值# 根据以上条件，正常情况下的 Nginx Server 可以应付的最大连接数为： 4 * 8000 = 32000# worker_connections 值的设置跟物理内存大小有关# 因为并发受 IO 约束， max_clients 的值须小于系统可以打开的最大文件数# 而系统可以打开的最大文件数和内存大小成正比，一般 1GB 内存的机器上可以打开的文件数大约是10 万左右# 我们来看看 360M 内存的 VPS 可以打开的文件句柄数是多少：# $ cat /proc/sys/fs/file-max# 输出 34336# 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内# 所以， worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置# 使得并发总数小于操作系统可以打开的最大文件数目# 其实质也就是根据主机的物理 CPU 和内存进行配置# 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。# ulimit -SHn 65535&#125;http &#123; #设定 mime 类型,类型由 mime.type 文件定义 include mime.types; default_type application/octet-stream; #设定日志格式 log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（ zero copy 方式）来输出文件， #对于普通应用，必须设为 on, #如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off， #以平衡磁盘与网络 I/O 处理速度，降低系统的 uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; #开启 gzip 压缩 gzip on; gzip_disable "MSIE [1-6]."; #nginx 传输文件大小，默认为1M client_max_body_size 20m; client_header_buffer_size 32k; large_client_header_buffers 4 32k; #设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; #设定虚拟主机配置 server &#123; #侦听 80 端口 listen 80; #定义使用 www.linuxidc.com 访问 server_name www.linuxidc.com; #定义服务器的默认网站根目录位置 root html; #设定本虚拟主机的访问日志 access_log logs/nginx.access.log main; #默认请求 location / &#123; #定义首页索引文件的名称 index index.php index.html index.htm; &#125; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # 静态文件， nginx 自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; #过期 30 天，静态文件不怎么更新，过期可以设大一点， #如果频繁更新，则可以设置得小一点。 expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI 处理. 使用 FastCGI 默认配置. location ~ .php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; # 禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125; &#125;&#125; 参考链接,感谢前辈: http://www.linuxidc.com/Linux/2017-04/142986.htm （完）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux-Centos7系统解决端口占用问题]]></title>
    <url>%2F2018%2F01%2F14%2FLinux-Centos7%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[服务器为Linux-Centos7系统 , 昨天发生了一个非常诡异的情况 , tomcat在已关闭的情况下 , 依然显示其8080端口被占用 , 最后定位到占用端口的进程 , 解决问题 . 1.查看占用端口的进程netstat -lnp|grep 8080 [root@izbp109iqt20o2h63tpcuvz java]# netstat -lnp|grep 8080 tcp6 0 0 :::8080 :::* LISTEN 4486/java 可以看到 , 是4486的一个java进程占用了8080端口. 2.查看进程信息 ps 4486 [root@izbp109iqt20o2h63tpcuvz java]# ps 4486 PID TTY STAT TIME COMMAND 4486 ? Sl 1:16 /usr/local/java/jdk1.8.0_152/jre/bin/java -Djava.util.logging.config.file=/usr/local/j 日志相关的程序 3.强杀进程 kill -9 4486 [root@izbp109iqt20o2h63tpcuvz java]# kill -9 4486 [root@izbp109iqt20o2h63tpcuvz java]# netstat -lnp|grep 8080 [root@izbp109iqt20o2h63tpcuvz java]# 杀死进程之后,再次查看端口占用,发现已经不存在端口占用了.问题解决. 完整的操作记录如下: [root@izbp109iqt20o2h63tpcuvz java]# netstat -lnp|grep 8080 tcp6 0 0 :::8080 :::* LISTEN 4486/java [root@izbp109iqt20o2h63tpcuvz java]# ps 4486 PID TTY STAT TIME COMMAND 4486 ? Sl 1:16 /usr/local/java/jdk1.8.0_152/jre/bin/java -Djava.util.logging.config.file=/usr/local/j [root@izbp109iqt20o2h63tpcuvz java]# kill -9 4486 [root@izbp109iqt20o2h63tpcuvz java]# netstat -lnp|grep 8080 [root@izbp109iqt20o2h63tpcuvz java]# (完)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP开发环境搭建(windows)]]></title>
    <url>%2F2018%2F01%2F09%2FPHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-windows%2F</url>
    <content type="text"><![CDATA[终于入坑”世界上最好的语言-PHP”,从性能和严谨度上来说,不如Java;从发展趋势来说,不如Go和Python,但是个人认为PHP是目前最适合公司发展的语言,起码2年内是这样的,作为一名技术人员,根据业务发展需要进行技术选型和自我调整,而不是根据自己的技术栈积累去选择业务方向,应该是一个基本准则,所以,果断入坑. PHP有很多集成开发环境,比如Wamp,Appserv等.但是自己电脑上运行着java程序,tomcat,nginx,mysql等都是配置好的,而且平时也需要进行JavaEE的开发,所以没必要用集成环境.这里记录下单独配置Apche和PHP的工作日志. Apache下载Apache官网下载页面 选择对应的版本和平台,比如windows平台选择Files for Microsoft Windows --&gt; ApacheHaus,然后下载指定的包即可,现在的发开电脑一般都是64位了. 配置定位到Apache安装目录下的conf目录,这是Apache的配置目录,比如D:\Dev\Apache24\conf,打开httpd.conf配置文件 1.配置根目录 配置Apache的安装目录的根目录,比如: 12Define SRVROOT &quot;D:/Dev/Apache24&quot;ServerRoot &quot;$&#123;SRVROOT&#125;&quot; 如果这里不配置,那么稍后安装Apache为系统服务时,会报出如下异常信息: Errors reported here must be corrected before the service can be started.httpd.exe: Syntax error on line 39 of D:/Dev/Apache24/conf/httpd.conf: ServerRoot must be a valid directory 即ServerRoot必须为一个合法有效的目录 2.配置端口 搜索定位到如下内容,Apache默认端口为80,为了避免端口冲突,也可以修改为其他端口.如果使用默认的80端口,则通过http://localhost即可访问,如果使用修改后的端口,则必须加端口号,比如http://localhost:8888 12#Listen 12.34.56.78:80Listen 8888 安装服务将Apache安装/卸载 为系统服务 1234//安装D:\Dev\Apache24\bin\httpd.exe&quot; -k install -n apache//卸载D:\Dev\Apache24\bin\httpd.exe&quot; -k uninstall -n apache 异常信息Apache 安装时出现 Failed to open the Windows service manager, perhaps you forgot to log in as Adminstrator 此时应以管理员身份运行DOS窗口,定位到C:\Windows\System32\cmd.exe,右键以管理员身份运行即可. 安装成功 1234C:\Windows\system32&gt;&quot;D:\Dev\Apache24\bin\httpd.exe&quot; -k install -n apacheInstalling the &apos;apache&apos; serviceThe &apos;apache&apos; service is successfully installed.Testing httpd.conf.... 测试Apache打开Apche/bin目录下的ApacheMonitor.exe,可以测试启动Apache,根据是否修改Apache默认端口号,打开http://localhost(默认)或http://localhost:8888(自定义端口). 如果页面出现It workds!表示Apache启动成功. 参考链接: https://jingyan.baidu.com/article/29697b912f6539ab20de3cf8.html http://www.cnblogs.com/yerenyuan/p/5460336.html PHP下载https://secure.php.net/downloads.php 里面有linux和windows下的安装包,目前办公电脑是windows系统,所以选择的windows包,windows安装包下载链接直达http://windows.php.net/download/ 配置Apache支持PHP 打开D:\Dev\Apache24\conf\httpd.conf配置文件 定位到 1#LoadModule vhost_alias_module modules/mod_vhost_alias.so 在下方添加 123LoadModule php7_module &quot;D:/Dev/PHP7/php7apache2_4.dll&quot;PHPIniDir &quot;D:/Dev/PHP7&quot;AddType application/x-httpd-php .php .html .htm 注意,我这里安装的是PHP7,如果是PHP5,则里面对应换成php5_module,php5apache2_4.dll等. 找到如下代码 123&lt;IfModule dir_module&gt; DirectoryIndex index.html&lt;/IfModule&gt; 改为 123&lt;IfModule dir_module&gt; DirectoryIndex index.php index.html&lt;/IfModule&gt; 修改Apache默认的站点目录 12DocumentRoot &quot;$&#123;SRVROOT&#125;/htdocs&quot;&lt;Directory &quot;$&#123;SRVROOT&#125;/htdocs&quot;&gt; 修改为 12DocumentRoot &quot;D:/Code/PHP&quot;&lt;Directory &quot;D:/Code/PHP&quot;&gt; 之后这个目录就是打开http://localhost:8888时的根目录,可以在该目录创建index.php,用于默认访问的php文件. 配置PHP 1.修改配置文件名 把PHP安装目录的D:\Dev\PHP7\php.ini-development改名为php.ini，作为PHP的配置文件。 接下来开始编辑php.ini文件 2.设置PHP扩展包的具体目录 找到 12; On windows:; extension_dir = &quot;ext&quot; 修改为12; On windows:extension_dir = &quot;D:\Dev\PHP7\ext&quot; 3.开启相应的库功能 默认提供了大量的库,需要开启哪个,去掉前面的分号(注释)即可 1234567891011121314151617181920212223;extension=bz2extension=curl;extension=fileinfoextension=gd2;extension=gettext;extension=gmp;extension=intl;extension=imap;extension=interbase;extension=ldapextension=mbstring;extension=exif ; Must be after mbstring as it depends on itextension=mysqli;extension=oci8_12c ; Use with Oracle Database 12c Instant Client;extension=openssl;extension=pdo_firebird;extension=pdo_mysql;extension=pdo_oci;extension=pdo_odbc;extension=pdo_pgsql;extension=pdo_sqlite;extension=pgsql;extension=shmop 4.设置时区 找到 1;date.timezone = 设置 1date.timezone = Asia/Shanghai 测试PHP重启Apache，在站点目录下新建文件index.php，输入内容： 123&lt;?php phpinfo();?&gt; 打开http://localhost:8888,如果显示PHP版本及配置信息,则表示配置成功. 参考: https://www.cnblogs.com/pharen/archive/2012/02/06/2340628.html 其他问题开启mod_rewritehttps://www.cnblogs.com/li-mei/p/5959217.html 开启curl模块 编辑PHP配置文件php.ini,开启curl模块,;extension=php_curl.dll,将开头的分号去掉 在安装目录中，找到libeay32.dll和ssleay32.dll两个文件，将他们复制到 C:\windows\system32 中； 在安装目录中，打开 ext 目录，找到 php_curl.dll 文件，统一将其复制到 C:\windows\system32 中； 4 .重要: 将PHP的安装目录(比如D:\Dev\PHP7)添加到系统的Path环境变量中重新启动 Apache。配置即可生效]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mysql工作日志]]></title>
    <url>%2F2017%2F12%2F14%2FMysql%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[MySQL连接数当前连接数 mysql &gt; show status like &apos;Threads%&apos;; 最大连接数: mysql &gt; show global variables like &apos;max_conn%&apos;; 设置连接数: mysql &gt; set global max_connections=1000; mysql &gt; set global max_connect_errors=1000; 注意mysql关键词异常信息: 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;order ...at line 1 解决方案：看看自己定义的sql语句，比如mybatis时的xml文件中，该语句的第1行是否有错误(基本不用怀疑,肯定有错误)。 自己的问题：把mysql的关键字定义为了表的名字，导致sql语句出错。比如order，option等都是关键字，定义表名时应避开这些关键字。 日志查看是否启用了日志 mysql&gt;show variables like &apos;log_%&apos;;]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用Spring Task实现定时任务]]></title>
    <url>%2F2017%2F12%2F14%2F%E4%BD%BF%E7%94%A8Spring-Task%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[项目中实现定时任务有多种方式，除了TimerTask这种小工具之外，以下两种比较常用： Spring Task Quartz 项目中暂时没有用Quartz，本次使用的是Spring框架封装的定时任务工具，使用起来比较简单。 添加命名空间如果要使用Spring Task，需要在spring配置文件里增加如下内容： 1234567891011&lt;beans xmlns="http://www.springframework.org/schema/beans" ... xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="http://www.springframework.org/schema/beans .... http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd"&gt; ...&lt;/bean&gt; 举例，自己项目中的Spring.xml文件内容如下: 12345678910111213141516&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd"&gt; ...&lt;/bean&gt; 配置Task注解扫描在spring.xml文件中配置自动扫描包路径 和 Task注解扫描: 123456&lt;!--扫描标记@Scheduled注解的定时任务--&gt;&lt;task:annotation-driven/&gt;&lt;!--扫描路径--&gt;&lt;context:component-scan base-package="com.crocutax.test.schedule"/&gt; 注意 如果上一步没有配置好，即使这里已经配置了驱动及扫描，运行的时候依然会报如下异常： Caused by: org.xml.sax.SAXParseException; lineNumber: 62; columnNumber: 30; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ‘task:annotation-driven’ 的声明。 定义定时任务在想要定时执行的方法上添加@Scheduled注解，及Cron表达式即可。 12345678@Componentpublic class TimeoutTask &#123; @Scheduled(cron = "0 0 */1 * * ?") //每1小时执行一次 public void test() &#123; System.out.println("定时任务执行了............."); &#125;&#125; 方法中定义了需要执行的任务，这里只打印了log，项目中则是定时检查数据库中某些表的信息。 标记了@Scheduled注解的方法会被第二步配置的扫描器扫描到，注入Spring容器，执行该方法中的任务。 Cron表达式则定义了执行该任务的周期，频率。 SpringTask和Quartz使用的Cron语法是一样的。 异常处理如果出现如下异常 DEBUG [RMI TCP Connection(5)-127.0.0.1] - Could not find default ScheduledExecutorService beanorg.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type ‘java.util.concurrent.ScheduledExecutorService’ available 是因为没有找到默认的调度器导致的,该异常并不影响程序运行,可以通过调整Log级别来屏蔽这些异常信息,见 http://blog.csdn.net/chwshuang/article/details/52840539 参考链接: http://www.ibloger.net/article/2636.html http://www.jianshu.com/p/13623119cb5b http://www.what21.com/sys/view/java_java-frame_1478840380252.html (完)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo持续优化-添加本地搜索功能]]></title>
    <url>%2F2017%2F12%2F10%2FHexo%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96-%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[Next官网–&gt;第三方服务–&gt;搜索服务 中已经有详细的介绍了,主题内置了4种搜索方式: Swiftype 微搜索 Local Search Algolia 由于自己的博客主要用于工作日志的记录,以及工作时的快速定位查询,因此选择了第三种方式Local Search,即本地搜索. 安装搜索插件在Hexo根目录执行如下命令1$ npm install hexo-generator-searchdb --save 编辑站点配置文件在站点配置文件(Hexo根目录的配置文件)_config.yml中添加 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件,启用本地搜索在主题配置文件(Next主题根目录的配置文件)_config.yml中启用123# Local searchlocal_search: enable: true 注:以上内容在Next官网本地搜索模块有详细介绍,在此只为记录. (完)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux下启动tomcat后,浏览器无法访问]]></title>
    <url>%2F2017%2F12%2F10%2Flinux%E4%B8%8B%E5%90%AF%E5%8A%A8tomcat%E5%90%8E-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[Centos服务器,本地和服务器ip互ping正常(本机ping服务器,服务器ping本地),但是服务器上部署好tomcat后,本机却无法通过浏览器访问服务器tomcat的8080端口. 比如服务器公网ip为:123.123.123.123,启动tomcat后默认端口为8080,通过123.123.123.123:8080访问时,无法访问tomcat默认页面.考虑是服务器防火墙的问题. 确认tomcat已开启1$ ps -ef|grep tomcat 控制台输出,表明tomcat已处于开启状态 12root 1428 1 0 Dec08 ? 00:02:16 /usr/local/java/jdk1.8.0_152/jre/bin/java -Djava.util.logging.config.file=/usr/local/java/tomcat8/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -classpath /usr/local/java/tomcat8/bin/bootstrap.jar:/usr/local/java/tomcat8/bin/tomcat-juli.jar -Dcatalina.base=/usr/local/java/tomcat8 -Dcatalina.home=/usr/local/java/tomcat8 -Djava.io.tmpdir=/usr/local/java/tomcat8/temp org.apache.catalina.startup.Bootstrap startroot 4932 4069 0 09:16 pts/0 00:00:00 grep --color=auto tomcat 如果tomcat未开启,则通过tomcat的startup.sh命令开启,直接输入文件所在的路径即可. 1$ /usr/local/java/tomcat8/bin/startup.sh 控制台输出: 1234567[root@izbp109iqt20o2h63tpcuvz ~]# /usr/local/java/tomcat8/bin/startup.sh Using CATALINA_BASE: /usr/local/java/tomcat8Using CATALINA_HOME: /usr/local/java/tomcat8Using CATALINA_TMPDIR: /usr/local/java/tomcat8/tempUsing JRE_HOME: /usr/local/java/jdk1.8.0_152/jreUsing CLASSPATH: /usr/local/java/tomcat8/bin/bootstrap.jar:/usr/local/java/tomcat8/bin/tomcat-juli.jarTomcat started. Tomcat started.表明tomcat已开启成功! 配置防火墙编辑防火墙配置 1$ vi /etc/sysconfig/iptables 添加8080端口的防火墙,允许访问. 12345678910111213*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibited 注意!非常关键:端口的配置必须要在如下配置的上方,放在下方无效. 12-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibited 输入i开始编辑,ESC键结束编辑,WQ保存并退出. 重启防火墙 1$ service iptables restart 之后就可以在本机通过浏览器访问123.123.123.123:8080,就可以正常看到tomcat的默认欢迎页面了. (完) 参考链接: http://blog.csdn.net/itzhangdaopin/article/details/62044620]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用hexo-qiniu-sync插件配合七牛云实现博客图床管理]]></title>
    <url>%2F2017%2F12%2F07%2F%E4%BD%BF%E7%94%A8hexo-qiniu-sync%E6%8F%92%E4%BB%B6%E9%85%8D%E5%90%88%E4%B8%83%E7%89%9B%E4%BA%91%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[简介对于为什么选择七牛云作为博客图床就不说了,直接记录过程. 之前管理博客中的图片,流程如下: 将图片保存在本地 本地图片上传七牛云 复制图片外链 md文件中引入图片外链 删除本地图片 使用了hexo-qiniu-sync插件之后,流程如下: 将图片保存在指定目录下 在md中引用图片即可 其他优点: 本地统一管理博客图片 自动上传七牛云 七牛高级图片处理功能扩展使用 配置注册七牛云 注册 七牛云 创建存储空间,添加”对象存储”,访问控制选择”公开空间” 右上角个人面板–&gt;密钥管理–&gt;获取AK(AccessKey)和SK(SecretKey) hexo配置hexo-qiniu-sync GitHub上已经有详细的步骤介绍了,这里只是记录一下. 在hexo主目录运行如下命令安装hexo-qiniu-sync插件 1npm install hexo-qiniu-sync --save 在hexo主目录的_config.yml文件中配置 123456789101112131415161718plugins:qiniu: offline: false sync: true bucket: &#123;your qiniu bucket name&#125; access_key: &#123;your AK&#125; secret_key: &#123;your SK&#125; dirPrefix: urlPrefix: &#123;your qiniu domain,for example:http://xxxxxx.xxx.clouddn.com&#125; local_dir: static update_exist: true image: folder: images extend: js: folder: js css: folder: css 说明 12345678910111213141516七牛云存储设置offline 是否离线. 离线状态将使用本地地址渲染sync 是否同步bucket 空间名称.access_key 上传密钥AccessKeysecret_key 上传密钥SecretKeysecret_file 秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可dirPrefix 上传的资源子目录前缀.如设置，需与urlPrefix同步 urlPrefix 外链前缀.up_host 上传服务器路径,如选择华北区域的话配置为http://up-z1.qiniu.comlocal_dir 本地目录.update_exist 是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)image/js/css 子参数folder为不同静态资源种类的目录名称，一般不需要改动image.extend 这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http://developer.qiniu.com/docs/v6/api/reference/fop/image/ 可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图 注意,一定不能在配置文件中做如下配置,否则hexo s和hexo d命令会出问题. 12plugins: - hexo-qiniu-sync 虽然官方文档已经提示了这一点,但是自己大意了,还是掉坑里了. 使用上一步配置好以后,执行hexo s命令,会自动在hexo主目录创建如下目录结构: 1234567node_modulespublicstatic // 静态资源目录 - css //css文件存储目录 - images //图片存储目录 - js //js文件存储目录... 将本地图片放在images目录下,在md文件中以如下方式引入文件即可:1&#123;% qnimg 图片名称.jpg %&#125; 在部署过程中,会出现如下命令: 123INFO Now start qiniu sync.INFO Need upload file num: 4Please run `hexo qiniu sync` to sync. 提示有待上传的文件,让运行hexo qiniu sync命令进行文件上传,但是我发现其实他已经自动上传了.在4000端口的本地服务上可以正常预览,并且在七牛云空间里已经可以看到了.感谢开源的前辈们! 后续有机会会把七牛云图片高级处理再研究使用下,本次暂时到这里. 参考链接: https://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/ (推荐) http://www.ixirong.com/2016/10/31/how-to-use-hexo-qiniu-sync-plugin/ (完)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bin目录下没有svn.exe文件]]></title>
    <url>%2F2017%2F12%2F07%2Fbin%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%B2%A1%E6%9C%89svn.exe%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[AndroidStudio编译过程中出现如下异常信息: can&apos;t use subversion command line client : svn .Probably the path to Subversion executable is wrong. Fix it.. 在AndroidStudio中如果需要使用SVN的话需要指定svn.exe的路径,如果路径不正确,或者指定路径下比如TortoiseSVN\bin目录下没有svn.exe文件,就会报出这个异常. 此时重新安装SVN,在安装SVN的过程中有一个command line client tools默认是不安装的,如下图: 在安装过程中勾选安装即可 安装完毕,svn.exe文件就出现在bin目录下了. (完)]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea编码设置]]></title>
    <url>%2F2017%2F11%2F26%2FIdea%E7%BC%96%E7%A0%81%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[编码不统一,会导致出其不意的乱码或不易察觉的错误,在使用Idea开发的过程中,有几个可以设置编码的地方,整理如下: 当前文件在Idea中打开任意一个文件时,在工作台的右下角,会有一个显示文件编码的地方,一般都是UTF-8,但是不排除有网上clone下来的项目,编码是GBK的情况. 当前项目File-&gt;Settings-&gt;Editor-&gt;File Encodings 这种方式修改的文件编码方式只对当前 project 起作用，每次新建了一个工程后还需要重新设置编码方式。 所有Idea项目File-&gt;Other Settings-&gt;Default Settings-&gt;Editor-&gt;File Encodings 这里设置的是默认的文件编码方式，所有新建的工程使用的都是默认的文件编码方式。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取手机联系人]]></title>
    <url>%2F2017%2F11%2F26%2FAndroid%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E8%81%94%E7%B3%BB%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[获取手机中的联系人信息,以下代码仅做记录. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class MainActivity extends AppCompatActivity &#123; /** * 所有的联系人信息 */ private Cursor personCur; /** * 所有联系人电话号码 */ private Cursor numberCur; /** * 联系人的信息集合 */ List&lt;String&gt; list= new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getAllContancts(); &#125; /** * 获取通讯录中的联系人及号码 */ private void getAllContancts() &#123; // 获取手机通讯录信息 ContentResolver resolver = this.getContentResolver(); // 获取联系人信息 personCur = resolver.query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null); if (personCur == null) &#123; try &#123;//此处适配了6.0权限 Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.parse("package:" + getPackageName())); startActivity(intent); &#125; catch (Exception e) &#123; Intent intentSet = new Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS); startActivity(intentSet); &#125; return; &#125; // 循环遍历，获取每个联系人的姓名和电话号码 while (personCur.moveToNext()) &#123; // 联系人姓名 String cname = ""; // 联系人电话 String cnum = ""; // 联系人id号码 String ID; ID = personCur.getString(personCur.getColumnIndex(ContactsContract.Contacts._ID)); // 联系人姓名 cname = personCur.getString(personCur.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)); // id的整型数据 int id = Integer.parseInt(ID); if (id &gt; 0) &#123; // 获取指定id号码的电话号码 Cursor c = resolver.query( ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID + "=" + ID, null, null); // 遍历游标 while (c.moveToNext()) &#123; cnum = c.getString(c.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); if (!TextUtils.isEmpty(cname) ) list.add(cname);//查询通讯录中所有联系人 &#125; if (c != null &amp;&amp; !c.isClosed()) c.close(); &#125; &#125; try &#123; if (personCur != null &amp;&amp; !personCur.isClosed()) &#123; personCur.close(); &#125; &#125; catch (Exception e) &#123; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>工作日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android监听手机短信]]></title>
    <url>%2F2017%2F11%2F26%2FAndroid%E7%9B%91%E5%90%AC%E6%89%8B%E6%9C%BA%E7%9F%AD%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[有两种实现方式,监听短信和监听短信数据库. 方式一:短信监听以下情况可能会导致短信拦截失败: 小米,360等品牌手机拦截短信,短信的优先级给了系统 用户禁用短信权限 手机连接电脑,被电脑端的手机助手类软件截获 手机内装有QQ通讯录之类的管理联系人,短信的应用,被截获. 定义短信广播接收者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SMSBroadcastReceiver extends BroadcastReceiver &#123; private static OnReceivedMessageListener mOnReceivedMessageListener; public static final String SMS_RECEIVED_ACTION = "android.provider.Telephony.SMS_RECEIVED"; public SMSBroadcastReceiver() &#123; super(); &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(SMS_RECEIVED_ACTION)) &#123; Object[] pdus = (Object[]) intent.getExtras().get("pdus"); for(Object pdu:pdus) &#123; SmsMessage smsMessage = SmsMessage.createFromPdu((byte [])pdu); String sender = smsMessage.getDisplayOriginatingAddress(); String content = smsMessage.getDisplayMessageBody(); long date = smsMessage.getTimestampMillis(); Date tiemDate = new Date(date); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String time = simpleDateFormat.format(tiemDate); //过滤不需要读取的短信的发送号码 if ("106902780116481".equals(sender)) &#123; mOnReceivedMessageListener.onReceived(getDynamicPassword(content)); abortBroadcast(); &#125; &#125; &#125; &#125; public interface OnReceivedMessageListener &#123; void onReceived(String message); &#125; public void setOnReceivedMessageListener(OnReceivedMessageListener onReceivedMessageListener) &#123; this.mOnReceivedMessageListener = onReceivedMessageListener; &#125; /** * 从字符串中截取连续6位数字组合 ([0-9]&#123;" + 6 + "&#125;)截取六位数字 进行前后断言不能出现数字 用于从短信中获取动态密码 * @param str 短信内容 * @return 截取得到的6位动态密码 */ public String getDynamicPassword(String str) &#123; // 6是验证码的位数,一般为六位 Pattern continuousNumberPattern = Pattern.compile("(?&lt;![0-9])([0-9]&#123;" + 6 + "&#125;)(?![0-9])"); Matcher m = continuousNumberPattern.matcher(str); String dynamicPassword = ""; while (m.find()) &#123; dynamicPassword = m.group(); &#125; return dynamicPassword; &#125;&#125; 注册广播123456789101112SMSBroadcastReceiver = mSMSBroadcastReceiver = new SMSBroadcastReceiver();IntentFilter intentFilter = new IntentFilter(SMSBroadcastReceiver.SMS_RECEIVED_ACTION);intentFilter.setPriority(Integer.MAX_VALUE);this.registerReceiver(mSMSBroadcastReceiver, intentFilter);ToastManager.getInstance().showLongToast("注册短信监听");mSMSBroadcastReceiver.setOnReceivedMessageListener(new SMSBroadcastReceiver.OnReceivedMessageListener() &#123; @Override public void onReceived(String message) &#123; //do something &#125;&#125;); 方式二:监听短信数据库内容提供者中对外通信方式有3种: 方式1:定义为Activity的内部类,直接在onChang()方法中处理业务逻辑,比如收到短信之后设置给EditText 优点:方便 缺点:耦合度高,复用性差 方式2:定义接口,Activity实现这个接口,拿到回调,处理业务逻辑 优点:耦合度低,复用性高 缺点没用充分利用Handler资源 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Created by wxw on 2016/9/24 10:34 * function: 监听短信数据库 * e-mail:wangxw725@163.com */public class SmsContentObserver extends ContentObserver &#123; private Cursor cursor = null; private Context mContext; private String[] projection = new String[]&#123;"_id","body"&#125;; private OnMessageObservedListener mOnMessageObservedListener; public SmsContentObserver(Context context,Handler handler) &#123; super(handler); this.mContext = context; &#125; public interface OnMessageObservedListener &#123; void onObservedMessage(String message); &#125; public void setOnMessageObservedListener(OnMessageObservedListener onMessageObservedListener) &#123; this.mOnMessageObservedListener = onMessageObservedListener; &#125; @Override public void onChange(boolean selfChange) &#123; super.onChange(selfChange); cursor = mContext.getContentResolver().query(Uri.parse("content://sms/inbox"), projection,null, null, "_id desc"); if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) &#123; cursor.moveToNext(); int smsbodyColumn = cursor.getColumnIndex("body"); String smsBody = cursor.getString(smsbodyColumn); mOnMessageObservedListener.onObservedMessage(getDynamicPassword(smsBody)); &#125; cursor.close(); &#125; private String getDynamicPassword(String str) &#123; Pattern continuousNumberPattern = Pattern.compile("(?&lt;![0-9])([0-9]&#123;" + 6 + "&#125;)(?![0-9])"); Matcher m = continuousNumberPattern.matcher(str); String dynamicPassword = ""; while (m.find()) &#123; dynamicPassword = m.group(); &#125; return dynamicPassword; &#125;&#125; 方式3:通过Handler发送消息,在Activity中进行业务逻辑处理 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Created by wxw on 2016/9/24 10:34 * function: 监听短信数据库 * e-mail:wangxw725@163.com */public class SmsContentObserver extends ContentObserver &#123; private Cursor cursor = null; private Context mContext; private Handler mHandler; private String[] projection = new String[]&#123;"_id","body"&#125;; public SmsContentObserver(Context context,Handler handler) &#123; super(handler); this.mContext = context; this.mHandler = handler; &#125; @Override public void onChange(boolean selfChange) &#123; super.onChange(selfChange); cursor = mContext.getContentResolver().query(Uri.parse("content://sms/inbox"), projection,null, null, "_id desc"); if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) &#123; cursor.moveToNext(); int smsbodyColumn = cursor.getColumnIndex("body"); String smsBody = cursor.getString(smsbodyColumn); mHandler.obtainMessage(1,getDynamicPassword(smsBody)).sendToTarget(); &#125; cursor.close(); &#125; private String getDynamicPassword(String str) &#123; Pattern continuousNumberPattern = Pattern.compile("(?&lt;![0-9])([0-9]&#123;" + 6 + "&#125;)(?![0-9])"); Matcher m = continuousNumberPattern.matcher(str); String dynamicPassword = ""; while (m.find()) &#123; dynamicPassword = m.group(); &#125; return dynamicPassword; &#125;&#125; 注册观察者12smsContentObserver = new SmsContentObserver(this, smsHandler);getContentResolver().registerContentObserver(Uri.parse("content://sms/"), true, smsContentObserver); handler中处理消息123456789101112131415private Handler smsHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 0: ...... break; case 1: LogUtils.x("Activity收到了短息码:"+(String)msg.obj); lf.mEtPassword.setText((String)msg.obj); break; &#125; &#125;&#125;; 注销观察者123456789@Overrideprotected void onDestroy() &#123; super.onDestroy(); ...... if(smsContentObserver!=null)&#123; getContentResolver().unregisterContentObserver(smsContentObserver); smsContentObserver = null; &#125;&#125; 遗留问题观察者会多次回调onChang方法() 参考博客: http://blog.csdn.net/qinjuning/article/details/7047607 http://blog.csdn.net/u014452224/article/details/53910230]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换电脑了]]></title>
    <url>%2F2017%2F11%2F16%2F%E6%8D%A2%E7%94%B5%E8%84%91%E4%BA%86%2F</url>
    <content type="text"><![CDATA[期待已久的小米笔记本终于到了，之前的acer用了3年多，这个顶配小米本计划使用5年，陪伴自己在技术上加速前进。 Java开发 Web开发 Linux 另外，在纠结到底该使用CentOS还是Ubuntu作为服务器系统的时候，https://www.zhihu.com/question/19599986 果断解决了自己的问题，感谢前辈。分享知识，就是在创造价值。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 入参出参数据类型转换]]></title>
    <url>%2F2017%2F10%2F31%2FSpringMVC-%E5%85%A5%E5%8F%82%E5%87%BA%E5%8F%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[入参Spring类型转换为Date类型如果前端传递的是日期字符串,比如”2017-10-23 19:46:45”,而我们在Controller中直接用Date类型接收,会报出如下异常: Failed to convert value of type ‘java.lang.String’ to required type ‘java.util.Date’ 解决方案:自定义数据类型转换器 1.自定义DateConverter 123456789101112131415161718import org.springframework.core.convert.converter.Converter;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; String pattern = source.length()==10 ? "yyyy-MM-dd" : "yyyy-MM-dd HH:mm:ss"; SimpleDateFormat format = new SimpleDateFormat(pattern); try &#123; return format.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.在Spring MVC配置文件中配置自定义的Converter 1234567891011121314&lt;!-- 注解驱动--&gt;&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;&lt;!-- 自定义参数绑定--&gt;&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;!-- 日期类型转换 --&gt; &lt;bean class="com.longke.watercleanner.converter.CustomDateConverter"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 这样前端传递的日期型字符串如”2017-10-23 19:46:45”,就可以转换为Date类型,在Controller中接收参数时可以使用Date类型接收,会自动转换. 出参Long类型转换为String类型由于在项目中使用了SnowFlake生成long类型ID作为表的主键,这样虽然有利于后台数据库的优化,但是在和前端交互时会出现一些问题. Java中的long类型字段在JavaScript的number类型接收时,会存在四舍五入的失真情况,比如: 后台id为372121275172126720,前端接收到的id为372121275172126700 后台id为372121602671771648,前端接收到的id为372121602671771650 这会导致根据id查询某个表时,id不存在导致的查询失败. 解决方案:@ResponseBody返回json数据时,将long类型的id转换为String类型,供前端使用. 1.自定义LongToStringMapper,继承ObjectMapper 12345678910111213141516171819import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.module.SimpleModule;import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;/** * 自定义Json转换器,把ResponseBody中Long类型的数据转换为String类型 */public class LongToStringMapper extends ObjectMapper &#123; private static final long serialVersionUID = 3223645203459453114L; public LongToStringMapper() &#123; super(); SimpleModule simpleModule = new SimpleModule(); simpleModule.addSerializer(Long.class, ToStringSerializer.instance); simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance); registerModule(simpleModule); &#125;&#125; 2.在Spring MVC配置文件中配置自定义的Mapper 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;!--返回JavaBean时解析成Json--&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"/&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;property name="objectMapper"&gt; &lt;bean class="com.longke.watercleanner.converter.LongToStringMapper"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 出参long类型时间戳转换为格式化日期字符串正常数据库存储的是时间戳,比如时间为long类型数据1508759205000,如果想返回给前端”2017-10-23 19:46:45”类型的字符串,可以利用Spring框架本身提供给我们的注解工具@DateTimeFormat,在pojo的属性上进行配置 12@DateTimeFormat(pattern = "yyyy-MM-dd hh:mm:ss")private Date appointmentDate; 不过这个还是得看需求,传递时间戳还是比较方便的,比如前端可能有时候需要的只是”2017-10-23”,而不想要后面的时分秒,而有时候又是需要的,所以还是直接传递时间戳,前端按需转换比较好. 以上只是匆匆记录,后期会再完善,优化写法,并尝试了解源码.(完) 参考链接: https://xtuer.github.io/spring-mvc-to-date/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-吴恩达:任何人都能成为机器学习专家]]></title>
    <url>%2F2017%2F10%2F08%2F%E7%AC%94%E8%AE%B0-%E5%90%B4%E6%81%A9%E8%BE%BE-%E4%BB%BB%E4%BD%95%E4%BA%BA%E9%83%BD%E8%83%BD%E6%88%90%E4%B8%BA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%93%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[访谈链接: Quora 知乎 自己能否够格成为机器学习从业人员? 任何人都可以 必须持续学习 高效的AI学习方式 复现他人发表的结果是一个掌握机器学习非常有效但却被低估的方式,临摹大师作品,在此过程中学习和总结,并创造新的产品或项目.写博客并开源项目,获得反馈 通过课程进行入门,之后再阅读科研文章,书籍 关注行业大V,获取最新资讯 多参加行业交流会,获取行业讯息和反馈 需要补习哪些数学知识重要性依次递减: 线性代数 概率和统计 微积分（包括多变量微积分） 优化 如何应对未来的AI世界 拥有持续学习的能力 学会编程]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mac系统生成SSH公钥]]></title>
    <url>%2F2017%2F10%2F06%2Fmac%E7%B3%BB%E7%BB%9F%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[使用SSH方式建立Git远程连接可以免除每次提交时的用户名和密码验证,可谓一劳永逸.可以直接参考 服务器上的 Git - 生成 SSH 公钥 定位公钥文件打开终端输入指令:cd ~/.ssh和ls查看文件列表 123MacdeMacBook-Air:blog crocutax$ cd ~/.sshMacdeMacBook-Air:.ssh crocutax$ lsknown_hosts 我们需要一对id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名。 .pub 文件就是需要上传到Git服务器的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 .ssh 目录），如果没有找到,则通过ssh-keygen指令来创建该文件. 创建公钥私钥打开终端输入指令:ssh-keygen 这里会提示让输入key的存储路径(默认是:/Users/mac/.ssh/id_rsa),以及密钥口令(输入两次),如果没有特殊指定,直接全部Enter即可. 123456789101112131415161718192021MacdeMacBook-Air:.ssh crocutax$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/Users/mac/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/mac/.ssh/id_rsa.Your public key has been saved in /Users/mac/.ssh/id_rsa.pub.The key fingerprint is:SHA256:LNg7AMZJyNIu0JxfKsCvkvwiALzmG4UuCRF3snIkNRk crocutax@MacdeMacBook-Air.localThe key&apos;s randomart image is:+---[RSA 2048]----+|=*E+. ||=X** . ||*oO. o ||o*+ooo . ||++ooo o S ||**. . o ||Bo. o ||oo.. . ||..o |+----[SHA256]-----+ 查看公钥此时再查看文件目录,发现我们需要的id_rsa和id_rsa.pub文件已经有了.输入指令cat ~/.ssh/id_rsa.pub查看公钥内容,并在Git服务器端配置即可.如果是Github或者码云等Git服务器,那么在个人中心的设置页面,配置SSH列表即可. 1234MacdeMacBook-Air:.ssh crocutax$ lsid_rsa id_rsa.pub known_hostsMacdeMacBook-Air:.ssh crocutax$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCxH7NqCzjO5D+ygwd1llaJoq1sJw0RJSCU/GLArSthCNZx....此处省略....arrL2mF5VAJr40fAyNgrXU5dSYBLgQTRDnFVeDrwGcL0agoveB5Df2wFLlVt6a5xwrIJ0GhqRWwSKtcB crocutax@MacdeMacBook-Air.local]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mac系统搭建hexo环境]]></title>
    <url>%2F2017%2F10%2F06%2Fmac%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BAhexo%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Hexo官网有详细的安装步骤 安装GitGit官网下载 测试git是否安装成功 12MacdeMacBook-Air:~ crocutax$ git --versiongit version 2.14.1 安装Node.js 1.先安装nvm Node Version Manager 打开终端,输入: cURL:1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash Wget:1wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash 通过如下指令测试nvm是否安装成功 12MacdeMacBook-Air:~ crocutax$ command -v nvmnvm 如果出现Comman not found提示1-bash: nvm: command not found 则尝试 重新打开终端 输入指令:source ~/.bashrc 2.nvm安装完毕后,通过nvm安装node.js 1$ nvm install stable 如下指令代表安装成功 12345678MacdeMacBook-Air:~ crocutax$ nvm install stableDownloading and installing node v8.6.0...Downloading https://nodejs.org/dist/v8.6.0/node-v8.6.0-darwin-x64.tar.gz...######################################################################## 100.0%Computing checksum with shasum -a 256Checksums matched!Now using node v8.6.0 (npm v5.3.0)Creating default alias: default -&gt; stable (-&gt; v8.6.0) 安装hexo1234567891011121314151617181920212223MacdeMacBook-Air:~ crocutax$ sudo npm install -g hexo/Users/mac/.nvm/versions/node/v8.6.0/bin/hexo -&gt; /Users/mac/.nvm/versions/node/v8.6.0/lib/node_modules/hexo-cli/bin/hexo&gt; dtrace-provider@0.8.5 install /Users/mac/.nvm/versions/node/v8.6.0/lib/node_modules/hexo-cli/node_modules/dtrace-provider&gt; node scripts/install.js&gt; fsevents@1.1.2 install /Users/mac/.nvm/versions/node/v8.6.0/lib/node_modules/hexo-cli/node_modules/fsevents&gt; node install[fsevents] Success: &quot;/Users/mac/.nvm/versions/node/v8.6.0/lib/node_modules/hexo-cli/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64/fse.node&quot; already installedPass --update-binary to reinstall or --build-from-source to recompile&gt; hexo-util@0.6.1 postinstall /Users/mac/.nvm/versions/node/v8.6.0/lib/node_modules/hexo-cli/node_modules/hexo-util&gt; npm run build:highlight&gt; hexo-util@0.6.1 build:highlight /Users/mac/.nvm/versions/node/v8.6.0/lib/node_modules/hexo-cli/node_modules/hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.json+ hexo-cli@1.0.3added 217 packages in 72.766sMacdeMacBook-Air:~ crocutax$ 使用hexo -version指令测试hexo是否安装成功 123456789101112MacdeMacBook-Air:~ crocutax$ hexo -versionhexo-cli: 1.0.3os: Darwin 16.6.0 darwin x64http_parser: 2.7.0node: 6.10.2v8: 5.1.281.98uv: 1.9.1zlib: 1.2.11ares: 1.10.1-DEVicu: 58.2modules: 48openssl: 1.0.2k 初始化Hexo目录创建自己的博客文件夹,然后cd到该目录下 1.执行指令hexo init初始化hexo 1234567891011121314151617181920212223242526272829303132333435363738MacdeMacBook-Air:~ crocutax$ cd /Users/mac/Desktop/crocutax/blogMacdeMacBook-Air:blog crocutax$ hexo initINFO Cloning hexo-starter to ~/Desktop/crocutax/blogCloning into &apos;/Users/mac/Desktop/crocutax/blog&apos;...remote: Counting objects: 59, done.remote: Total 59 (delta 0), reused 0 (delta 0), pack-reused 59Unpacking objects: 100% (59/59), done.Submodule &apos;themes/landscape&apos; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &apos;themes/landscape&apos;Cloning into &apos;/Users/mac/Desktop/crocutax/blog/themes/landscape&apos;...remote: Counting objects: 785, done. remote: Total 785 (delta 0), reused 0 (delta 0), pack-reused 784 Receiving objects: 100% (785/785), 2.54 MiB | 142.00 KiB/s, done.Resolving deltas: 100% (403/403), done.Submodule path &apos;themes/landscape&apos;: checked out &apos;decdc2d9956776cbe95420ae94bac87e22468d38&apos;INFO Install dependenciesnpm WARN deprecated swig@1.4.2: This package is no longer maintained&gt; dtrace-provider@0.8.5 install /Users/mac/Desktop/crocutax/blog/node_modules/dtrace-provider&gt; node scripts/install.js&gt; fsevents@1.1.2 install /Users/mac/Desktop/crocutax/blog/node_modules/fsevents&gt; node install[fsevents] Success: &quot;/Users/mac/Desktop/crocutax/blog/node_modules/fsevents/lib/binding/Release/node-v57-darwin-x64/fse.node&quot; already installedPass --update-binary to reinstall or --build-from-source to recompile&gt; hexo-util@0.6.1 postinstall /Users/mac/Desktop/crocutax/blog/node_modules/hexo-util&gt; npm run build:highlight&gt; hexo-util@0.6.1 build:highlight /Users/mac/Desktop/crocutax/blog/node_modules/hexo-util&gt; node scripts/build_highlight_alias.js &gt; highlight_alias.jsonnpm notice created a lockfile as package-lock.json. You should commit this file.added 429 packages in 30.513sINFO Start blogging with Hexo!MacdeMacBook-Air:blog crocutax$ 2.安装npm 输入指令:npm install 3.启动hexo本地服务 123MacdeMacBook-Air:blog crocutax$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 此时,打开http://localhost:4000/就可以看到hexo的默认首页了,hexo搭建完毕! 注意事项 hexo初始化的目录必须是空目录,所以如果是文件迁移,那么先hexo初始化空目录,然后再文件覆盖即可. 其他配置请参考: Hexo+Github Pages搭建个人博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows系统本地与远程服务器间的文件传输]]></title>
    <url>%2F2017%2F09%2F19%2Fwindows%E7%B3%BB%E7%BB%9F%E6%9C%AC%E5%9C%B0%E4%B8%8E%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[日常开发过程中，有些时候可能会用到本机和远程服务器间的文件传输，本文记录的是两台windows电脑间的文件传输，linux系统以后再说。 在mstsc成功建立远程桌面连接后，可以通过如下方式进行传输： 直接粘贴、复制 第三方软件网络传输：QQ，邮箱附件，网盘…… 本地磁盘共享 FTP文件传输 这里主要说下后两者，即：本地磁盘共享 和 FTP文件传输。 本地磁盘共享在mstsc建立远程桌面连接的时候，点击左下方的 显示选项 在弹出的选项卡中选择本地资源 --&gt; 本地设备和资源 --&gt; 详细信息 --&gt; 驱动器 --&gt; 勾选{要共享的磁盘目录} --&gt; 确定 打开远程桌面我的电脑，可以看到我们共享的本地磁盘显示在设备列表中，接下来本地和远程电脑就可以通过这个磁盘进行文件传输了。 FTP文件传输通过 FileZilla 可以在远程服务器快速搭建FTP服务，还是比较简单的。 FileZilla Client客户端放在本地电脑，主窗口一目了然 主机：远程服务器ip地址 连接状态log信息：成功、异常、失败信息都在这里显示 用户名、密码：需要在FileZilla Server端创建 远程share目录：需要在FileZilla Server端创建 文件传输列表：将需要传输的文件拖入该区域即可 FileZilla Server1、FileZilla 服务端 安装在远程服务器上，登陆后host为本机，port端口保持默认即可 2、打开窗口Edit --&gt; Users 添加授权账户 3、打开窗口Edit --&gt; Users，设置远程服务器端共享文件目录 可以为多个目录，设置不同级别的访问权限 可以针对不同的目录，设置不同的授权用户 可以将 Shared folders目录列表中的某个目录设置为home dir，即根目录（单选，只能设置一个，前缀为H 标记）。 使用1、服务端（远程）启动之后，客户端（本地）通过设置主机ip、用户名、密码等信息建立连接，获取到远程根目录以后，就可以正常传输文件了。 2、文件传输完毕，会存在服务端指定的shared folders目录下。 如果遇到异常信息，往下继续看。 异常解决1.连接失败 公网IP有误 用户名密码有误（需要在服务端创建） 端口错误 2.安全性警告 Warning: FTP over TLS is not enabled, users cannot securely log in. 警告并不影响使用，如果想解决这个警告，可以在Settings中配置 3.Passive mode设置如果出现以下异常信息： 1231. You appear to be behind a NAT router. Please configure the passive mode settings and forward a range of ports in your router2. 425 Can&apos;t open data connection for transfer of &quot;/&quot; 需要在 Edit --&gt; Settings中做如下配置： 使用自定义端口（确保该端口已经开通入网规则） 设置公网ip 当然，以上异常信息，还有可能由其他原因导致，因自己暂未遇到，先不做深究，等遇到时再搜索即可。 这里只记录了File Zilla的简单使用，至于用户分组、ip过滤、传输限速、安全设置等，可以根据自己需要再研究。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用tomcat7插件将项目一键部署到远程tomcat服务器-热部署]]></title>
    <url>%2F2017%2F09%2F17%2F%E4%BD%BF%E7%94%A8tomcat7%E6%8F%92%E4%BB%B6%E5%B0%86%E9%A1%B9%E7%9B%AE%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%A8%8Btomcat%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[现在用maven管理J2EE项目应该是常态了，在开发阶段我们经常需要经历反复的”修改代码-&gt;部署-&gt;测试”过程。如果每次修改完代码，都通过maven先clean-&gt;package，再手动到输出目录把打好的war包copy到tomcat的webapps下，多次的重复这种无意义的体力活会让人烦躁,而且显得没有程序员精神。 不得不说，有些时候“懒”还是有很多正面意义的。这篇文章就是介绍下如何通过tomcat7插件将项目一键部署到tomcat服务器的webapps目录下。命令很简单，主要是环境配置，以及踩坑记录。 实现tomcat热部署用到了: maven (项目构建和依赖管理) tomcat7插件 (部署到tomcat的插件) tomcat服务器 (web服务器) 1.添加tomcat用户及权限由于涉及到tomcat的自动部署，所以需要具备tomcat的管理权限,而普通的tomcat用户是没有管理权限的，比如通过{TOMCAT_HOME}/bin/startup.bat启动tomcat之后，在首页右侧的Manager App中，需要先输入管理员账户和密码才能进行项目服务器上项目的管理，否则根本无法进入管理页面。 添加用户和权限也很简单，在{TOMCAT_HOME}/conf/tomcat-users.xml 文件中，&lt;/tomcat-users&gt;节点下添加如下内容,创建管理角色和用户,并授权用户管理角色: 123&lt;role rolename="manager-gui" /&gt;&lt;role rolename="manager-script" /&gt;&lt;user username="tomcat" password="tomcat" roles="manager-gui, manager-script"/&gt; 之后进入tomcat首页-&gt;Manager App测试管理员账号是否创建成功 注： username和password可以自定义，这里为了简单记忆使用了tomcat同时作为用户名和密码。 网上有的博客这里配置了大量的权限，但是目前并没有发现其在这个阶段的作用和意义。 2.配置tomcat允许远程访问默认tomcat只允许本地部署，如果是要部署到远程服务器上，那么需要在远程服务器的{TOMCAT_HOME}conf/Catalina/localhost/目录下创建一个manager.xml文件，配置如下内容： 1234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Context privileged="true" antiResourceLocking="false" docBase="$&#123;catalina.home&#125;/webapps/manager"&gt; &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="^.*$" /&gt;&lt;/Context&gt; 如果只想允许部分IP拥有访问权限，那么可以配置allow节点，比如1allow=&quot;127.0.0.1,192.168.1.*&quot; 代表只允许主机拥有访问权限。 注意： 如果没有这一步的配置，本地tomcat服务器部署正常，但是远程tomcat服务器会报出下方常见问题中提到的Cannot invoke Tomcat manager: Connection reset by peer: socket write error异常 3.为maven添加tomcat管理员账号由于需要使用maven来构建和部署项目，所以maven就需要拥有tomcat的管理员账号信息。在{MAVEN_HOME}/conf/settings.xml文件中&lt;servers&gt;节点下添加如下内容： 12345678&lt;!-- 配置可以操作tomcat的用户名和密码 --&gt;&lt;server&gt; &lt;id&gt;crocutax&lt;/id&gt; &lt;!-- server login name --&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;!-- server login password --&gt; &lt;password&gt;tomcat&lt;/password&gt;&lt;/server&gt; 4.配置tomcat7插件在项目的pom.xml中配置tomcat7 plugin，具体节点的意义看注释或下方清单 123456789101112131415161718192021222324&lt;!-- 配置Tomcat插件 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 此处的名字必须和&#123;MAVEN_HOME&#125;/conf/settings.xml中配置的server节点的id一致--&gt; &lt;server&gt;crocutax&lt;/server&gt; &lt;!--服务器端口号--&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 项目发布的路径,默认就是tomcat/webapps目录,可以指定深层次目录,留"/",则默认在webapps目录下部署ROOT.war包--&gt; &lt;path&gt;&lt;/path&gt; &lt;!-- 注意tomcat7此处的url，不能随意修改,后缀必须是text,不能是html. 如果是本地tomcat部署,用localhost和ip都可以 --&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;!--&lt;url&gt;http://117.62.110.110:8080/manager/text&lt;/url&gt;--&gt; &lt;!--解决中文参数乱码问题--&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;update&gt;true&lt;/update&gt; &lt;!--配置在tomcat\conf\tomcat-users.xml中定义的用户名--&gt; &lt;username&gt;tomcat&lt;/username&gt; &lt;password&gt;tomcat&lt;/password&gt; &lt;/configuration&gt;&lt;/plugin&gt; 节点清单 server : 名字必须和{MAVEN_HOME}/conf/settings.xml中配置的server节点的id一致 port : 服务器端口号 path ：项目发布的路径,默认就是tomcat/webapps目录,可以指定深层次目录,留”/“,则默认在webapps目录下部署ROOT.war包 url ： 注意tomcat7此处的url，不能随意修改,后缀必须是text,不能是html. 如果是本地tomcat部署,用localhost和ip都可以 uriEncoding ：解决中文参数乱码问题 update ： 热部署，否则后期会报错 username ：配置{TOMCAT_HOME}\conf\tomcat-users.xml中定义的用户名 password ：同上 5.启动tomcat服务器先通过{TOMCAT_HOME}/bin/startup.bat启动tomcat，启动完毕之后再进行部署，否则会报出如下异常 12Cannot invoke Tomcat manager: Connection refused: connect -&gt; [Help 1] 6.maven命令部署在IDE-&gt;Terminal 或 项目根目录打开dos窗口，输入maven命令 mvn clean package tomcat:deploy (使用的是插件1.1版本，如果pom.xml中配置的是2.2版本，那么使用这么命令会报错) mvn clean package tomcat7:deploy (使用的是插件2.2版本，自己用的这个) 然后看着命令行歇一会吧 123456789101112131415161718192021222324252627...[INFO] --- maven-war-plugin:2.2:war (default-war) @ cmw ---[INFO] Packaging webapp[INFO] Assembling webapp [cmw] in [D:\code\server\chinesemedicine\target\cmw][INFO] Processing war project[INFO] Copying webapp resources [D:\code\server\chinesemedicine\src\main\webapp][INFO] Webapp assembled in [887 msecs][INFO] Building war: D:\code\server\chinesemedicine\target\cmw.war[INFO] WEB-INF\web.xml already added, skipping[INFO][INFO] &lt;&lt;&lt; tomcat7-maven-plugin:2.2:deploy (default-cli) &lt; package @ cmw &lt;&lt;&lt;[INFO][INFO][INFO] --- tomcat7-maven-plugin:2.2:deploy (default-cli) @ cmw ---[INFO] Deploying war to http://localhost:8080/cmwUploading: http://localhost:8080/manager/text/deploy?path=%2Fcmw&amp;update=trueUploaded: http://localhost:8080/manager/text/deploy?path=%2Fcmw&amp;update=true (45960 KB at 40564.5 KB/sec)[INFO] tomcatManager status code:200, ReasonPhrase:OK[INFO] OK - Deployed application at context path /cmw[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 18.075 s[INFO] Finished at: 2017-09-17T11:31:21+08:00[INFO] Final Memory: 20M/293M[INFO] ------------------------------------------------------------------------ 出现 BUILD SUCCESS，就部署成功了！ 常见的部署命令，在Tomcat7 Plugin Documentation 中有详细介绍，这里罗列几个常用的： tomcat7:run 运行当前项目 tomcat7:deploy 部署当前项目 tomcat7:redeploy 重新部署项目 tomcat7:undeploy 取消部署当前项目 常见问题Tomcat return http status error: 401, Reason Phrase: Unauthorized未授权访问tomcat，即没有tomcat的管理权限，如果没有进行步骤1中的”添加tomcat用户及权限”操作,远程部署时就会报此异常。 还有一种情况，已经在conf/tomcat-users.xml中配置了用户和权限 1234&lt;!-- 创建用户,并授权 --&gt;&lt;role rolename="manager-gui" /&gt;&lt;role rolename="manager-script" /&gt;&lt;user username="tomcat" password="tomcat" roles="manager-gui, manager-script"/&gt; 但是还是有这个异常信息，于是在服务器tomcat首页测试Manager App，发现定义的tomcat管理员角色无法正常登陆。这说明配置的用户和角色出问题了,继续排查，在tomcat启动日志中,发现了如下异常信息: 警告: Unexpected exception resolving reference com.sun.org.apache.xerces.internal.impl.io.MalformedByteSequenceException: 1 字节的 UTF-8 序列的字节 1 无效。 于是怀疑是有中文字符造成的影响，删掉了在tomcat-users.xml中的中文注释,即 &lt;!-- 创建用户,并授权 --&gt; 再次部署,tomcat Manager App 测试成功,远程一键部署成功! 注： 虽然这里是WARN而不是ERROR，但是还是有可能造成一些内部程序的加载失败导致功能缺失，比如这里的tomcat启动成功，但是内部管理权限却配置失败，进而导致远程部署因没有权限而失败。所以，从严谨性角度出发，如果精力足够，那么所有的WARN都不容忽视。 Connection reset by peer: socket write error 异常信息：[ERROR] Failed to execute goal org.apache.tomcat.maven:tomcat7-maven-plugin:2.2:deploy (default-cli) on project cmw: Cannot invoke Tomcat manager: Connection reset by peer: socket write error -&gt; [Help 1] 这个应该是部署的时候最容易出现的异常了，在这里卡了很久。网上查了一大圈。根本原因是:当客户端发出请求（request）后，如果还没有完全获得服务端的响应（response），客户端与服务器段的连接断开（例如断网、按了“停止”按钮、或者客户端浏览器关闭等），服务器端就会抛出此Exception。 这个问题需要从多方面排查。 1.如果是远程服务器，需要配置tomcat允许远程访问，见步骤2 2.有的说tomcat9在步骤1中配置用户权限时，同一个用户不能同时拥有manager-gui和manager-script权限，但是我分开了之后，依然没有解决这个问题。最终放弃使用tomcat9，使用tomcat7，一切正常了。 3.如果tomcat上已经部署了该项目，那么需要使用redeploy命令，即mvn tomcat7:redeploy 部署后的项目404以下3种原因都有可能造成部署后的项目无法正常访问，报404： 如果是远程服务器，请确保8080端口已经添加到入网规则中 pom.xml中tomcat7插件的path节点配置的有问题 项目本身404 tomcat内存泄漏tomcat日志中报出 The web application [/appStore] appears to have started a thread named [Thread-2],but has failed to stop it ,this is very likely to create a memory leak 等有时间了再研究，http://www.cnblogs.com/xyb930826/p/5725340.html 中有提到 参考链接 http://www.cnblogs.com/xyb930826/p/5725340.html https://my.oschina.net/simpleton/blog/598692 http://www.jianshu.com/p/78b17d656a5e https://github.com/hehongwei44/my-blog/issues/148]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Done is better than perfect]]></title>
    <url>%2F2017%2F09%2F14%2FDone-is-better-than-perfect%2F</url>
    <content type="text"><![CDATA[做了一些年头的技术人员之后，会不由得思考自己做这些东西的价值，之前曾经发表一些自己的看法，见 技术的价值和定位。技术是永无止境的,而且更新迭代非常快,那么面对技术,我们该采取什么样的态度? 偶然了解到扎克伯克所崇尚的黑客文化，其中有一句口号自己很喜欢，就是 Done is better than perfect ，有一种被认同感. Google了一下这句话,看到了阮一峰老师 的一篇文章，是2012年的，提到了Facebook在创业初期，扎克伯格用于激励团队的一些标语，感觉相当不错，遂记录一下： Done is better than perfect. Code wins arguments. Move fast and break things. Stay focused and keep shipping. 创业公司在巨头林立的IT行业，很多时候很难突围，要么稍有起色时被迫被收购，要么死，Facebook能在诸位大佬的夹缝中迅速成长壮大，跟扎克伯格主导的黑客文化应该不无关系。]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[将Mysql中的表一键生成Hibernate的POJO]]></title>
    <url>%2F2017%2F09%2F09%2F%E5%B0%86Mysql%E4%B8%AD%E7%9A%84%E8%A1%A8%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90Hibernate%E7%9A%84POJO%2F</url>
    <content type="text"><![CDATA[生成步骤在Idea中,通过Persistence工具可以将Mysql中已经创建好的数据表一键生成POJO，这样可以很方便的进行Hibernate的数据映射，加快开发进度。 首先，在Idea右侧侧边栏中，有Database 选项卡，选择对应的数据库，在这里进行数据库关联。 然后在File --&gt; Project Structure --&gt; Modules --&gt; {your modulename} 中添加Hibernate选项，标记此Module为一个Hibernate项目。 之后在Idea左侧边栏就会出现Persistence选项卡（如果没有显示，可以在View–&gt; Tool Windows –&gt; Persistence 中找到） 在选项卡中右键选择Assign Data Sources选择数据来源 在弹出的对话框中，选择Data Source，这里直接定位到了已关联的数据库。 指定完完Entities数据源之后，就可以选择生成POJO了 在弹出的对话框中进行配置，指定POJO的输出路径，配置前缀、后缀名，选择是注解还是XML方式进行映射等等 OK完事，自动生成的POJO长这样 12345678910111213141516171819202122232425262728@Entity@DynamicInsert@DynamicUpdatepublic class User &#123; private String id; private String username; @Id @Column(name = "id", nullable = false, length = 50) public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; @Basic @Column(name = "username", nullable = true, length = 50) public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125;&#125; 常见问题 如果数据库表结构发生了改变，重新生成POJO即可 如果POJO中@Column的属性出现Cannot resolve column {columnname} This inspection controls whether the Persistence ORM annotations are checked against configured Datasources ，直接Alt+Enter选择Assign Data Sources指定数据源即可。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[svn使用总结]]></title>
    <url>%2F2017%2F09%2F06%2Fsvn%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[客户端关联SVN仓库方式方式一(本地空目录) 创建一个空文件夹,空白处右键 checkout,输入服务器仓库的URL 当checkout的文件夹下多了个.svn的文件夹时代表关联成功 方式二(本地有项目文件夹) 将客户端项目import到服务器仓库 删除本地文件 将刚才导入服务器的项目checkout检出到本地,完成关联 提交 文件上有”？”图标时，代表服务器不知道该文件存在，右击 add，让该文件计划提交 commit提交,注意提交备注信息 养成先update,再commit的习惯 误删恢复 本地删除 ,恢复方法:SVN Update 服务器删除 ,恢复方法:show log,revert to this version 版本冲突* 当本地版本低于服务器的版本,就会出现提交的冲突,因此每次提交前,先从服务器更新最新版本到本地. * 比如用户A提交,用户B编译代码后没有update,直接提交,就会产生冲突 * 冲突解决 edit conflicts 自己编辑冲突 resolve 让系统自动解决冲突(合并两者的代码,有点麻烦) 图标解释1.绿色的对勾 : 首次关联仓库成功后，代码提交完成 2.蓝色?号： 服务器不识别该文件，新建的文件 3.蓝色+号： 计划将该文件提交到服务器的仓库 4.红色！号：文件修改了 5.黄色！号：产生冲突了。 6.灰色对勾： 只读文件，如果需要修改需要右击 get Lock 7.黄色小锁： 获取锁可以修改文件。其他用户不能再次获取锁来修改文件 8.灰色横杠： 被忽略，不提交服务器 锁操作* 图片、视频、so、等不可被编辑的文件才使用锁,其他慎用。 * 锁只能锁住一个文件状态，如果该文件被修改了，锁自动就没了。 提交原则 先update,后commit 每完成一个小模块,每天下班前都需要提交 禁止提交不能通过编译的代码 每次提交必须书写明晰的标注 不要提交自动生成的代码 慎用锁定功能 其他注意事项 提交时候提交的是一个目录,右键空白处选择提交,默认提交的是文件所在的整个目录 永远不要去删除Server端的仓库，否则无法找回代 谨慎使用还原，因为如果本地代码没有commit，那么还原后没有commit的代码将无法找回 直接忽略的文件,直接显示横杠 ; 已提交过的文件,设置为忽略时,会先显示红叉,提交后,变为白色横杠 由于是已经提交过的文件,所以设置为忽略时,显示红叉,表示计划从版本控制中删除,当提交后,就从服务器里删除了,然后成为忽略状态.如果一个文件没有提交过,直接设置为忽略,是显示不出红叉的.因为服务器里没有,不需要计划删除. 修改远程仓库url地址 TortoiseSVN-&gt;Relocate(重新定位),输入修改后的URL地址即可. 常见错误 Unable to connect to a repository at URL “https://…” Access to “/svn/…” forbidden 跟管理员确认自己是否拥有该仓库的访问权限 有权限的前提下依然存在此错误,则TortoiseSVN--&gt;Settings--&gt;Saved Data--&gt;clear ,即可解决 SVN 图标不显示 svn图标不显示的解决方案 ,自己依靠第四种方法解决了问题.]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven安装及添加本地jar包到maven仓库]]></title>
    <url>%2F2017%2F08%2F18%2Fmaven%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0jar%E5%8C%85%E5%88%B0maven%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[配置maven环境首先,下载插件,解压 http://maven.apache.org/download.cgi然后开始配置环境变量, 新建系统变量 MAVEN_HOME 变量值：D:\Dev\apache-maven-3.5.0 (即maven的安装目录) 编辑系统变量 Path 添加变量值：;%MAVEN_HOME%\bin 测试:mcd打开dos窗口 ,输入 mvn --version 显示如下界面代表maven安装成功 添加本地jar包到maven仓库安装非开源插件进行maven管理时需要添加本地jar包到maven仓库 在jar包所在目录打开dos窗口,进行maven安装. 1mvn install:install-file -DgroupId=com.alipay -DartifactId=sdk-java -Dversion=20170725114550 -Dpackaging=jar -Dfile=alipay-sdk-java20170725114550.jar 出现如下界面,说明成功安装到了maven本地仓库 可以在C:\Users\用户名\.m2\repository 目录下查看该仓库 再在pom.xml中添加依赖,就OK了 12345&lt;dependency&gt; &lt;groupId&gt;com.alipay&lt;/groupId&gt; &lt;artifactId&gt;sdk-java&lt;/artifactId&gt; &lt;version&gt;20170725114550&lt;/version&gt;&lt;/dependency&gt; mvn命令行打包出现中文乱码DOS命令行默认是GBK编码，如果编辑器、项目、tomcat等都设置的是UTF-8格式编码，那么使用mvn命令打包的项目部署后会出现中文乱码问题。 解决：在pom.xml中指定mvn打包时的编码格式为UTF-8 123456789101112&lt;!--maven编辑插件--&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- 指定编码格式，否则在DOS下运行mvn compile命令打包后会出现中文乱码，因为系统默认使用GBK编码 --&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt; 不是内部或外部命令maven配置环境变量后依然提示”不是内部或外部命令,也不是可运行的程序”,参考 http://blog.csdn.net/u014079773/article/details/49718207 ,在Path中配置文中提到的路径即可解决.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Realm数据库使用总结及采坑记录]]></title>
    <url>%2F2017%2F07%2F27%2FRealm%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E5%8F%8A%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Realm使用注意事项 Realm默认运行在主线程,使用时须开启异步任务 Realm本身是单例类,可以多线程并发调用,但是RealmObject则不允许并发,每个RealmObject都绑定了一个TreadId,必须在创建该RealmObject的线程中使用它. 在子线程查询出的数据无法在主线程使用,自己的方案是:子线程查询,置换为自己的Bean类,然后在主线程使用 没有主键的realmObject无法进行update操作.所以如果要使用realm.copyToRealmOrUpdate(realmObject),那么这个realmObject必须设置primaryKey 如果Realm关闭，所有查询得到的RealmObject都不能使用了,解决方案是复制一份数据到内存中。 操作数据库必须在transaction中完成 常见问题Object not managed by Realm, so it cannot be removedRealm不支持直接通过deleteFromRealm删除Bean类,即使该Bean extends RealmObject，否则会报此异常 正确姿势: 根据指定字段，从数据库中查询到该Bean，然后再删除 123456789101112131415/** * 从数据库中删除CollectBean * @param conType * @param relateId */public void deleteCollectBeanByTypeAndId(String conType,int relateId)&#123; Realm realm = RealmUtils.getInstance().mRealm; CollectBean bean = realm.where(CollectBean.class) .equalTo(CollectBean.CON_TYPE, conType) .equalTo(CollectBean.RELATE_ID,relateId) .findFirst(); realm.beginTransaction(); bean.deleteFromRealm(); realm.commitTransaction();&#125; Realm accessed from incorrect threadRealmObject自带线程保护功能，只能在创建它的线程中访问，在子线程中不能访问。也就是说，如果你在主线程中new了一个RealmObject对象 user，那么在子线程中是访问不了user对象的。要想在子线程中访问，必须先将user存入Ream中，然后在子线程中query出来。简书文章 is not part of the schema for this Realm 详细异常信息: java.lang.IllegalArgumentException: UserBean is not part of the schema for this Realm 需要调整plugin中的顺序,如下: 12345apply plugin: 'com.android.application'apply plugin: 'com.bugtags.library.plugin'apply plugin: 'android-apt'apply plugin: 'realm-android'apply plugin: 'com.neenbedankt.android-apt' {bean}has a primary key, use ‘createObject(Class, Object)’ instead 详细异常信息: io.realm.exceptions.RealmException: ‘UserBean’ has a primary key, use ‘createObject(Class, Object)’ instead. 如果实体中已经通过@PrimaryKey标明了主键,那么想要通过createObject(Class&lt;E&gt;, Object)创建实体对象,则必须传入primaryKeyValue(主键值) 异步查询之坑 1.官方文档介绍 主线程操作Realm会卡顿/阻塞线程官方表示Realm运行速度很快,足以在主线程运行,而后又表示其实还是会阻塞线程导致偶发的ANR,因此建议在子线程操作Realm. 2.子线程查询的数据,无法在主线程使用 解决方案: 子线程查询,置换为自己的Bean类,然后在主线程使用. 12345678910111213141516171819202122Realm.getDefaultInstance().executeTransactionAsync(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; Person ziPerson = realm.where(Person.class).findFirst(); personInfo = new PersonInfo(); personInfo.setName(ziPerson.getName()); personInfo.setAge(ziPerson.getAge()); //Log 输出#Execute ] false..Person&#123;name='小明', age=18&#125; KLog.i((Looper.getMainLooper()==Looper.myLooper())+".."+ personInfo.toString()); &#125;&#125;, new Realm.Transaction.OnSuccess() &#123; @Override public void onSuccess() &#123; //Log 输出#OnSuccess ] true..personInfo:Person&#123;name='小明', age=18&#125; KLog.i((Looper.getMainLooper()==Looper.myLooper())+".."+ personInfo.toString()); &#125;&#125;, new Realm.Transaction.OnError() &#123; @Override public void onError(Throwable error) &#123; KLog.i(error.toString()); &#125;&#125;); RejectedExecutionException 详细异常信息:java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4dffbdd rejected from io.realm.internal.async.RealmThreadPoolExecutor@c09c352[Running, pool size = 17, active threads = 2, queued tasks = 100, completed tasks = 110] 解决方案: 不要在for循环中使用Realm,将数据存入集合中,然后开启事务,直接使用copyToRealmOrUpdate(realmObjectList)存储即可. 事务嵌套报异常 详细异常信息:The Realm is already in a write transaction in /Users/blakemeike/Working/release/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp line 116 原因 : 在一个事务中开启了另外一个事务.应避免这种情况.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Realm数据库简单入门]]></title>
    <url>%2F2017%2F07%2F27%2FRealm%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[官网Realm官网 android文档 一个不错的Realm简介博客 模型1234public class Dog extends RealmObject &#123; public String name; public int age;&#125; 创建实体的方法:123456781.直接new Dog dog = new Dog();2.通过create()方法 Dog dog = realm.create(Dog.class)3.通过create()+预设主键(PrimaryKey)的方法 Dog dog =realm.create(Dog.class,1) 添加Bean进Database1234567Dog dog = new Dog();dog.name = "Rex";dog.age = 1;Realm realm = Realm.getDefaultInstance();realm.beginTransaction();realm.copyToRealm(dog)realm.commitTransaction(); 查询123RealmResults&lt;Dog&gt; pups = realm.where(Dog.class) .lessThan("age", 2) .findAll(); 添加数据监听12345678// Listeners will be notified when data changespups.addChangeListener(new RealmChangeListener&lt;RealmResults&lt;Dog&gt;&gt;() &#123; @Override public void onChange(RealmResults&lt;Dog&gt; results) &#123; // Query results are updated in real time puppies.size(); // =&gt; 1 &#125;&#125;); 支持异步任务123456789101112131415161718realm.executeTransactionAsync(new Realm.Transaction() &#123; @Override public void execute(Realm bgRealm) &#123; User user = bgRealm.createObject(User.class); user.setName("John"); user.setEmail("john@corporation.com"); &#125; &#125;, new Realm.Transaction.OnSuccess() &#123; @Override public void onSuccess() &#123; // Transaction was a success. &#125; &#125;, new Realm.Transaction.OnError() &#123; @Override public void onError(Throwable error) &#123; // Transaction failed and was automatically canceled. &#125; &#125;); Realm的异步操作在子线程执行任务,在主线程发布onSuccess回调 123456789101112131415Realm.getDefaultInstance().executeTransactionAsync(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; //此方法在子线程 realm.copyToRealmOrUpdate(userBean); KLog.i("execute...." + Thread.currentThread().getName() + "..." + (Looper.myLooper() == Looper.getMainLooper())); &#125;&#125;, new Realm.Transaction.OnSuccess() &#123; @Override public void onSuccess() &#123; //此方法在子线程 KLog.i("onSuccess...." + Thread.currentThread().getName() + "..." + (Looper.myLooper() == Looper.getMainLooper())); &#125;&#125;); Log输出: 12execute....pool-8-thread-1...falseonSuccess....main...true 其他基础操作只是在此基础上简单的换下api而已,不再记录.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM开发Web项目问题解决记录]]></title>
    <url>%2F2017%2F07%2F23%2FSSM%E5%BC%80%E5%8F%91Web%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Invalid content was found starting with element ‘init- param’在配置Spring前端控制器时,如果按照如下方式配置那么&lt;init-param&gt;标签就会有错误提示Invalid content was found starting with element &#39;init- param&#39; . 12345678910&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 解决方案: 将&lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 放在&lt;init-param&gt;标签的后面即可.即 1234567&lt;servlet&gt; ... &lt;init-param&gt; ... &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; Could not open ServletContext resource 错误信息:Could not open ServletContext resource [/WEB-INF/dispatcher-servlet.xml] 在web.xml中,加载springmvc的配置文件时,如果不指定contextConfigLocation路径,那么默认加载的是/WEB-INF/servlet名称-serlvet.xml（例如dispatcher-servlet.xml , springmvc-servlet.xml） #FileNotFoundException 错误信息: java.io.FileNotFoundException: class path resource [applicationContext.xml] cannot be opened because it does not exist 如果通过maven管理web项目,并且把配置文件放在了resources目录下,那么此时配置applicationContext.xml路径时,需要使用如下方式: 12345&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;!--&lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;--&gt;&lt;/context-param&gt; web.servlet.PageNotFound.noHandlerFound 错误信息:web.servlet.PageNotFound.noHandlerFound No mapping found for HTTP request with URI [/helloworld] in DispatcherServlet with name ‘dispatcher’ Stackoverflow问题链接直达 里列举了诸多的可能性原因.我这里当时的原因是: Spring扫描包配置问题,导致未扫描到指定的Controller 编译文件输出路径问题 form表单提交时类型转换异常 错误信息:Unable to convert string [${createtime}] to class [java.util.Date] for attribute [value]: [Property Editor not registered with the PropertyEditorManager] 需要自定义参数绑定,完成日期类型的转换 1.定义日期转换器123456789101112131415161718public class CustomDateConverter implements Converter&lt;String,Date&gt; &#123; public Date convert(String source) &#123; //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss) SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try &#123; //转成直接返回 return simpleDateFormat.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; //如果参数绑定失败返回null return null; &#125;&#125; 2.dispatcher-servlet.xml中配置转换器12345678910111213&lt;mvc:annotation-driven conversion-service="conversionService" validator="validator"/&gt; &lt;!-- 自定义参数绑定--&gt;&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;!-- 日期类型转换 --&gt; &lt;bean class="controller.converter.CustomDateConverter"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 完成! javax.servlet.http.httpservlet 不存在将tomcat中lib包里的servlet-api.jar(例如D:\Dev\Tomcat9\lib\servlet-api.jar) 复制到项目中 , 并添加依赖 , 重新build即可. MultipartException:form表单文件上传失败 错误信息: MultipartException: The current request is not a multipart request 解决方案: 需要在form表单上添加enctype=&quot;multipart/form-data属性 1&lt;form id="test" action="$&#123;pageContext.request.contextPath &#125;/test.action" method="post" enctype="multipart/form-data"&gt; js文件加载失败:XXX.js 404 (Not Found)在dispatcher-servlet.xml中添加静态资源解析 12&lt;!-- 静态资源解析 包括 ：js、css、img、..--&gt;&lt;mvc:resources location="/js/" mapping="/js/**"/&gt; 标签onclick属性调用js function()方法无效 错误信息:Uncaught ReferenceError: [function] is not defined at HTMLInputElement.onclick 解决方法:先添加jquery依赖,再定义另外的script标签,并在其中声明function 12345&lt;%--引入js的包--%&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath &#125;/js/jquery-1.4.4.min.js"&gt;&lt;/script&gt;&lt;script&gt; your function...&lt;/script&gt; HttpMediaTypeNotSupportedException 错误信息:HttpMediaTypeNotSupportedException: Content type ‘application/json;charset=UTF-8’ not supported 原因:jackson依赖没有添加完整 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0.pr4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0.pr4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0.pr4&lt;/version&gt;&lt;/dependency&gt; 配置完整就好了. Invalid bound statement (not found)运行项目时报如下异常: org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): 问题: Mybatis接口和xml文件绑定异常 解决: 主要检查Mybatis中mapper接口中的方法名和mapper.xml中的id名字是否一致 参考链接: http://blog.csdn.net/softwarehe/article/details/8889206]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android支付宝支付之坑]]></title>
    <url>%2F2017%2F07%2F21%2FAndroid%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E4%B9%8B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[之前用支付宝支付，总体来说一直比较顺利，没有遇到什么坑。不过人生处处有惊喜，现在在一家外包公司工作，项目质量参差不齐，奇葩情况也偶有出现。 前几天项目组的一位小伙伴遇到了一个支付宝支付的问题，原因后台把支付宝的加签工作甩给了移动端，当时我就震惊了！还有这种操作？！！WTF！！！而且ios已经按照这种移动端加签的方式做好了，这就让Android端很尴尬了。如果让后台重新按正规流程做一遍，ios也得改，而且显得Android端技术很差啊，后台和ios都做好了，就Android还是支付不了，于是只能硬上了。 支付宝Demo中的签名方法如下： 123456789101112131415161718192021222324252627282930313233343536public class SignUtils &#123; private static final String ALGORITHM = "RSA"; private static final String SIGN_ALGORITHMS = "SHA1WithRSA"; private static final String SIGN_SHA256RSA_ALGORITHMS = "SHA256WithRSA"; private static final String DEFAULT_CHARSET = "UTF-8"; private static String getAlgorithms(boolean rsa2) &#123; return rsa2 ? SIGN_SHA256RSA_ALGORITHMS : SIGN_ALGORITHMS; &#125; public static String sign(String content, String privateKey, boolean rsa2) &#123; try &#123; PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec( Base64.decode(privateKey)); KeyFactory keyf = KeyFactory.getInstance(ALGORITHM); PrivateKey priKey = keyf.generatePrivate(priPKCS8); java.security.Signature signature = java.security.Signature .getInstance(getAlgorithms(rsa2)); signature.initSign(priKey); signature.update(content.getBytes(DEFAULT_CHARSET)); byte[] signed = signature.sign(); return Base64.encode(signed); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 如果项目中直接用这个方法去跑，一定是无法正常调起支付宝支付的，会报如下异常： 1java.security.spec.InvalidKeySpecException: java.lang.RuntimeException: error:0D0680A8:asn1 encoding routines:ASN1_CHECK_TLEN:wrong tag 这是支付宝Demo留给我们的坑，按照网上的说法，将其中获取KeyFactory的代码改为 1KeyFactory keyf = KeyFactory.getInstance(ALGORITHM,"BC"); 再次运行后，报异常： 1ExtendedInvalidKeySpecException: unable to process key spec: java.lang.ClassCastException: com.android.org.bouncycastle.asn1.DLSequence cannot be cast to com.android.org.bouncycastle.asn1.ASN1Integer 以为这次又是支付宝的坑，其实这次是同事留给我的坑，同事把PrivateKey用错了。。。正常的RSA2_PRIVATE 长这样，注意是以==号结尾 更换了之后，这种支付宝加签的方式就可以跑通了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea使用中的问题记录]]></title>
    <url>%2F2017%2F07%2F19%2FIdea%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[idea配置Tomcat,启动Web项目 Run-&gt;Edit Configuration 添加TomcatServer-&gt;Local Server,在Server选项卡中选择Tomcat服务器,并进行Tomcat名称,默认部署后启动的浏览器等信息 编辑器已有默认配置 选择Deployment选项卡,按绿色+号 添加需要部署的项目,右侧Application context为项目名称. 如果Application context不配置,默认为/,那么通过http://localhost:8080/index.jsp即可访问项目页面 如果Application context配置为/test,那么访问路径变为http://localhost:8080/test/index.jsp 注意 如果发现配置的部署的项目无法Apply,或者无法通过绿色铅笔按钮进行编辑 , 那么采用如下方法: idea编辑器左上角File-&gt;Project Structure-&gt;Project Settings-&gt;Artifacts-&gt;绿色按钮添加-&gt;Web Application Exploded 左边output root为编译文件输出目录 , 右侧Available Elements为可用项目元素 , 默认编辑器已配置好可用项目元素 , 双击 , 或右键选择 , 即可将指定目录左移到output root目录. 回到Edit Configuration-&gt;Deployment界面 , 重新添加部署的项目 , 来源选择Artifacts即可 4.此时Apply之后发现tomcat并没有添加成功 , 还差最后一步 . 在Edit Configuration页面下方 , 有Befor launch:Build,Build Artifacts,Activate tool window选项 , 默认只有一个Build条目 , 再添加一个Build Artifacts条目 , 再Apply-&gt;OK 配置成功!完事! 错误:找不到或无法加载主类环境状况: 环境变量配置没有问题,通过windows命令行窗口可以正常查看版本号 电脑里的其他Java和Android项目都运行正常 在此前提下,运行Demo时报出 错误:找不到或无法加载主类. 说明是Idea配置问题导致的. 原因 没有给Project设置编译文件的输出路径,即Project Structure -&gt; Project Settings -&gt; Project compiler output没有设置,但是却在Modules -&gt; Paths 中选择了 Inherit project compile output path Project Structure -&gt; Modules -&gt; Paths 中,选择了Use module compile output path , 但是只是默认的相对路径. 解决方案 首先,确保Project Structure -&gt; Project,已为Project指定SDK 其次: 方案1:使用Project的编译输出路径 在Project Settings -&gt; Project compiler output中设置Project的编译输出路径 在Project Settings -&gt; Modules中选择 Inherit project compile output path 即继承Project的路径 方案2:使用Module的编译输出路径 Project Structure -&gt; Modules -&gt; Paths,改变Output path 和 Test output path的路径. 两个路径默认是: \out\lib \out\test\lib 改为项目绝对路径+上述目录,比如项目文件路径为E:\JavaEE\HelloWorld,那么修改后的两个Path分别为: E:\JavaEE\HelloWorld\out\lib E:\JavaEE\HelloWorld\out\test\lib 实现接口方法报错当实现一些接口方法时,报出@Override is not allowed when implementing Interface method 由于项目所使用的java语言版本所导致的,打开File-&gt;Project Structure-&gt;Modules-&gt;选择项目目录-&gt;Sources选项卡-&gt;Language Level,更换Language Level即可,比如更换为8-Lambdas. 即可解决问题,如下图所示 pom.xml中配置的依赖库提示not found情况1:maven Reposity 仓库里有解决:右键–&gt;Maven–&gt;Reimport , 搞定 情况1:maven Reposity 仓库里没有,比如一些第三方服务商的库解决: 将jar包安装到本地仓库 , 见maven安装及添加本地jar包到maven仓库 ,重新build即可 mybatis的Mapper和xml关联失败,找不到xml文件1234org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.crocutax.mybatisdemo.mapper.UserMapper.findUserList at org.apache.ibatis.binding.MapperMethod$SqlCommand.&lt;init&gt;(MapperMethod.java:225) at org.apache.ibatis.binding.MapperMethod.&lt;init&gt;(MapperMethod.java:48) 解决方案:在pom.xml中配置12345678910&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 参考 http://blog.csdn.net/shifangwannian/article/details/48882201 webxml attribute is requiredmaven构建时报异常,信息如下: webxml attribute is required (or pre-e xisting WEB-INF/web.xml if executing in update mode 原因:maven管理的web项目,默认会去src/main/webapp目录下寻找WEB-INF/web.xml文件,因此web项目的文件转移到该目录即可. 参考:http://blog.csdn.net/lizhitao/article/details/25213669 java.lang.NoClassDefFoundError: javax/el/ELManager原因:缺少javax.el-api仓库依赖 解决:在pom.xml中添加javax.el依赖即可 12345&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 参考链接:https://stackoverflow.com/questions/45841464/java-lang-noclassdeffounderror-javax-el-elmanager]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[融云IM踩坑记录]]></title>
    <url>%2F2017%2F07%2F04%2F%E8%9E%8D%E4%BA%91IM%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[融云自身引入了一些第三方库,当我们自己在项目中再引入这些第三方库的时候,就会出现冲突的情况.比如duplicate entry XXX 类的错误. PhotoView冲突 错误信息 duplicate entry: uk/co/senab/photoview/BuildConfig.class 原因 如果从Github仓库在gradle中以compile &#39;com.commit451:PhotoView:1.2.4&#39;引入PhotoView,那么此时PhotoView会有两个 uk.co.senab.photoview.PhotoView (正式photoview) io.rong.photoview.PhotoView (融云中的photoview) 解决方案 使用融云中的PhotoView即可 Eventbus冲突 org.greenrobot.eventbus.EventBus(正式Eventbus) io.rong.eventbus.EventBus (融云SDK中的Eventbus) 项目中碰到的问题 误使用了不同包下的Eventbus,导致事件传递失败. 解决方案 使用同一包下的Eventbus即可]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[技术的价值和定位]]></title>
    <url>%2F2017%2F06%2F09%2F%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BB%B7%E5%80%BC%E5%92%8C%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[技术出身的人，有钻研精神，但是同时很多都有强迫症，会为了一丁点问题花费大量的时间，有些出于工作需要，有些则纯粹是和自己较劲，比如: 为了解耦更加彻底，而多写N个接口，层层回调，解耦的便捷度换来的是大量重复的体力活-接口。 为了丁点的性能，花费了大量的时间去尝试多种方案、优化、调试。 为了代码更加优雅，费尽心思的设计、重构，最终可能只是自己比较high而已。 …… 从个人技术提升的角度而言，这些例子无疑都是正向的，在这些行为的过程中，自己整体技术能力注定会有所提升。从技术研究的角度而言，也都是必要的，比如任何能提升服务器1%性能的方案都值得去研究和实现，任何能为用户节省1%流量、加快1%速度的方案都值得去尝试。 然而，太多的个人技术钻研和正式的技术研究其实最终的作用微乎其微、甚至没有。大家都认同重复造轮子没有意义和价值，但是个人觉得无法对现实工作起到正向作用，无法作用于产品上的技术都是没有价值和意义，以及不值得去付出时间和精力的。 无论是自然科学还是社会科学，全世界可能有不计其数的科研成果，最终起到作用的有1%吗？不知道。而且并不认为没有这无法直接转化的99%的研究成果做铺垫，就没有这1%的对人类真正起到推动作用的科研成果。 1%的精品是有价值和作用的，9%的良品是值得借鉴但是无法直接转化的，剩余90%都是出于工作需要不得不出的成果，是凑数的，是工作职责内的正常产出而已。这里说的就是这90%，到底有没有值得付出的价值。 个人观点： 技术是永无止境的，值得尊敬的，伟大的，技术可以改变人们的生活，可以推动历史的发展。 无法商业化的技术，完全没有存在的价值，也不值得花费时间和精力去钻研，因为，你是纯研发人员吗？你是科学家吗？ 你可以选择 YES，但是我选择 NO。 技术+商业运作，技术才有体现价值的机会，否则，就只能是文献而已。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-《程序员修炼之道：从小工到专家》]]></title>
    <url>%2F2017%2F06%2F01%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%9A%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[注重实效的哲学 在所有的弱点中,最大的弱点就是害怕暴露弱点. 勇敢的承担起责任,提供各种选择,不要找蹩脚的借口. 破窗效应会让项目迅速腐烂,因此,不要容忍破窗户. 做变化的催化剂,无论是对于自己,还是团队. 别只顾低头走路,也要抬头看天.知道自己所做的事情对长期的战略目标有什么意义. 批判地分析你读到的和听到的,不可不信,也不可全信. 知识上的投资总能得到最好的回报 –本杰明富兰克林. 因此,要定期为自己的知识资产投资. 优秀投资者的行为: 定期投资-养成习惯 多元化投资是长期成功的关键 在保守的投资和高风险,高回报之间平衡投资资产 设法低买高卖,以获取最大回报 周期性的重新评估和平衡资产 像优秀的投资者一样投资自己的技术: 每年至少学习一种新语言 每季度阅读一本技术书籍 参加本地的技术活动,杜绝与世隔绝 试验不同的开发环境,Windows–&gt;Linux,Notepad–&gt;SublimeText 跟上技术潮流 重新梳理,评估自己的技术体系 尽可能的把学的技术用到项目中 注重实效的方式 Don’t Repeat Yourself.重复的危害性. 环境所迫的重复,比如只能使用一种开发环境,工具,技术.. 开发者无意识的重复,并没有意识到自己在重复着自己已经习惯的东西. 偷懒性的重复,因为重复,更加容易. 开发者之间的重复造轮子行为. 学会制造和利用 “可复用”的东西,避免重复. 可撤销性:如果某个想法是你唯一的想法,再没有什么比这更危险的事了. 纯文本的威力. 用纯文本保存知识.Keep Knowledge in Plain Text. 掌握小而精的Shell脚本 精通一种编辑器 , 提升工作效率 可配置 可扩展 可编程 你不可能写出完美的软件，所以要减少不必要的过度追求 断言式编程 按照合约(Contract)进行设计 Always Use Source Code Control. Fix the Problem,Not the Blame. Treat English as Just Another Programming Language. 充分解耦 要配置，不要集成 将抽象放进代码，细节放进元数据 分析工作流，以改善并发性 使视图与模型分离 当你编码时 编码并不是机械式的工作，处处都需要经过深思熟虑，所以不要靠巧合编程 编写易于测试的代码 重构在何时进行重构 早重构，常重构 有重复代码时 可以更加彻底的解耦时 存在过时的技术 性能需要优化 怎样重构 不要试图在重构的同时增加功能 开始重构之前，确保项目拥有良好的测试，并经常运行这些测试，这样可以及早发现重构导致的问题 在项目开始之前 不要收集需求，而是挖掘用户需求 建立需求文档 与用户一同工作，以像用户一样思考 Some Things Are Better Done than Described 注重实效的团队 不要留破窗户 避免温水煮青蛙式的团队氛围变化 注重沟通 围绕功能、而不是工作职务进行组织 尽可能多的采用自动化 测试 早测试、常测试、自动测试 要到通过全部测试、编码才算完成 测试什么 单元测试 集成测试 验证和校验 资源耗尽、错误及恢复 性能测试 可用性测试 回归测试 傲慢与偏见 Sign Your Work 杜绝团队协作中的 “地盘” 意识 名言 语言的界限就是一个人世界的界限.–维特根斯坦 再多的天才也无法胜过对细节的专注 –Levy’s Eighth Law 欲求更好,常把好事变遭–李尔王. （换言之,无法一步就做到完美的结果,最好是先上路,先出一个大致差不多的结果,再小步快速迭代）]]></content>
      <categories>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[共享经济的热潮]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%85%B1%E4%BA%AB%E7%BB%8F%E6%B5%8E%E7%9A%84%E7%83%AD%E6%BD%AE%2F</url>
    <content type="text"><![CDATA[现状共享单车在经历了部分一线城市的试点式推广后，开始陆续如火如荼的在全国范围内展开，在资本的助力下快速的复制，这种经济、环保、方便的模式也逐渐被越来越多的人接收。 在北京地区，强势者如摩拜、ofo（在全国范围内，这两家都是强势者），紧跟者如小蓝单车、永安行等，杭州市有哈罗单车、小鸣单车，估计其他诸多城市也都有地方性的共享单车品牌。 自己真正认识、体会到共享模式的优点还是来源于滴滴打车，现在已经扩张到改名为“滴滴出行”了，囊括了更多的业务概念和服务内容。印象中上高中地理的时候，老师讲到城市交通规划问题，就有设计交通拥堵、流量峰值、交通资源优化配置等问题。所以从解决这些问题的角度来看，滴滴确实是一家非常伟大的公司，这些事，政府永远做不到，也不会去做，因为存在既得利益群体的阻力。 共享单车应该算是在共享经济概念上的延展了，绿色出行的口号和公益广告持续了这么多年，感觉还没有这些共享单车公司在概念普及、实际行动方面给大家做出的贡献大。虽然很多城市都有市政提供的单车，但是骑下就知道差别和差距了。 新事物的曲折成长新产品的出现，必定要付出市场教育的成本，先行者有先入为主的优势，但是也不得不承担这个教育成本的付出。 想想当年滴滴、快的、Uber等公司，被出租车司机、出租车公司各种阻挠，又是罢工、又是游行、又是砸场子、又是出政策。。。 出租车拒载是家常便饭，因为乘坐出租车而发生的民事、刑事案件相信大家也都不会把它当做热点新闻，但是一旦这些事情发生在滴滴、快的、Uber司机的身上，那必然是一个头条，必然可以以此为切入点去各种论证这种共享模式的不规范、不安全、不靠谱等等。 甚至于滴滴都已经做成现在这种规模了，市场教育完成了，这种服务模式也深入人心了，2016年下半年的时候，政府还要强行收割市场，以京户、京牌、车轴距（这个也太刻意了）等限制条件强行把已经培育好的市场收割给当地国企。如果以这样的理由扩展到其他行业，那所有的服务性岗位如保姆、保洁、保安、快递员、建筑工人等等都得回老家了，在北京叫个外卖估计得配送费200块起了，招个保安都得月薪1万以上了。 其实所有人都明白是怎么回事，只是无力反抗而已。但是这一切，并不妨碍所有的新事物在阻挠、曲折中成长。不信随着时间的推移，发展壮大的一定是滴滴这种困局中求生的公司，而不是躺着张嘴等喂，没饭吃就哭，一哭就把别人碗抢过来喂他的公司。 现在的共享单车，同样也遇到了各种各样的问题，比如市民素质问题、黑车司机的蓄意破坏问题、违规停放问题。当然也会有骑共享单车摔倒能上头条的问题等等，如出一辙。 其实总结来看，当这些新事物、模式出现时，有三个共同点： 被各方阻挠、破坏 焦点效应，双刃剑 曲折中不断成长 市场份额之争比较有代表性的两家：摩拜和ofo，个人觉得这两家真是风格迥异而又殊途同归的公司。 对摩拜的印象是技术驱动，互联网模式做精品单车，据称每辆3000元的成本，即使放在全国单车已经一片混战情况下，摩拜的质量应该还是最好的。感觉是一家稳扎稳打，比较靠谱的公司，所有单车比较一圈，还是骑摩拜的车最放心。（不过来到杭州，发现摩拜投入的车辆很少，经常找不到车，只好把押金退了，换成了本地的单车，尴尬。。。） 对ofo的印象是土老板来了，大金链子大金表张嘴两颗大金牙，车海战术，黄灿灿一片，连蓝牙锁都没有，一次扫码永久骑车。当然这个车也骑不了多久，就ofo的车质量估计也就200块钱的成本，甚至有次跟同事聊天，谈到这几家单车公司的车质量，同事反问道：“就那车质量能值200？”，于是又下调了心理价位，估计100。。。 其实ofo的战略也很明显，先用破车来教育市场，增加用户量，把日活和押金拿过来，然后用这个数据去融资，再拿融资的钱去复制模式、快速圈地、迭代产品、更新技术。比起后面这些带来的好处，谁还在乎那一堆堆掉链子、爆胎、没轮子的小黄车？那些钱的作用已经起到了，而那些低质量的车本来就是用来达到上述目的的。 当然，最终的结局肯定也跟几年前的团购、外卖、打车一样，最后估计还是剩摩拜和ofo两家，其他家都是被收购的命运。为什么明知道做不过，还要进入这个行业去做呢？各种各样的共享单车品牌，颜色都不够用了！ 因为被收购了，应该也很赚钱吧！甚至可以说只要活到能被收购的时候，或者在当地市场做到有资格被收购的规模，都是稳赚的吧！所以，很多公司可能并不是为了号称的理想、绿色出行、共享经济、市民服务等等，做，就是为了等着被收购！ 一方面是一些公司为了被溢价收购而做，另一方面，突然发现，再努力的做什么，最终还是逃不过资本的介入乃至掌控，各个大小行业，最终都是资本的战场。。。 共享热潮的连带效应在共享汽车、共享自行车的带动下，共享电动车、共享充电宝、共享雨伞，甚至共享衣服、共享中央厨房都开始了。。。 无论王思聪吃不吃翔，反正这些五花八门的共享产品和服务，让普通老百姓的日常生活在衣食住行方面更加便捷、更加经济、更加丰富多彩了。 （完）]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo持续优化-在文章尾部添加版权声明信息]]></title>
    <url>%2F2017%2F05%2F20%2FHexo%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96-%E5%9C%A8%E6%96%87%E7%AB%A0%E5%B0%BE%E9%83%A8%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[如果文章没有版权声明信息，可能会发生被他人随意转载、随意修改的情况，如果是普通的技术文章和随笔还好，但如果涉及到一些比较重要的信息，可能会涉及一些未可知的不良后果。 但是如果每篇文章都手动添加版权声明信息，也太没有程序员的职业精神了，所以还是依靠脚本自动生成比较好。 自己使用的Hexo+NexT主题，主题默认的版权声明配置在themes\next\_config.yml文件中 # Declare license on posts post_copyright: enable: false license: CC BY-NC-SA 3.0 license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/ 直接把enable 改为true即可开启。 不过自己对默认的效果不太满意，想自定义一下，模仿IIssNan 的声明效果，先上最终效果图 具体步骤整理如下： 自定义版权声明HTML代码定位到themes\next\layout\_macro\post.swig文件，找到&lt;footer class=&quot;post-footer&quot;&gt;节点，该节点包括了每篇文章底部的tag、span分割线等标签，可以根据自己的需要放置【版权声明】的位置。 123456789101112131415161718192021222324252627282930313233&lt;footer class="post-footer"&gt; &#123;# 版权声明节点 #&#125; &lt;div&gt; &#123;% if not is_index %&#125; &lt;ul class="post-copyright"&gt; &lt;li class="post-copyright-link"&gt; &lt;strong&gt;本文作者：&lt;/strong&gt; &lt;a href="/" title="欢迎访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class="post-copyright-link"&gt; &lt;strong&gt;本文标题：&lt;/strong&gt; &lt;a href="&#123;&#123; url_for(post.permalink) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class="post-copyright-link"&gt; &lt;strong&gt;本文链接：&lt;/strong&gt; &lt;a href="&#123;&#123; url_for(post.permalink) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;"&gt;&#123;&#123; post.permalink &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class="post-copyright-date"&gt; &lt;strong&gt;发布时间：&lt;/strong&gt;&#123;&#123; post.date.format("YYYY年M月D日 - HH时MM分") &#125;&#125; &lt;/li&gt; &lt;li class="post-copyright-license"&gt; &lt;strong&gt;版权声明： &lt;/strong&gt; 本文由 &#123;&#123;theme.author&#125;&#125; 原创，采用 &lt;a href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh" rel="license" target="_blank"&gt;保留署名-非商业性使用-禁止演绎 4.0-国际许可协议&lt;/a&gt; &lt;/br&gt;转载请保留以上声明信息！ &lt;/li&gt; &lt;/ul&gt; &#123;% endif %&#125; &lt;/div&gt;... 里面都是基础的HTML代码，使用了一个无序列表用于展示版权声明的各项信息，这里可以随意diy。当然里面涉及一些属性，比如： theme.author ： 作者名 post.title ：文章标题 post.path ：文章相对路径 post.permalink : 文章绝对路径 post.date : 日期 注意 这里用page和post效果一样，比如page.title , page.path 我这里基本都做成了超链接形式，也可以做成文本形式，看自己意愿而定。 通过类选择器添加自定义样式定位到themes\next\source\css\_custom\custom.styl 文件，通过类选择器添加CSS样式 123456789// Custom styles..post-copyright &#123; margin: 2em 0 0; padding: 0.5em 1em; border-left: 3px solid #FF1700; background-color: #F9F9F9; list-style: none;&#125; 本地部署先看看效果吧，也可以到 http://www.crocutax.com 看看效果。 参考链接 https://arcecho.github.io/2017/04/08/Hexo-Next%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E6%A8%A1%E5%9D%97/ http://crossingmay.com/2016/04/20/updatehexo/ （完）]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo持续优化-创建分类和标签页面]]></title>
    <url>%2F2017%2F05%2F20%2FHexo%E6%8C%81%E7%BB%AD%E4%BC%98%E5%8C%96-%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[昨天本地的博客文件被误删了，后来重新搭建起来，发现博客没有分类和标签页面了，原因是source目录下的categories 和 tags 目录被删除了，需要重新创建。然而只是创建个空目录是不行的，必须按照规范来。 之前搭建的时候，这里并没有记录，导致还浪费了一点时间，现在简单记录下。 创建分类页面运行命令hexo new page categories 该命令会在source目录下生成 categories 文件夹，categories 文件夹中有一个index.md文件，按照下列方式修改文件内容 --- title: 分类 date: 2017-05-20 09:50:22 type: &quot;categories&quot; comments: false --- type 字段用来指定页面类型，comments 字段用来指定该页面是否显示评论。 创建标签页面运行命令hexo new page tags 该命令会在source目录下生成 tags 文件夹，tags 文件夹中有一个index.md文件，按照下列方式修改文件内容 --- title: 标签 date: 2017-05-20 09:51:00 type: &quot;tags&quot; comments: false --- type 字段用来指定页面类型，comments 字段用来指定该页面是否显示评论。 不需要再去XML做任何的配置，直接hexo g + hexo s 本地部署，就会发现分类和标签页面一切正常了。 参考链接： http://www.jianshu.com/p/cc08e3e509e0 (完)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RatingBar的基本使用和自定义样式]]></title>
    <url>%2F2017%2F05%2F18%2FRatingBar%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[今天项目中又用到了RatingBar，于是翻出来之前踩坑的一篇笔记，快速解决问题，顺便把笔记内容整理在此，方便以后查阅。 当项目中遇到【评分】需求的时候，一般情况下都会使用RatingBar用于UI展示，而且很多时候都不会使用原生样式。原因有两个： Android和iOS样式的统一 系统原生样式的版本兼容性问题 所以适当的自定义RatingBar样式就显得很有必要了。 RatingBar基本使用RatingBar的基本使用比较简单，这里只记录一下几个常用的属性： isIndicator 是否是指示器，如果设置为true,则不可以通过点击来改变进度；如果设置为false，则可点击 numStars 一共有几个星星，默认是5个。 rating 表示进度 RatingBar 样式展示之前项目中一共碰到过四种RatingBar样式，各自效果图整理如下： 说明： 第一个：原生普通样式（随着主题不同，样式会变） 第二个：原生普通样式-小icon 第三个：自定义RatingBar 颜色 第四个：自定义RatingBar Drawable RatingBar 各样式实现原生样式原生样式其实没什么好说的，使用系统提供的style 即可 12345678910111213&lt;!--第一个：原生主题样式 --&gt;&lt;RatingBar style="?android:attr/ratingBarStyleIndicator" android:layout_width="wrap_content" android:layout_height="wrap_content" android:rating="3"/&gt;&lt;!--第二个：原生主题样式：小--&gt;&lt;RatingBar style="?android:attr/ratingBarStyleSmall" android:layout_width="wrap_content" android:layout_height="wrap_content" android:rating="3"/&gt; 自定义颜色这种方式也很简单，只需要要定义一个样式即可，两步完成。 第一步，定义样式，指定背景色 和 进度色 1234567&lt;!--自定义RatingBar Color--&gt;&lt;style name="RatingBar_CustomColor" parent="@android:style/Widget.Holo.RatingBar.Indicator"&gt; &lt;!--Background Color--&gt; &lt;item name="colorControlNormal"&gt;#D7D7D7&lt;/item&gt; &lt;!--Progress Color--&gt; &lt;item name="colorControlActivated"&gt;#F49800&lt;/item&gt;&lt;/style&gt; 第二步，XML中使用该主题 123456789&lt;!--自定义 Color--&gt;&lt;RatingBar android:id="@+id/go_rating" android:layout_width="wrap_content" android:layout_height="wrap_content" android:isIndicator="true" style="?android:attr/ratingBarStyleSmall" android:theme="@style/RatingBar_CustomColor" android:rating="3"/&gt; 自定义Drawable这种方式相对于前面几种，算是稍微麻烦一点的方式了，而且还存在图片拉伸的坑（图片底部被垂直拉伸成一条直线，跟哭了似的-_-!，就不贴图了）。先说具体实现方法，再说坑。 第一步，定义层叠布局layerlist 自定义过ProgressBar的同学，相信对下面的background，secondProgress，progress属性都不会陌生。 123456789101112&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@android:id/background" android:drawable="@drawable/star"/&gt; &lt;item android:id="@android:id/secondaryProgress" android:drawable="@drawable/star"/&gt; &lt;item android:id="@android:id/progress" android:drawable="@drawable/star_solid"/&gt;&lt;/layer-list&gt; 第二步，自定义样式，指定ProgressDrawable 注意这里指定minHeight和maxHeight，根据项目中的UI需求而定，定死高度的其中一个作用就是防止drawable图片被垂直拉伸。 123456&lt;!--自定义RatingBar Drawable--&gt;&lt;style name="RatingBar_CustomDrawable" parent="@android:style/Widget.Holo.RatingBar.Indicator"&gt; &lt;item name="android:progressDrawable"&gt;@drawable/custom_rating_bar&lt;/item&gt; &lt;item name="android:minHeight"&gt;15dp&lt;/item&gt; &lt;item name="android:maxHeight"&gt;15dp&lt;/item&gt;&lt;/style&gt; 第三步，在xml中使用刚才定义好的样式 1234567&lt;!--自定义Drawable样式--&gt;&lt;RatingBar android:id="@+id/room_ratingbar" style="@style/RatingBar_CustomDrawable" android:layout_width="wrap_content" android:layout_height="wrap_content" android:rating="3"/&gt; 最后说下图片垂直拉伸的解决方案： 设置minHeight和maxHeight，写死像素值。 让UI帮忙切一张底部留有空隙的star图标，比如有1px的空隙 使用略大于当前控件空间的icon，比如整个UI切图是按照drawable-xxhdpi来切的，那么使用高一级的drawable目录下比如drawable-xxxhdpi的icon，这样在运行的时候，icon会进行相应比例的缩放。 图片拉伸问题，还可以参考以下链接： http://shikezhi.com/html/2015/android_0920/375199.htmlhttp://blog.csdn.net/QMLN31821007/article/details/41121891 （完）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoogleDrive云盘同步本地博客文件]]></title>
    <url>%2F2017%2F05%2F18%2FGoogleDrive%E4%BA%91%E7%9B%98%E5%90%8C%E6%AD%A5%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前通过Github + Coding将自己的博客文章进行了双服务器托管，然而真正部署到远程服务器的内容其实都是发布后的主题样式文件和HTML文章，并不是整个博客系统的源文件。这样如果自己的本地电脑挂了，磁盘文件丢失了，又需要费一番周折才能陆续恢复。 为了避免这种情况，只能及时备份，移动硬盘的备份在及时性上略差一些，因此本地文件的云端同步存储是必然选择。 云盘的选择关于云盘的选择，可以参考知乎上的 市面上哪个云同步盘最好用 以及 目前体验较好的网盘有哪些 。从个人使用经历来讲，之前一直使用的金山快盘和360云盘都已关闭个人云存储服务，最后迫不得已用了百度云盘，结果百度一看360关闭了个人云存储服务，立即搞了一系列动作，这其中就包括将云盘同步功能由免费功能变成了付费会员的功能 -_-! 最终选择了 Google Drive 云端硬盘 作为云端硬盘，支持网页版和PC版(PC版下载地址 )，考虑因素有以下几点： Google出品，功能性和稳定性可以完全不用担心 15G免费空间，对于只存放博客文件来说，绰绰有余了 不用担心像存储在百度云盘里的文件一样，某天不知道什么原因就被删除了 Google Drive修改本地文件关联路径Google Drive PC端下载、安装都是傻瓜式的，没什么说的。在使用过程中遇到了【本地文件关联路径】的问题，在此记录一下。 在Google Drive过程中，没有给我们机会去选择安装路径，默认直接安装在了C盘的C:\Users\yourusername 路径下，这就导致如果我们想要将那些文件实时同步到云端，就需要将这些文件放在该目录下，即 C:\Users\yourusername\Goole云端硬盘 目录下，一把我们都是把C盘当做系统盘，不放置额外的软件及资料文件，原因可能涉及到诸多因素，比如： 系统运行性能 文件分区管理 随时可能出现的系统故障以及随之而来的C盘重装 所以，怎样才能指定需要同步到云端的本地文件目录呢？ 断开账户关联首先，打开本地Google Drive云端硬盘，选择【偏好设置】-&gt;【账号】-&gt;【断开账户关联】 修改关联路径其次，重新开启Google Drive云端硬盘，在下一步过程中的【第四步】-&gt;【同步选项】-&gt;【更改文件夹位置】 这样，就可以指定我们想要实时同步到云端的文件夹目录了，比如我的博客目录在D:\Blog , 修改成功后的效果： （完）]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView分割线-ItemDecoration]]></title>
    <url>%2F2017%2F05%2F12%2FRecyclerView%E5%88%86%E5%89%B2%E7%BA%BF-ItemDecoration%2F</url>
    <content type="text"><![CDATA[在ListView中，可以通过控件的divider属性直接进行设置其分割线，但是RecyclerView将控件、数据适配器、布局管理器都进行了解耦，分割线也同样如此。 所以需要我们自己去处理分割线问题，这里记录两个比较常用的形式： 普通线条分割线 Item间距 普通线条分割线直接使用系统提供的DividerItemDecoration即可 1234//创建分割线对象，第一个参数为上下文，第二个参数为RecyclerView排列方向DividerItemDecoration decoration = new DividerItemDecoration(this, DividerItemDecoration.VERTICAL);//为RecyclerView添加分割线mRecyclerView.addItemDecoration(decoration); 如果感觉对系统提供的分割线颜色值、高宽等不太满意，可以通过decoration.setDrawable() 方法传入自己定制的drawable，自定义分割线的样式。 效果图如下： Item间距正常情况下，我们需要RecyclerView的每个子Item之间都有一些间距，虽然可以通过普通的margin、padding实现，但是真正在日常开发时，有可能子Item定制的比较复杂，让上述实现Item间距的方式做起来略微有点麻烦，这时候就需要自定义ItemDecoration登场了。 系统提供的DividerItemDecoration是通过继承ItemDecoration类实现的，我们也一样，由于仅仅只需要做一个间距而已，所以会更加简单。 代码如下，只做了两件事： dp to px转换 从第二个条目开始，设置每个条目与上个条目的顶部距离 123456789101112131415161718192021222324252627public class SpaceItemDecoration extends RecyclerView.ItemDecoration &#123; private int mSpace; public SpaceItemDecoration(Context context,int dpValue) &#123; mSpace = dp2px(context,dpValue); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; if(parent.getChildAdapterPosition(view) &gt; 0) &#123; //从第二个条目开始，距离上方Item的距离 outRect.top = mSpace; &#125; &#125; /** * dp to px转换 * @param context * @param dpValue * @return */ private int dp2px(Context context,int dpValue)&#123; int pxValue = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dpValue, context.getResources().getDisplayMetrics()); return pxValue; &#125;&#125; 使用方式如下：123//直接传入dp值，比如10dp，就传入10，由SpaceItemDecoration负责像素转换SpaceItemDecoration decoration = new SpaceItemDecoration(this, 10);mRecyclerView.addItemDecoration(decoration); 效果图如下：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加字数统计、阅读时长、友情链接]]></title>
    <url>%2F2017%2F05%2F11%2FHexo%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E3%80%81%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF%E3%80%81%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[字数统计NexT主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，需要经过两步：只 第一步：安装word_count插件，在博客根目录下打开终端 npm install hexo-wordcount --save 第二步：在主题配置文件(Blog\themes\next\config.yml)中打开wordcount 统计功能 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 问题如果仅仅只是打开开关，部署之后会发现文章的【字数统计】和【阅读时长】后面没有对应的xxx字，xx分钟等字样，只有光秃秃的数字在那里。如下图 解决方案找到Blog\themes\next\layout\_macro\post.swig 文件，将“字”、“分钟” 字样添加到如下位置即可。 123456789&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; ...&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 再次运行，就能得到正常的如“字数统计 1888字”“阅读时长 6分钟”这样的样式了，如下图： 添加友情链接在主题配置文件(Blog\themes\next_config.yml)中打开links 开关即可 123456# Blog rolls 友情链接links_title: Linkslinks_layout: blocklinks_layout: inlinelinks: test: http://www.example.com 问题正常情况下本地部署，远程部署都没有问题，添加了友情链接之后，hexo s 本地部署的时候，就报出了如下异常 1234567891011121314INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.Unhandled rejection Error: ENOENT: no such file or directory, open 'D:\Blog\themes\next\layout\_scripts\schemes\.swig' at Error (native) at Object.fs.openSync (fs.js:641:18) at Object.fs.readFileSync (fs.js:509:33) at Object.ret.load (D:\Blog\node_modules\swig\lib\loaders\filesystem.js:55:15) at compileFile (D:\Blog\node_modules\swig\lib\swig.js:695:31) at Object.eval [as tpl] (eval at &lt;anonymous&gt; (D:\Blog\node_modules\swig\lib\swig.js:498:13), &lt;anonymous&gt;:842:18) at compiled (D:\Blog\node_modules\swig\lib\swig.js:619:18) at _compiled (D:\Blog\node_modules\hexo\lib\theme\view.js:127:30) at View.render (D:\Blog\node_modules\hexo\lib\theme\view.js:29:15) at D:\Blog\node_modules\hexo\lib\hexo\index.js:388:25 at tryCatcher (D:\Blog\node_modules\bluebird\js\release\util.js:16:23)... 提示说在themes\next\layout\_scripts\schemes 目录下找不到.swig 这个文件，但是没有添加友链之前好像也没什么问题啊？一头雾水。。。 解决方案在 官方issue 中也没有找到自己想要的解决方案，而且google下这个问题，遇到的人好像也不多，就想到可能只是个简单的小配置问题。 于是又回头看了看文件内容，想到了第一眼看到时就比较奇怪的一点： 12links_layout: blocklinks_layout: inline 有两个layout配置，不觉得奇怪吗？ 于是果断注释掉其中一个，再次运行hexo s ，完美运行！再次测试注释掉另外一个，依然完美运行！OK，就这么轻松愉快的解决了，猜测可能是多文件冲突导致的.swig 生成问题。 (完)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android微信支付流程及返回码-1之坑]]></title>
    <url>%2F2017%2F05%2F10%2FAndroid%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E5%8F%8A%E8%BF%94%E5%9B%9E%E7%A0%81-1%E4%B9%8B%E5%9D%91%2F</url>
    <content type="text"><![CDATA[之前做微信支付的时候，直接是以库形式引入项目的，虽然一直觉得微信支付的开发文档不太理想，但是印象中也没有遇到什么大坑。 今天项目组的一个小伙伴突然告诉我微信支付一直失败，根本调不起来支付页面，onResp() 中的返回码一直是-1，而且他好像已经搞了好几个小时了。于是我pull了一下项目代码开始排查问题。最终发现问题有两个： 微信开放平台上传的签名问题 Manifest文件中WXPayEntryActivity 的配置问题。 由于在处理这两个问题的过程中，顺便又回顾了一遍微信支付的流程，以前也没有真正记录下来过，所以这里记录一下。 这里先把微信支付的返回码贴一下，看看他们是有多么敷衍： 0 成功，展示成功页面 -1 错误，可能的原因：签名错误、未注册APPID、项目设置APPID不正确、注册的APPID与设置的不匹配、其他异常等。 -2 用户取消，无需处理。发生场景：用户不支付了，点击取消，返回APP。 相信绝大部分同学在处理微信支付这块的时候，遇到的都是返回-1，然而看看关于-1的解释，完全不给力。尤其是一个其他异常，真省事。。。 其实除了appId和签名以外，还有很多其他原因会导致返回-1，这些都被微信划为了其他异常而一笔带过。 整体集成流程可以查看 微信支付App端开发步骤 ，反正他们不会告诉你有坑的，还是要自己踩-_-! 获取AppID在 微信开放平台 申请开发应用，获取APP的唯一标识APPID，比较简单。之后通过 管理中心-应用详情 即可查看自己的AppID。 向开放平台提交包名和签名自己应用的包名就不用说了，比如com.weixin.test。 签名的话，要用到 签名工具 ，是微信自己做的一个app，只有17KB,安装在手机上，输入已经安装在手机上的自己应用的包名，即可获取该包名对应的签名数据。 吐槽一下：签名工具做的也太丑陋 + 不友好了，谁用谁知道。 注意 这里获取签名的时候，务必使用release版安装在手机上，然后去获取签名，因为真正最终上线运营的时候是release版。debug和release两个jks不一致，会导致最终签名不一致，这种不一致会导致微信支付调用失败。 如果嫌release签名调试不方便，有两种方法： 先向开放平台提交debug版签名，等待开发调试完毕，再换成release签名 向开放平台提交release版签名，在gradle中配置一下，debug版本build时候也使用release的jks即可。 今天项目中遇到的其中一个坑就是在这里，签名错误，完全跟技术无关。这种问题，再debug 3天也发现不了。 调用微信支付微信支付的逻辑，大部分是有服务器端完成的，客户端只需要在3个节点上进行处理： 1.通知服务器向微信下单这个服务器就是自己的后台，我们给后台传递必要的参数，比如商品id，价格等，由后台向微信服务器下订单，下单成功后，后台会将订单信息如prepayId等回调给我们。这里就是一个Android客户端-后台服务器 Request和Response的过程。 2.在服务器回调中调用微信支付在后台向微信服务器下单成功后，会将微信支付中需要使用到的一些字段数据回传给我们，我们拿着该字段去调起微信支付即可。 123456789101112131415161718//首先在调用之前，需要先在代码中进行微信API注册IWXAPI wxApi= WXAPIFactory.createWXAPI(context, null);// 将该app注册到微信wxApi.registerApp("your AppID");//创建一个支付请求对象PayReq request = new PayReq();//开始数据封装，这里一共有7个字段，都是必传的request.appId = "wxd930ea5d5a258f4f";request.partnerId = "1900000109";request.prepayId= "1101000000140415649af9fc314aa427",;request.packageValue = "Sign=WXPay";request.nonceStr= "1101000000140429eb40476f8896f4c9";request.timeStamp= "1398746574";request.sign= "7FFECB600D7157C5AA49810D2D8F28BC2811827B";//发起请求api.sendReq(req); 这里对几个字段进行特殊说明： appId ： 直接定义为常量即可 packageValue ：直接使用&quot;Sign=WXPay&quot;,这是一个固定的值。 sign：如果服务器端已经做过了签名生成，那么这里直接拿着赋值给PayReq 对象即可；如果服务器端没有做，那么还需要在本地进行签名生成之后，再赋值。 这个本地签名生成其实就是将上面的除了sign 以外的6个字段，拼接成key-value形式的字符串，在进行MD5加密，代码如下： 123456789101112131415161718192021222324252627//开始将6个字段进行数据封装List&lt;WXModel&gt; list = new LinkedList&lt;&gt;();list.add(new WXModel("appid", payReq.appId));list.add(new WXModel("noncestr", payReq.nonceStr));list.add(new WXModel("package", payReq.packageValue));list.add(new WXModel("partnerid", payReq.partnerId));list.add(new WXModel("prepayid", payReq.prepayId));list.add(new WXModel("timestamp", payReq.timeStamp));payReq.sign = genAppSign(list);//...发起请求即可/** * 生成签名 */private String genAppSign(List&lt;WXModel&gt; list) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; list.size(); i++) &#123; sb.append(list.get(i).key); sb.append('='); sb.append(list.get(i).value); sb.append('&amp;'); &#125; sb.append("key="); sb.append(Constant.WX_APP_KEY); String appSign = MD5Utils.getMessageDigest(sb.toString().getBytes()).toUpperCase(); return appSign;&#125; 注意 签名工作一般由后台完成，在生成签名时，务必注意key的拼写问题，比如必须拼appid而不是appId，必须拼prepayid而不是prepayId，这里跟上面PayReq 对象中字段的命名方式不一样，用错了也是照样返回-1。自己曾经作为server端忽略了这一点，坑了移动端的同事一把，耽误了好几个小时-_-! 签名所使用的是 微信商户平台的API密钥，而不是微信开放平台 的 AppSecret。 API密钥在商户平台后台–&gt;API安全–&gt;先安装操作证书，后设置密钥。见下图： 3.WXPayEntryActivity中接收回调在该类的onResp() 方法中拿到微信支付的回调，然后去跟服务器再度确认支付结果。官方解释如下： 在WXPayEntryActivity类中实现onResp函数，支付完成后，微信APP会返回到商户APP并回调onResp函数，开发者需要在该函数中接收通知，判断返回错误码，如果支付成功则去后台查询支付结果再展示用户实际支付结果。注意一定不能以客户端返回作为用户支付的结果，应以服务器端的接收的支付通知或查询API返回的结果为准。 OK，到这里其实并不是就完事了。想正常接到支付成功的回调，除了上面一系列的AppId、应用签名、微信支付请求等流程不能出错外，这个类也得好好配置下才行，否则返回码-1依然在等待着你。。。 类的位置WXPayEntryActivity 类必须放在 包名.wxapi 下，比如com.weixin.test.wxapi.WXPayEntryActivity ，包名或类名不一致会造成无法回调。 Manifest文件中的声明WXPayEntryActivity 不是一个普通的类，而是要继承Activity的一个View界面，所以必须在Manifest文件中声明。那么这里坑又来了，如果仅仅只是在Manifest中声明一下，在测试的时候会发现，依然是返回-1。 需要这么配置才可以： 123456789101112&lt;activity android:name=".wxapi.WXPayEntryActivity" android:exported="true" android:launchMode="singleTop"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="your AppId"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 清空缓存最后再说一个坑，如果经过一系列的配置，发现完全都配置好了，可是微信支付依然返回-1。而此时我们可能又会回头排查各个节点的问题，是配置问题？是自己的数据传递问题？到底哪里的bug？ 其实这时候，清空下自己的应用缓存就可以了，通过 设置-应用管理-your app-清空缓存，进行缓存清理过后，立竿见影拿到成功的回调！ (完)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发中的TextView技巧点整理]]></title>
    <url>%2F2017%2F05%2F09%2FDrawerLayout-%E7%A9%BA%E7%99%BD%E5%8C%BA%E5%9F%9F%E7%82%B9%E5%87%BB%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近的项目里需要使用到侧滑布局，SlidingMenu 、自定义侧滑布局、 DrawerLayout都可以实现，前两种都已经尝试过了，最近1年多时间做项目都是使用底部导航栏，没有用到侧滑布局，DrawerLayout也一直没有去尝试，正好借此机会用一下。 mainlayout 和 drawerlayout如下图： 可以发现，drawerlayout打开时，drawerlayout的A区域（空白区域）正好覆盖在了mainlayout 的ViewPager区域，C区域（空白区域）正好覆盖在了mainlayout 的左下方Button区域。 问题当drawerlayout打开时，在drawerlayout上空白区域的点击事件，会穿透（向下传递）到底层mainlayout布局上，比如点击drawerlayout的A区域时，mainlayout的ViewPager会相应；点击drawerlayout的C区域时，mainlayout的Button会响应。 原因分析很明显，这是一个事件分发的问题，位于上层的drawerlayout布局不处理点击事件，所以事件得以传递到底层的mainlayout，而底层的mainlayout在该点击位置刚好有可以处理点击事件的控件，比如ViewPager和Button，所以这些控件就处理了。 由于drawerlayout处于打开状态时，在事件分发上处于上层，所以由它来决定事件是否分发，自己是否处理。刚才说的是空白区域，没有处理，所以才往下传递，真正自己已经处理的区域，比如B区域的RecyclerView，它的事件就不会往下传递。 那么除了B区域的RecyclerView以外，这些drawerlayout的空白区域本来就没控件来处理点击事件，注定要向下传递，怎么办呢？再自己定义DrawerLayout吗？ 解决方案当drawerlayout处于打开状态时，让drawerlayout整体可以处理点击事件即可，也就是说先把事件拦截下来，具体如何处理，由drawerlayout里的具体控件来定。 具体步骤也非常简单，就是设置一个监听： 定义DrawLayout监听123456789101112private DrawerLayout.SimpleDrawerListener mSimpleDrawerListener = new DrawerLayout.SimpleDrawerListener()&#123; @Override public void onDrawerOpened(View drawerView) &#123; //档DrawerLayout打开时，让整体DrawerLayout布局可以响应点击事件 drawerView.setClickable(true); &#125; @Override public void onDrawerClosed(View drawerView) &#123; super.onDrawerClosed(drawerView); &#125;&#125;; 在相应位置添加和移除监听12345678910@Overrideprotected void initListener() &#123; mDrawerLayout.addDrawerListener(mSimpleDrawerListener);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); mDrawerLayout.removeDrawerListener(mSimpleDrawerListener);&#125; 再运行，就不会出现穿透问题了，完事！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coding+Github双服务器托管个人博客]]></title>
    <url>%2F2017%2F05%2F05%2FCoding%2BGithub%E5%8F%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%98%E7%AE%A1%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[自从想认认真真写博客以来，会经常更新一些文章，无论是经验总结，还是读书笔记，还是纯扯扯淡。早就听说Github屏蔽了百度蜘蛛，也就是说百度搜不到我托管在Github上的博客，一直想找个空闲时间解决下这个事，于是今天就搞了一下：把博客分别托管在码云 Pages 和 Github Pages上，再通过DNS解析进行访问优化。 特殊说明 由于最后没有找到码云Pages 的绑定自定义域名在哪，所以没法通过http://www.crocutax.com/ 来访问部署到码云Pages上的博客，最终选择了 Coding Pages 作为国内的部署服务器，流程都是完全一样的，只是在Coding Pages页面有绑定自定义域名的操作而已，所以在此不再累述，本文仅作记录。开始！ 由于在Github上部署过了，所以整体在oschina上就非常熟练了。官方也有 码云 Pages 介绍，按照步骤来即可，无论是重新创建仓库+push，还是从Github导入都很简单，如果中间没有遇到坑的话，也就一两分钟的事。这里 把重点记录下。 添加公匙oschina的公匙分为 项目公匙 和 用户公匙 官方文档说明如下：项目的 SSH key只针对项目,且我们仅对项目提供了部署公钥,即项目下的公钥仅能拉取项目,这通常用于生产服务器拉取仓库的代码。 而用户的 key 则是针对用户的,用户添加了 key 就对用户名下的项目和用户参加了的项目具有权限,一般而言,用户的 key 具有推送和拉取的权限 , 而项目的 key 则只具有拉取权限 具体的添加步骤，按照 生成并部署SSH key 来即可，一开始自己只是把之前生成好的公匙直接添加进用户公匙中，结果push的时候报出日下异常： 123Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 最终通过在terminal终端输入ssh -T git@git.oschina.net来添加到 Git @ OSC，解决了此问题，报出·Welcome to Git@OSC, Crocutax(yourname)！·表明添加成功，之后就可以通过SSH方式正常的往仓库push了。 静态资源加载失败，网页样式丢失在新建立仓库的时候，项目名称 必须和 用户名称 完全一致，注意不是 昵称，否则之后部署Pages服务时就会出现静态资源加载失败，网页样式丢失的情况。 按照我部署时踩坑的情况，如果部署完毕，网站地址样式为：http://uesername.oschina.io/projectname，比如http://wangxw725.oschina.io/myblog，那么这个静态资源一定加载失败了，进去看到的就是简陋的博客目录。 如果创建仓库时项目名称和用户名称一致，那么效果如下，注意网址样式，此时就是加载成功的。 deploy部署配置修改根目录下_config.yml中的deploy配置，每次同时部署到Coding和Github两个仓库。 DNS解析优化国内使用Coding，海外使用Github，这样能相应的提升访问速度。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-《深入理解Java虚拟机》-GC对象判定算法]]></title>
    <url>%2F2017%2F05%2F04%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B-GC%E5%AF%B9%E8%B1%A1%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在 JVM内存模型 中，程序计数器、虚拟机栈、本地方法栈3个区域生命周期与所在的线程同步，栈中的每个栈帧分配多少内存基本上在类结构确定下来时就是已知的，因此这几个区域的内存分配和回收具有确定性，不需要考虑太多内存回收的问题。 而Java堆和方法区则不一样，一个接口中多个实现类需要的内存可能不一样，一个方法中多个分支小的内存也可能不一样，只有程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，也是垃圾收集器的重点关注区域。 如果想要进行垃圾回收，必须要进行垃圾对象的判定，而关于GC对象判定的算法，有如下两种： 引用计数算法 可达性分析算法 引用计数算法概念给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的对象，就可以被垃圾回收器回收。 优点实现简单，判定效率高。 缺点无法解决对象之间相互循环引用的问题（A中持有B的引用，B中持有A的引用，此时即使将A和B都赋值为null，A和B的引用计数仍不为0，无法回收），导致GC判定不准确。因此主流的Java虚拟机都没有采用这种方式来进行GC对象判定。 可达性分析算法概念通过一系列被称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索锁走过的路径称为引用链（Reference Chain）当一个对象到GC Roots没有任何引用链相连（从GC Roots到这个对象不可达）时，则证明此对象是不可用的，是可被回收的。 图中左侧的GC Roots链是可达的，而右侧Object5~7虽然相互之间存在引用，但是由于到GC Roots不可达，因此被判定为可回收的对象。 可作为GC Roots的对象 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法去中常量引用的对象 本地方法栈中Native方法引用的对象]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-《深入理解Java虚拟机》-对象探秘]]></title>
    <url>%2F2017%2F05%2F04%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B-%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98%2F</url>
    <content type="text"><![CDATA[Java是一门面向对象编程的语言，在Java程序运行过程中无时无刻都有对象被创建出来，那么在虚拟机层面，对象的创建到底涉及哪些方面？下面就从以下3个方面来了解下【对象】： 对象的创建 对象的内存布局 对象的访问定位 对象的创建我们一般创建对象都是通过new的方式，而虚拟机在遇到一条new指令时，首先会去检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析、初始化过。如果没有，则执行该类的加载过程。 类加载检查过后，对象所需的内存大小已经完全确定，虚拟机开始为对象分配内存，这里涉及两种内存分配方式： 方式1：指针碰撞如果Java堆中的内存是规整的，使用中的内存放一边，空闲的内存放另外一边，中间放着一个指针作为分界点指示器，那么此时的分配内存其实就是把指针向空闲空间挪动对象大小的距离，这种分配方式成为“指针碰撞”。 方式2：空闲列表如果Java堆中的内存是不规整的，已使用内存和空闲内存相互交错，那么此时虚拟机就需要维护一个列表，记录那些内存块是可用的，分配内存的时候从列表记录中定位到一块足够大的控件划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”。 内存分配的方式由Java堆是否规整决定，而Java堆是否规整由采用的垃圾回收器是否带有压缩整理功能决定。所以使用Serial、ParNew等带Compact过程的收集器时采用“指针碰撞”方式，而使用CMS这种基于Mark-Sweep算法的收集器时，则采用“空闲列表”方式。 内存分配过程中的并发问题解决 方案1：对分配内存空间的动作进行同步处理，即采用CAS配上失败重试的方式保证更新操作的原子性。方案2：基于本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）将内存分配的动作按照线程划分在不同的空间之中进行。 对象初始化 默认初始化：虚拟机对对象进行设置：对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄，是否启用偏向锁。。。 显示初始化：经过上一阶段后，对象的所有字段还都是零，接下来会执行方法，进行显示初始化，之后该对象才能正常使用。 对象的内存布局对象在内存中存储的布局可以分为3块区域： 对象头（Header） 实例数据（Instance Data） 对齐填充（Padding） 对象头（Header）该区域包含两部分。 第一部分：用于存储对象自身的运行时数据，例如：哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。 第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。 实例数据（Instance Data）用于存储对象的有效信息，即代码中所定义的各种类型的字段内容。 存储顺序说道虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。默认分配策略为： 相同宽度的字段分配到一起 父类中定义的变量会出现在子类之前 如果CompactFields参数值为true（默认就是true），那么子类中较窄的变量也可能会插入到父类的变量空隙之中 对齐填充（Padding）该区域仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是对象大小必须是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 对象的访问定位虚拟机规范中只规定了通过一个指向对象的引用（reference类型）来访问对象，具体的对象访问方式由虚拟机的实现而定。目前主流的访问方式由两种： 句柄 直接指针 句柄访问Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的内存地址值。 优点reference中存储的是稳定的句柄地址，在对象被移动（垃圾回收时对象会频繁移动）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 直接指针reference中直接存储对象地址值，对象中存储访问类型数据的指针 + 对象实例数据。 优点速度更快，节省了一次指针定位的时间开销，鉴于对象的访问在Java中非常频繁，因此积累起来会是一项不小的性能优化。Sun HotSpot采用“直接指针”方式进行对象访问。]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-《深入理解Java虚拟机》-JVM内存模型]]></title>
    <url>%2F2017%2F05%2F02%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自不同的用途： 程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，属于线程私有区域，此区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 作用：当前线程所执行的字节码的行号指示器。 在虚拟机概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等都依赖此计数器。 为什么该区域属于线程私有Java虚拟机的多线程是通过：线程轮流切换，并分配CPU执行时间的方式来实现的（CPU在任何一个确定的时刻只会执行【一条线程】中的指令）。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，不同线程之间互不影响，独立存储。 Java虚拟机栈Java虚拟机栈（Java Virtual Machine Stacks）描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完毕，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 注意事项： 线程私有区域，生命周期与线程一致。 局部变量表存放了编译期可知的各种基本数据类型，对象引用 64位长度的long和double类型的数据占用2个Slot，其余数据类型只占1个 局部变量表所需的内存空间在编译期间完成分配，运行期间方法入栈时在帧中分配的局部变量空间是确定的，不会发生改变。 本区域的两种异常： StackOverflowError如果线程请求的栈深度大于虚拟机锁允许的深度，则抛出此异常。 OutOfMemoryError虚拟机扩展时无法申请到足够的内存时，抛出此异常。 本地方法栈本地方法栈（Native Method Stack）与Java虚拟机栈作用类似，区别在于前者服务于Native方法，而后者服务于Java方法。 虚拟机规范中对应本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机实现方式各自不同。其中Sun HotSpot虚拟机直接把本地方法栈 和 Java虚拟机栈合二为一了。 和Java虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。 Java堆 此区域的作用是存放对象的实例，几乎所有的对象实例都在这里分配内存。 该区域是被所有线程共享的一块内存区域，在虚拟机启动时创建。 该区域是垃圾回收器管理的主要区域 从内存回收中分代收集的角度看，该区域可分为：新生代和老年代。 该区域的内存空间可以是不连续的，只要逻辑上连续即可（类似磁盘空间） 如果对中没有内存完成实例分配，并且堆也无法再扩展时，抛出OutOfMemoryError异常 方法区 方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 如果GC分代收集扩展至方法区，那么该区域一般被称为“永久代”。但是不同的虚拟机对此的定义，有所不同。 垃圾回收在此区域比较少出现，一般是针对常量池的回收，和对类型的卸载。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中。 运行时常量池相对于Class文件常量池而言更具动态性。 受方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 直接内存 在JDK1.4中引入了NIO类，一种基于通过（Channel）与缓冲区（Buffer）的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。由于变了在Java堆和Native堆中来回复制数据，因此在一些场景中可以显著提高性能。 直接内存（Direct Memory）并不是虚拟机运行时数据的一部分 直接内存的分配不会受Java堆内存大小的限制，但是受本机总内存大小以及处理器寻址空间的限制。]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近面试的一些感悟]]></title>
    <url>%2F2017%2F05%2F01%2F%E6%9C%80%E8%BF%91%E9%9D%A2%E8%AF%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[五一之前，公司陆陆续续在招人，补充Android队伍，在节前的两天，更是夸张到1天安排了10多个人过来，我从早上8点半去了就开始面试，除了中午吃饭的半小时之外，一直面试到下午6点结束，也只面试了8个人。 面试者紧张，面试别人也紧张，双方都是有备而来，而且技术问题并不涉及任何的扯淡，会就是会，不会就是不会。一个又一个的面试，尤其是连续面试的时候，让我好些时候都有个幻觉：这一类的知识点，我刚才是不是问过了？心里这么想，也不好意思问出来，否则显得多不专业啊！ 最近接触了各种各样的同学，在此简单分类总结一下： 狮子大开口型简历上各种3年5年开发经验，知识面很狭窄，技术深度很浅，对源码和原理基本不了解，一些普通技术的基本使用也说不清楚，要么英语发音让我完全听不懂，要么是以时间长了忘了为由搪塞过去。 但是，重点来了：薪资要求，动辄16K+17薪，动辄20K+15薪。语气霸气且坚定，坚持“反正不能比我以前的薪资低！”。 懵逼型这类同学不知道为什么选择来应聘，因为他们完全没有做好面试的准备。 整个面试过程基本处于一个懵逼状态，问啥啥不知道，四大组件只知道Activity，Service和BroadCast只是“听说过”。 线程池？？ 。。。 Handler实现机制？？。。。 MVP是指什么？？。。。 甚至还有一个同学，简历上有Github和CSDN的账号，我现场用手机登录，发现博客里很多都是教别人怎么学习Android，怎么做开发，面试题集锦等等，让他讲一篇他自己写的博客，也是支支吾吾，连10个字都说不出来。 这都是啥意思呢？当然，这类面试也结束的最快。 装逼型这种类型的同学有以下特点： 表达能力不错 看不上一些技术点，更喜欢谈宏观理论，对普通的技术知识有一种明显的不屑感 喜欢以基于A问题延展出自己比较了解的但是可能跟A相关度不大的B问题侃侃一番，而企图绕过A问题 喜欢转移话题，偷换概念 让我印象最深的是两个： 一个是9年开发经验，2年Java，7年Android，之前公司的头衔是技术总监；一个是6年开发，多次创业经历，各种天使轮A轮什么的。 由于我自己只是一个普通的开发人员，而且公司招的也只是Android开发人员，那我当然要问Android开发需要的知识和技能了。但是得到的答复很多情况下都是： 原理这块啊，时间长了，忘记了。 内存处理这块，也没什么难处理的问题，都是小事。 开发中遇到的问题？也没什么问题，或者算不上问题，反正最终都能解决。 数据结构这块，我没有深入研究过。 我最近3年都在做SDK开发，这些我们都用不上，所以都记不清了。 问：你觉得你最近3年做SDK，对于现在将要应聘的应用开发来说，有什么不利因素吗？ 答：没有不利因素，因为SDK开发还是用到的应用开发中的一些技术。 问：那你们做SDK这块，最主要使用了哪些技术？ 答：XXX,XXX,XXX。 问：聊聊XXX吧。 答：（参考上面几种回答） 那。。。还怎么继续聊呢？ 如果觉得招聘要求上的条目都很小儿科，那为什么搞不定这些小儿科的问题呢？那为什么还来应聘这个小儿科的职位呢？我们也没有招CTO啊？ 总结技术角度而言其实技术是永无止境的，无论是从深度还是广度来讲，每个人都在不停的学习过程中，也很少有人说自己精通了什么。 我自己对于底层原理，FrameWork，数据结构和算法也都是入门级，甚至门都没入。但是工作了几年，不可能任何的深入研究的尝试都没有做过，不可能连很多基础的使用都以“忘记了”来搪塞，不可能所有的细节都以“这些都是小问题”来糊弄。 做技术，还是要有严谨的态度，还是要有所追求的。 职场而言一个萝卜一个坑，无论是BAT，还是小米，今日头条，饿了么，美团，还是诸多默默无闻的中小企业，都需要技术人员，公司有大小，技术人员的水平有高低，但是大家各自都有自己合适的位置，合适的坑。 自己感觉自己技术不错，有更好的追求了，就追求更大的平台去挑战一下；自己感觉还需要再沉淀，那就继续再修炼。 我自己技术水平一般，面试了阿里也没有进去，有自知之明且有目标和追求，所以我在现在的位置上珍惜 + 努力。]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android7.0适配之FileProvider的使用]]></title>
    <url>%2F2017%2F04%2F25%2FAndroid7.0%E9%80%82%E9%85%8D%E4%B9%8BFileProvider%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文包括4个部分: FileProvider登场的背景 尝试翻译官方文档 FileProvider (只是自己学习的过程中顺便翻译了,并未校验,因为懒的弄;如发现错误,麻烦帮忙指正;如果掉坑里了,后果自负-_-!) FileProvider支持的path类型 FileProvider的使用示例 Android 7.0 文件权限的变化为了提高私有文件的安全性，在targetSdk版本为N或者以后版本的app中，其私有目录将会限制访问。这可以防止私有文件元数据的泄露，比如文件大小或者是文件是否存在。但这给开发者带来了一些不利的影响： 文件的所有者不能放宽文件权限，如果你使用MODE_WORLD_READABLE或者 MODE_WORLD_WRITEABLE操作文件，将会触发SecurityException。 当跨package域传递file://的URI时，接收者得到的将是一个无权访问的路径，因此，这将会触发FileUriExposedException。对于这类操作，可以使用ContentProvider, 但官方推荐的方式是使用FileProvider.在targetSdk为Android N之前的系统版本中，可以使用如下方法调用系统相机拍照并存入指定路径中 123Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);Uri uri = Uri.fromFile(sdcardTempFile);intent.putExtra(MediaStore.EXTRA_OUTPUT, uri); 但是当你将targetSdk设置为Android N时 , 在执行到这段代码时app就crash了，crash的原因便是FileUriExposedException 。这里有两种解决方案: 方案1: ContentProvider 1234Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);ContentValues contentValues = new ContentValues(1);contentValues.put(MediaStore.Images.Media.DATA, sdcardTempFile.getAbsolutePath());Uri uri = context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues); 方案2: FileProvider FileProvider简介FileProvider 是 ContentProvider 一个特殊的子类,用于通过创建content:// 类型的URI来替代file:// 类型的URI,从而为一个app提供更加安全的文件分享操作. 一个content URI允许你授予临时的读写权限,当你创建一个包含content URI的intent时,为了将这个content URI发送给一个客户端app,还可以调用Intent.setFlags()方法添加权限.这个Content类型的URI只要app存在活跃的activity就会一直有效,一旦退出app,该URI失效. 相比之下,File://类型的URI一旦提供了以后,任何app都可以使用该URI,并且在主动改变URI路径之前,这个URI一直有效,可以随时访问.这使得安全性大为降低.由于Content URI提供的更高等级的文件安全机制,使得FileProvider成为Android安全架构的一个关键部分. FileProvider主要包含以下5方面的知识点: 定义一个FileProvider 指定可访问的文件 为一个文件创建一个Content URI 为URI提供临时权限 将Content URI提供给另外一个app 1.定义一个FileProvider由于FileProvider默认提供了为文件创建content URI的功能,因此你就不必再在代码中定义一个它的子类了.你可以直接在XML文件中声明一个FileProvider. 声明FileProvider步骤: 在application标签下添加一个标签 设置android:name 属性为android.support.v4.content.FileProvider 基于app的包名来设置android:authorities属性,例如:包名为mydomain.com,那么授权路径为:com.mydomain.fileprovider 设置android:exported 属性为false;FileProvider不需要public 设置android:grantURIPermissions 属性为true,允许文件的临时访问 1234567891011121314&lt;manifest&gt; ... &lt;application&gt; ... &lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.mydomain.fileprovider" android:exported="false" android:grantURIPermissions="true"&gt; ... &lt;/provider&gt; ... &lt;/application&gt;&lt;/manifest&gt; 如果想重写FileProvider中的方法,那么继承FileProvider类,并且在XML文件中的声明时,android:name 需要使用自定义类的全路径类名 2.指定可访问的文件一个FileProvider只能为提前指定好的文件目录生成content URI.可以通过在xml文件中,以&lt;paths&gt;标签的形式指定文件目录.比如下面的代码,表明你计划为 images/ 目录下的子文件请求content URI 1234&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;files-path name="my_images" path="images/"/&gt; ...&lt;/paths&gt; &lt;paths&gt;标签必须包含一个或多个下列标签 &lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;内部存储路径,与Context.getFilesDir()返回的路径一致 &lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;内部缓存路径,与Context.getExternalFilesDir() 返回的路径一致 &lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;外置存储卡根目录,与Context.getExternalFilesDir()返回的路径一致 注意 name代表URI的路径,为了安全起见,隐藏了具体的目录位置 , 具体的目录位置由path字段指定 所有的path指定的都是目录名,包含了旗下的子目录,而不是文件名.无法通过文件名来指定单个文件,也无法通过通配符的形式指定一系列子文件. 必须为每个需要content URI的路径在xml提供标签来指定,比如下面的代码就提供了两个目录 1234&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;files-path name="my_images" path="images/"/&gt; &lt;files-path name="my_docs" path="docs/"/&gt;&lt;/paths&gt; 在资源目录下创建对应的xml文件,比如res/xml/file_paths.xml,在Manifest文件中将路径xml通过&lt;meta-data&gt;标签与FileProvider绑定起来. 123456789&lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.mydomain.fileprovider" android:exported="false" android:grantURIPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt;&lt;/provider&gt; 3.为文件生成content URI为了与其他app通过content URI来分享文件,你的app需要生成一个content URI.方法如下: 分享方app: 为该文件创建一个File对象 将File对象传递给getUriForFile(),获取一个URI对象 将该URI对象通过intent传递给其他的app 接收方app:通过ContentResolver.openFileDescriptor获取一个ParcelFileDescriptor , 读取该文件 例如:假设你的app需要提供给其他app一个FileProvider , authority授权名为com.mydomain.fileprovider , 为内部存储目录images/ 目录下的default_image.jpg 文件创建一个content URI. 123File imagePath = new File(Context.getFilesDir(), "images");File newFile = new File(imagePath, "default_image.jpg");Uri contentUri = FileProvider.getUriForFile(getContext(), "com.mydomain.fileprovider", newFile); 代码结果:getUriForFile()方法返回了一个contentUri , 路径内容为: content://com.mydomain.fileprovider/my_images/default_image.jpg 4.给URI提供临时权限从getUriForFile()获取到content URI以后,通过以下任意一种方式授予访问权限 方式1:调用Context.grantUriPermission(package, Uri, mode_flags)为content URI 授权.使用指定的mode_flags 这里需指定授权的包名和mode_flags,权限分为 FLAG_GRANT_READ_URI_PERMISSION 读 FLAG_GRANT_WRITE_URI_PERMISSION 写 可单选可多选权限的有效期为:手动撤销授权revokeUriPermission() 或 重启设备. 方式2:通过调用Intent 的 setData()方法将此content URI放入intent中调用Intent.setFlags() ,选项为 FLAG_GRANT_READ_URI_PERMISSION 读 FLAG_GRANT_WRITE_URI_PERMISSION 写 可单选可多选将此intent发送给其他app.一般情况下,会通过setResult()方法发送给其他intent 权限有效期 : 当接收到的activity处于活跃状态时持续有效 , 退出时自动失效,一个activity获取到得content URI权限,这个权限会延展至所属的整个app. 5.为其他app提供content URI5.1其他app请求自己app为一个文件提供content URI给其他app有很多形式,其中一个常用的方式时接收其他app通过startActivityResult()方法启动自己的app , 通过Intent来启动自己app中的一个Activity.你可以立即返回一个content URI , 或者展示一个交互界面供用户选择一个文件 , 一旦用户选择了该文件 , 就将该文件的的content URI返回给请求者app . 无论哪种方式 , 最终都通过setResult()方式将content URI返回给请求者. 5.2自己app请求其他app将content URI放入ClipData对象中,然后将ClipData对象添加进Intent中,再将Intent发送给一个app. 调用Intent.setClipData()来添加ClipData对象,可以放入1个或多个 . 每个ClipData对象都包含一个content URI 当通过Intent.setFlags()来设置临时访问权限时,这些权限会适用于所有的content URIs 注意 Intent.setClipData()方法只能在API 16(Android4.1)以上才能使用 , 如果为了确保版本的兼容性,那么只能每次通过intent发送一个content URI.将ACTION_SEND添加进action,通过setData()将content URI添加进data. FileProvider支持的path类型从FileProvider源码查看其中涉及的Path类型 123456private static final String TAG_ROOT_PATH = "root-path";private static final String TAG_FILES_PATH = "files-path";private static final String TAG_CACHE_PATH = "cache-path";private static final String TAG_EXTERNAL = "external-path";private static final String TAG_EXTERNAL_FILES = "external-files-path";private static final String TAG_EXTERNAL_CACHE = "external-cache-path"; 从Android官方文档上可以看出FileProvider提供以下几种path类型： &lt;files-path path=&quot;&quot; name=&quot;camera_photos&quot; /&gt; 该方式提供在应用的内部存储区的文件/子目录的文件。它对应Context.getFilesDir()返回的路径，例如/data/data/com.crocutax.mytest/files &lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 该方式提供在应用的内部存储区的缓存子目录的文件。它对应Context.getCacheDir()返回的路径，例如/data/data/com.crocutax.mytest/cache &lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 该方式提供在外部存储区域根目录下的文件。它对应Environment.getExternalStorageDirectory()返回的路径，例如/storage/emulated/0 &lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 该方式提供在应用的外部存储区根目录的下的文件。它对应Context.getExternalFilesDir(String type)返回的路径。例如 12ContextCompat.getExternalFilesDirs(MainActivity.this,null)[0]: //log输出: /storage/emulated/0/Android/data/com.crocutax.mytest/files &lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt; 该方式提供在应用的外部缓存区根目录的文件。它对应Context.getExternalCacheDir()返回的路径。 12ContextCompat.getExternalCacheDirs(MainActivity.this)[0]: //log输出: /storage/emulated/0/Android/data/com.crocutax.mytest/cache FileProvider的使用示例1.在Manifest文件中定义FileProvider123456789&lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.touchmedia.daolan.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths" /&gt; &lt;/provider&gt; 2.res/xml/file_paths中指定共享目录123&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="sdcard_path" path="" /&gt;&lt;/paths&gt; 3.通过FileProvider获取ContentUri123456789//安装app...//通过FileProvider获取contentUriUri contentUri = FileProvider.getUriForFile(mContext, "com.touchmedia.daolan.fileprovider", apkFile);//授予临时访问权限intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);intent.setDataAndType(contentUri,"application/vnd.android.package-archive");//跳往安装界面mContext.startActivityForResult(intent,INSTALL_APP); 其他涉及到本地文件读取的操作,例如图库,操作方式都一样,跟以前唯一的不同仅仅只是FileProvider的引入. 另外,可参考如下链接: CommonsWare FileProvider专题FileProvider无法获取外置SD卡问题解决方案Android7.0适配心得]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>版本特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio导入Eclipse项目-填坑记录]]></title>
    <url>%2F2017%2F04%2F25%2FAndroidStudio%E5%AF%BC%E5%85%A5Eclipse%E9%A1%B9%E7%9B%AE-%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最早开始使用AndroidStudio的时候 , 导入Eclipse项目 , 填了很多坑 , 当时也没想着记录下来 . 最近公司做一个视频监控的项目 , down下来硬件厂商提供的Android SDK之后 , 发现竟然是Eclipse写的!!! 这已经是2017年了!!! Eclipse !!! 导入的过程中,再次填坑2个,在此记录.以后再遇到此类问题,都会补充在这篇文章里,不过考虑到Eclipse写Android项目真是几乎绝迹了,所以估计这篇文章收录的也不会再多了-_-! Could not determine the class-path for interface错误信息:Error:Could not determine the class-path for interface com.android.builder.model.AndroidProject. 原因Gradle配置错误 解决方案:第一步:将 项目根目录下的build.gradle文件中gradle的classpath修改成一个本地已有的gradle版本,比如 123dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.1'&#125; 第二步:将gradle目录下gradle-wrapper.properties文件中distributionUrl修改为对应的gradle包,比如 1distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip 第三步:rebuild 参考地址: stackoverflow 链接直达 非法字符: ‘\ufeff’ 错误: 需要class, interface或enum错误信息: 原因该文件非UTF-8 无 BOM 格式，具体原因未知,可能是Android Studio检测更加严格了?(就像当初很多Eclipse中的.9图放在AndroidStudio就报错一样) 这里只是猜测. 解决方案:手动把该文件转换为UTF-8 无 BOM格式编码, 我使用的时Notepad++,打开该文件后,直接编码转换即可 然后rebuild就可以了.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池基础知识整理]]></title>
    <url>%2F2017%2F04%2F23%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.为什么需要线程池在面向对象编程中 ,创建和销毁对象是很耗时的,因为创建一个对象要获取内存资源或者其他更多资源.所以在日常编程中才会有意的避免过多的创建并不必要的对象. 线程的创建和销毁也是同样,而且相比于普通的对象更为消耗资源.线程池技术的引入,就是为了解决这一问题. 1.1 线程池简介线程池是指在初始化一个多线程应用程序过程中创建的一个线程集合,线程池在任务未到来之前,会创建一定数量的线程放入空闲队列中.这些线程都是处于睡眠状态,即均未启动,因此不消耗CPU,只是占用很小的内存空间.当请求到来之后,线程池给这次请求分配一个空闲线程,把请求传入此线程中运行,进行处理. 当预先创建的线程都处于运行状态时,线程池可以再创建一定数量的新线程,用于处理更多的任务请求. 如果线程池中的最大线程数使用满了,则会抛出异常,拒绝请求.当系统比较清闲时,也可以通过移除一部分一直处于停用状态的线程,线程池中的每个线程都有可能被分配多个任务,一旦任务完成,线程回到线程池中并等待下一次分配任务. 使用线程池可以提升性能,减少CPU资源的消耗,同时还可以控制活动线程,防止并发线程过多,避免内存消耗过度. 1.2 线程池优点总结 复用线程池中的线程,避免因为线程的创建和销毁所带来的性能开销 能有效控制线程池的最大并发数量,避免大量线程之间因互相抢占系统资源而导致的阻塞现象. 能够对线程进行简单的管理,并提供定时执行,指定间隔,循环执行等功能. 2.Executor的继承关系图黄色为接口 , 蓝色为类 体系成员简介: Executor线程池体系的顶层接口,只有一个execute()方法用于执行Runnable任务.该体系内的所有类,接口都默认实现/继承 此接口,并在此基础上进行分类扩展. 12345678910//源码public interface Executor &#123; /** * @param command Runnable任务 * @throws RejectedExecutionException 如果任务无法继续执行,则抛出此异常 * @throws NullPointerException 如果传入的Runnable为null,则抛出此异常 */ void execute(Runnable command);&#125; ExecutorServiceExecutor的扩展接口,用于定义一些Runnable管理相关的方法,比如 void shutdown(); 有序关闭已经提交的任务,但是不再接受新的任务,重复shotdown无效.而且此方法不会等待已提交任务的执行完毕. List&lt;Runnable&gt; shutdownNow(); 尝试停止所有正在执行的任务,终止所有处于等待队列中的任务,并将这些等待被执行的任务返回给调用者 boolean isShutdown(); 判断线程池是否已关闭 boolean isTerminated(); 当调用了showdown()方法后,所有任务是否已执行结束.注意:如果不事先调用showdown()方法,则此方法永远返回false. boolean awaitTermination(long timeout, TimeUnit unit); 当调用shotdown()方法后,调用此方法可以设置等待时间,等待执行中的任务全部结束,全部结束返回true.如果超时,或线程中断导致未全部结束则返回false. &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); 提交有返回值的Runnable任务. &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit) 执行传入的任务,当所有任务执行结束或超时后,返回持有任务状态和结果的Future集合.注意:一个任务结束有两种情况:1.正常执行完成;2.抛出异常. &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks); 执行传入的任务,只要有任何一个任务成功执行完成(不抛出异常),一旦有结果返回,或抛出异常,则其他任务取消. ScheduledExecutorServiceExecutorService的子接口,定义了延迟或周期性执行Runnable任务的方法. AbstractExecutorServiceExecutorService的默认抽象实现类,对ExecutorService进行了简单实现,开发者可以参考并重写这些方法. SerialExecutorServiceExecutorService的子接口,标记型接口,该类型的线程池会以队列(先进先出)的顺序执行提交的任务. ThreadPoolExecutorAbstractExecutorService子接口的默认实现类,可以使用这个类自定义线程池使用.系统提供的几种常用线程池,最终都是通过此类来创建. ScheduledThreadPoolExecutorScheduledExecutorService子接口的实现类,继承ThreadPoolExecutor,用于延迟或周期性执行Runnable任务. 3.如何创建线程池Executor是Java中的一个接口,其默认实现类是ThreadPoolExecutor,构造方法如下1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor一共有4个重载的构造方法,上述代码中的后三位参数都是可选参数.通过构造方法即可自定义线程池.然后通过execute()来执行Runnable任务. 涉及到的几个参数解释如下: corePoolSize 线程池的核心线程数,默认情况下,核心线程会在线程池中一直存活,即使它们处于闲置状态.如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true,那么闲置的[核心线程]在等待新任务到来时会有超时策略,这个时间间隔由keepAliveTime所指定,当等待时间超过keepAliveTime所指定的时长后,核心线程就会被终止. maximumPoolSize 线程池所能容纳的最大线程数,当活动线程数达到这个数值后,后续的新任务将会被阻塞. keepAliveTime 非核心线程闲置时的超时时长,超过这个时长,非核心线程就会被回收.当ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true时, keepAliveTime同样会作用于核心线程. 这个[保活时间]设计的巧妙之处在于:当线程处于闲置状态时,并不马上销毁，而是在指定时间段内将其缓存在线程池中,以方便在限定的时间段内如果再有任务来临，能够快速的重新启用等待中的线程.处于闲置状态的空闲线程并不会占用多少内存,而且这样就能显著减少频繁的创建,销毁线程造成的内存消耗及性能下降. unit 用于指定keepAliveTime参数的时间单位,这是一个枚举,常用的有TimeUnit.NANOSECONDS(毫秒),TimeUnit.SECONDS(秒),TimeUnit.MINUTES(分钟)等 workQueue 线程池中等待被执行的任务队列,这个队列仅持有通过execute方法提交的Runnable任务. threadFactory 线程工厂,ThreadFactory是个接口,它只有一个方法,·Thread newThread(Runnable r),executor创建新线程时调用 RejectedExecutionHandler 当由于线程阻塞,任务队列容量已满等因素导致无法成功执行任务时,这个handler会调用rejectedExecution方法来通知调用者. 4.系统封装的4种线程池这里要使用到Executors类,它是Executor体系的静态工厂类,类中封装了一些创建线程池的方法.Executor与其子接口及其实现类负责定义和规范线程池,而Executors负责创建线程池. 4.1 SingleThreadExecutorSingleThreadExecutor内部只有一个核心线程,它确保所有的任务都在同一个线程中按顺序执行.它的意义在于统一所有的外界任务到一个线程中,使得在这些任务之间不需要处理线程同步的问题. 内部实现如下:123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 代码测试:12345678910private void singleThreadExecutorTest() &#123; //单一线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); //开启5次线程 for (int i = 0; i &lt; 5; i++) &#123; singleThreadExecutor.execute(new MyThread()); &#125; //关闭线程池 singleThreadExecutor.shutdown();&#125; Log输出:12345System.out: pool-1-thread-1 执行System.out: pool-1-thread-1 执行System.out: pool-1-thread-1 执行System.out: pool-1-thread-1 执行System.out: pool-1-thread-1 执行 4.2 FixedThreadPoolExecutorFixedThreadPoolExecutor是一种线程数量固定的线程池,只有核心线程,没有超时机制,任务队列没有大小限制.当所有的线程都处于活动状态时,新任务都会处于等待状态,直到有线程空闲出来.当线程处于空闲状态时,它们并不会被回收,除非线程池被关闭了.这意味着它能够更加快速的响应外界的请求. 123456//构造方法public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 代码测试:12345678910111213141516171819/**自定义一个线程类,继承Thread,打印Log*/class MyThread extends Thread&#123; public void run() &#123; System.out.println(Thread.currentThread().getName()+" 执行"); &#125;&#125;private void fixedThreadPoolTest() &#123; //容量为2的固定线程池 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2); //创建5条线程 for (int i = 0; i &lt; 5; i++) &#123; fixedThreadPool.execute(new MyThread()); &#125; //关闭线程池 fixedThreadPool.shutdown();&#125; Log输出:12345System.out: pool-1-thread-1 执行System.out: pool-1-thread-2 执行System.out: pool-1-thread-2 执行System.out: pool-1-thread-2 执行System.out: pool-1-thread-1 执行 可以发现,虽然new了5个Thread,但是系统只用两条线程来执行5个任务. 4.3 CachedThreadPoolCachedThreadPool线程数量不定,只有非核心线程,并且其最大线程数为Integer.MAX_VALUE(相当于无限大)当线程池中的线程都处于活动状态时,线程池会创建新的线程来处理新任务,否则就会利用空闲的线程来处理新任务. 空闲线程都有超时时机,这个超时时长为60秒,限制超60秒就会被回收. 和FixedThreadPoolExecutor不同的是,CachedThreadPool的任务队列其实相当一个空集合,这将导致任何任务都会被立即执行,因为此时SynchronousQueue是无法插入任务的.CachedThreadPool线程池比较适合执行大量+耗时较少的任务.当整个线程池都处于闲置状态时,会因超时而被停止,此时没有线程的线程池几乎不占用任何系统资源. 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 代码测试:1234567891011private void cachedThreadPoolTest() &#123; //缓存线程池 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); //创建5条线程 for (int i = 0; i &lt; 5; i++) &#123; cachedThreadPool.execute(new MyThread()); &#125; //关闭线程池 cachedThreadPool.shutdown();&#125; Log输出:12345System.out: pool-1-thread-1执行System.out: pool-1-thread-1执行System.out: pool-1-thread-2执行System.out: pool-1-thread-3执行System.out: pool-1-thread-4执行 4.4 ScheduledThreadPoolExecutorScheduledThreadPoolExecutor核心线程数固定,非核心线程数没有限制,并且非核心线程闲置时会被回收主要用于执行定时任务 和 具有固定周期的重复任务. 1234567891011121314//Executors静态方法public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;//继续追查ScheduledThreadPoolExecutor源码,会发现最终还是通过ThreadPoolExecutor的构造来创建public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; 常用方法: schedule(Runnable command,long delay, TimeUnit unit)XXX时间之后,执行指定的任务 scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)XXX时间后,执行指定任务,每隔XXX时间执行一次 代码测试:1234567891011121314151617181920private void scheduledThreadPoolTest() &#123; //定时任务线程池 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(1); //3秒后打印一次Log scheduledThreadPool.schedule(new Runnable() &#123; @Override public void run() &#123; System.out.println("~~~~~~~~~3秒之后露个脸~~~~~~~~~"); &#125; &#125;,3000,TimeUnit.MILLISECONDS); //0秒初始化延迟,每秒打印Log scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println("每隔一秒打印一次"); &#125; &#125;,0,1000, TimeUnit.MILLISECONDS);&#125; Log输出:1234567System.out: 每隔一秒打印一次System.out: 每隔一秒打印一次System.out: 每隔一秒打印一次System.out: ~~~~~~~~~3秒之后露个脸~~~~~~~~~System.out: 每隔一秒打印一次System.out: 每隔一秒打印一次System.out: 每隔一秒打印一次 5.总结可以发现,系统提供的4种线程池,最终都是通过配置ThreadPoolExecutor的不同参数,来巧妙的达到不同的线程管理效果. 以上只是关于线程池的一些基础认知,下一篇进行 线程池运行原理分析.]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程池运行原理分析]]></title>
    <url>%2F2017%2F04%2F23%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[上一篇 线程池基础知识整理 做了简单的总结后,本篇来试着追一追源码,看看线程池的内部运行逻辑. 要想分析透彻整个线程池运行的逻辑,是个庞杂的工程,牵扯到线程池生命周期管理,队列管理,拒绝策略,调配逻辑等等.这里只是从一个Runnable任务发布到线程池中以后,线程池内部的运行逻辑角度去尝试分析. 先贴出整理的线程池操作流程图 , 然后开始追源码: 线程数量控制策略ThreadPoolExecutor是线程池的实现类,无论是自定义线程池,还是使用系统提供的线程池,都会使用到这个类.通过类的execute(Runnable command)方法来执行Runnable任务.那么一旦将一个Runnable任务execute()以后,到底发生了什么? 直接看代码 1234567891011121314151617181920212223242526272829303132333435363738/** * 将该Runnable任务加入线程池并在未来某个时刻执行 * 该任务可能执行在一个新的线程 或 一个已存在的线程池中的线程 * 如果该任务提交失败,可能是因为线程池已关闭,或者已达到线程池队列和线程数已满. * 该Runnable将交给RejectedExecutionHandler处理,抛出RejectedExecutionException */public void execute(Runnable command) &#123; if (command == null)&#123; //如果没传入Runnable任务,则抛出空指针异常 throw new NullPointerException(); &#125; int c = ctl.get(); //当前线程数 小于 核心线程数 if (workerCountOf(c) &lt; corePoolSize) &#123; //直接开启新的线程,并将Runnable传入作为第一个要执行的任务,成功返回true,否则返回false if (addWorker(command, true))&#123; return; &#125; c = ctl.get(); &#125; //c &lt; SHUTDOWN代表线程池处于RUNNING状态 + 将Runnable添加到任务队列,如果添加成功返回true失败返回false if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //成功加入队列后,再次检查是否需要添加新线程(因为已存在的线程可能在上次检查后销毁了,或者线程池在进入本方法后关闭了) if (! isRunning(recheck) &amp;&amp; remove(command))&#123; //如果线程池处于非RUNNING状态 并且 将该Runnable从任务队列中移除成功,则拒绝执行此任务 //交给RejectedExecutionHandler调用rejectedExecution方法,拒绝执行此任务 reject(command); &#125;else if (workerCountOf(recheck) == 0)&#123; //如果线程池线程数量为0,则创建一条新线程,去执行 addWorker(null, false); &#125; &#125;else if (!addWorker(command, false)) //如果线程池处于非RUNNING状态 或 将Runnable添加到队列失败(队列已满导致),则执行默认的拒绝策略 reject(command);&#125; 整理流程如下: 如果线程池中的线程数量少于corePoolSize(核心线程数量),那么会直接开启一个新的核心线程来执行任务,即使此时有空闲线程存在. 如果线程池中线程数量大于等于corePoolSize(核心线程数量),那么任务会被插入到任务队列中排队,等待被执行.此时并不添加新的线程. 如果在步骤2中由于任务队列已满导致无法将新任务进行排队,这个时候有两种情况: 线程数量 [未] 达到maximumPoolSize(线程池最大线程数) , 立刻启动一个非核心线程来执行任务. 线程数量 [已] 达到maximumPoolSize(线程池最大线程数) , 拒绝执行此任务.ThreadPoolExecutor会通过RejectedExecutionHandler,抛出RejectExecutionException异常. 以上就是一旦将一个Runnable任务execute()以后,执行的一系列逻辑,理解起来并不难,下面再对其中调用的一些方法做一些追查,就更方便理解其中的运行逻辑. 线程数量及线程池状态管理我们发现在execute()方法中频繁的执行这句c = ctl.get();代码,那么这ctl是什么,get()方法获取到的是什么,获取到的c又用来做什么? 上源码:12345678910111213141516171819//创建AtomicInteger对象private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3; //32-3 = 29//最大线程容量private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; //将1的二进制向右位移29位,再减1//运行状态保存在int值的高3位 (所有数值左移29位)private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;//运行状态private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;//线程数量private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;//是否正在运行private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125; 以上代码中的信息整理如下: clt是一个AtomicInteger对象,(提供原子操作进行Integer的使用,适用于高并发场景.该AtomicInteger的value可以自动刷新,确保在高并发环境下的唯一性.),而ctl.get()获取的就是该value值. 线程池用一个AtomicInteger来保存 [线程数量] 和 [线程池状态] ,一个int数值一共有32位,高3位用于保存运行状态,低29位用于保存线程数量 系统默认的线程容量就是(2^29)-1 , 大约5亿条线程-_-! 所以由此得知 :频繁的调用c = ctl.get();是为了获取该AtomicInteger的最新值,进而通过位运算获取线程池的最新运行状态,线程数量. [线程池状态]: RUNNING: 接收新任务,并执行队列中的任务 SHUTDOWN: 不接收新任务,但是执行队列中的任务 STOP: 不接收新任务,不执行队列中的任务,中断正在执行中的任务 TIDYING: 所有的任务都已结束,线程数量为0,处于该状态的线程池即将调用terminated()方法 TERMINATED: terminated()方法执行完成 新线程的创建在execute()方法中获知通过addWorker()方法来添加新线程,那么到底是如何添加和管理的?开始追源码,一看究竟. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 往线程池中添加Worker对象 * @param firstTask 线程中第一个要执行的任务 * @param core 是否为核心线程 * @return 添加是否成功 */ private boolean addWorker(Runnable firstTask, boolean core) &#123; //这里有两层[死循环],外循环:不停的判断线程池的状态 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //一系列判断条件:线程池关闭,Runnable为空,队列为空,则直接return false,代表Runnable添加失败 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; !workQueue.isEmpty()))&#123; return false; &#125; //内循环:不停的检查线程容量 for (;;) &#123; int wc = workerCountOf(c); //超过线程数限制,则return false if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))&#123; return false; &#125; //★ 添加线程成功,则直接跳出两层循环,继续往下执行. //注意:这里只是把线程数成功添加到了AtomicInteger记录的线程池数量中,真正的Runnable添加,在下面的代码中进行 if (compareAndIncrementWorkerCount(c))&#123; break retry; &#125; //再次判断线程池最新状态,如果状态改变了(内循环和外循环记录的状态不符),则重新开始外层死循环 c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs)&#123; continue retry; &#125; &#125; &#125; //结束循环之后,开始真正的创建线程. boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //创建一个Worker对象,并将Runnable当做参数传入 w = new Worker(firstTask); //从worker对象中取出线程 final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; //拿到锁 mainLock.lock(); try &#123; //再次检查线程池最新状态 int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; //检查准备执行Runnable的Thread的状态,如果该Thread已处于启动状态,则抛出状态异常(因为目前还没启动呢) if (t.isAlive())&#123; throw new IllegalThreadStateException(); &#125; //将新创建的worker,添加到worker集合 workers.add(w); ... workerAdded = true; &#125; &#125; finally &#123; //释放锁 mainLock.unlock(); &#125; if (workerAdded) &#123; //★Thread开始启动 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; //添加worker失败 if (! workerStarted)&#123; addWorkerFailed(w); &#125; &#125; return workerStarted;&#125; 总结: 先判断线程池状态和线程池中线程的容量,如果满足线程添加的条件,则先把AtomicInteger中记录的线程数量+1.然后再进行线程添加的工作. 创建worker对象,并将Runnable作为参数传递进去,并从worker中取出Thread对象,进行一系列条件判断后.开启Thread的start()方法,线程开始运行.所以worker对象中必然包含了一个Thread和一个要被执行的Runnable. 那么接下来继续追源码,印证下第二点的推断,看看Worker到底干了什么. Worker类 123456789101112131415161718192021222324//ThreadPoolExecutor的内部finial类private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; //当前worker要执行任务所用的线程(如果创建失败,则可能是null) final Thread thread; //第一个要执行的任务(可能是null) Runnable firstTask; //当前线程执行完的任务总数 volatile long completedTasks; //通过构造传入Runnable任务 Worker(Runnable firstTask) &#123; ... this.firstTask = firstTask; //通过ThreadFactory()创建新线程 this.thread = getThreadFactory().newThread(this); &#125; //调用外部类runWorker()方法 public void run() &#123; runWorker(this); &#125; ...&#125; worker类中的内部实现也印证了我们的推断: 每个worker,都是一条线程,同时里面包含了一个firstTask,即初始化时要被首先执行的任务. 最终执行任务的,是runWorker()方法 线程的复用继续追runWorker()方法的源码 123456789101112131415161718192021222324252627282930313233343536//ThreadPoolExecutor的final类,该方法由内部类Worker的run()方法调用final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); //取出Worker对象中的Runnable任务 Runnable task = w.firstTask; boolean completedAbruptly = true; ... try &#123; //★注意这个while循环,在这里实现了 [线程复用] while (task != null || (task = getTask()) != null) &#123; //上锁 w.lock(); //检查Thread状态的代码 ... try &#123; ... try &#123; //执行Worker中的Runnable任务 task.run(); &#125; catch (...) &#123; ...catch各种异常 &#125; &#125; finally &#123; //置空任务(这样下次循环开始时,task依然为null,需要再通过getTask()取) + 记录该Worker完成任务数量 + 解锁 task = null; w.completedTasks++; w.unlock(); &#125; &#125; //该线程已经从队列中取不到任务了,改变标记 completedAbruptly = false; &#125; finally &#123; //线程移除 processWorkerExit(w, completedAbruptly); &#125;&#125; 通过上面的源码,发现通过一个while循环,不断的getTask()取任务出来执行,以这种方式实现了线程的复用. 线程复用逻辑整理如下: 如果task不为空,则开始执行task 如果task为空,则通过getTask()再去取任务,并赋值给task,如果取到的Runnable不为空,则执行该任务 执行完毕后,通过while循环继续getTask()取任务 如果getTask()取到的任务依然是空,那么整个runWorker()方法执行完毕 上面只是从getTask()方法名和其返回值来猜测此方法的作用,下面就继续追源码,来证实和研究getTask()到底是怎么取任务的,从哪取,怎么取. getTask() 1234567891011121314151617181920212223242526272829private Runnable getTask() &#123; ... for (;;) &#123; ... // 如果线程池已关闭 或 任务队列为空,则AtomicInteger中记录的线程数量-1,并return null,结束本方法 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; //获取当前线程池中的总线程数 int wc = workerCountOf(c); //allowCoreThreadTimeOut参数是使用者自行设置的(默认false),用来设置:是否允许核心线程有超时策略 //条件1:核心线程超时 条件2:当前线程数 &gt; 核心线程数,满足任何一个条件则timed标记为true boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //超过最大线程数 或 超时 或 任务队列为空... 线程数量-1 + return null ... try &#123; //根据timed标记,使用不同的方式(限时等待 or 阻塞)从BlockingQueue&lt;Runnable&gt; workQueue 队列中取任务 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null)&#123; //如果取到了,就将Runnable返回 return r; &#125; //如果没取到,则重新for循环 ... &#125; &#125;&#125; 将以上源码中的信息整理如下: 线程池使用BlockingQueue来管理整个线程池中的Runnable任务,变量workQueue存放的都是待执行的任务 BlockingQueue是个阻塞队列，BlockingQueue.take()方法如果得到的是空，则进入等待状态,直到BlockingQueue有新的对象被加入时,才可以正常将Runnable取出并返回,线程开始正常运转,正常执行Runnable任务。 123456789101112131415/** * 先进先出的阻塞队列 */public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; /** * 检索并移除队列的顶部元素,如果该元素不可用则等待,直至元素可用 * Retrieves and removes the head of this queue, waiting if necessary * until an element becomes available. * * @return the head of this queue * @throws InterruptedException if interrupted while waiting */ E take() ...&#125; 让我们整理一下上面几段源码的逻辑顺序: execute()方法执行之后,进行一系列的逻辑判断来控制线程池中的线程数量,并通过addWorker()方法创建新线程 一旦Worker里的Thread开始start()之后,执行的其实是Worker里的run()方法,run()方法调用runWorker(Worker w)方法. 在runWorker()方法里面通过getTask()方法不停的取workQueue队列中的任务来执行,如果取到了就执行,如果没取到就等待. 结论: 一旦一个线程开启之后,会一直执行下去,直至任务队列中的任务执行完毕,达成了线程的复用 以Runnable队列为目标的worker虽然是串行操作,但是由于可以通过addWorker()添加多个worker,并且多个worker取的是同一个BlockingQueue中的Runnable,所以就实现了并行处理. 线程的移除在runWorker()方法中有如下代码:123456789101112131415final void runWorker(Worker w) &#123; boolean completedAbruptly = true; ... try &#123; while (getTask()...) &#123; ... 处理任务 &#125; //该线程已经从队列中取不到任务了,改变标记,该标记表示:该线程是否因用户因素导致的异常而终止 completedAbruptly = false; &#125; finally &#123; //线程移除 processWorkerExit(w, completedAbruptly); &#125;&#125; processWorkerExit这里用来将worker从worker集合中移除,步骤如下: 先移除传入的Worker(线程) 判断线程池里的最少线程数,如果最少线程数为0条,但是队列里依然有任务未执行完毕.那么必须确保线程池中至少有1条线程.(将最小线程数置为1) 如果当前线程数 &gt; 最小线程数,本方法结束,不再往下执行 否则添加一条新线程,来替代当前线程,继续去执行队列中的任务. 1234567891011121314151617181920212223242526272829/** * @param w the worker 线程 * @param completedAbruptly 该线程是否因用户因素导致的异常而终止 */private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; ... try &#123; //记录该线程完成任务的总数 completedTaskCount += w.completedTasks; //从worker集合中移除本worker(线程) workers.remove(w); &#125; ... //如果在runWoker()中正常执行任务完毕,这里completedAbruptly传入的就是false if (!completedAbruptly) &#123; int min = allowCoreThreadTimeOut ? 0 : corePoolSize; //如果线程池里最少线程数为0,但是此时任务队列里依然还有任务 if (min == 0 &amp;&amp; ! workQueue.isEmpty())&#123; //那么必须保留一条线程,所以将最小值设置为1 min = 1; &#125; //如果当前线程数&gt;= 最小线程数,则直接return if (workerCountOf(c) &gt;= min)&#123; return; &#125; &#125; //否则添加一条新线程,来替代当前线程,继续去执行队列中的任务. addWorker(null, false);&#125; 这次源码分析就先到这里,一路从execute()开始,走到线程移除.其实线程池里面涉及到的问题很多,以后有时间再慢慢研究. 参考链接:从使用到原理学习Java线程池]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发规范]]></title>
    <url>%2F2017%2F04%2F22%2FAndroid%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[分包规范包名全部小写，连续的单词只是简单地连接起来，不使用下划线。 采用反域名命名规则，全部使用小写字母。一级包名为com，二级包名为xxx（公司名），三级包名根据应用进行命名，四级包名为模块名或层级名。 例如：com.longke.qq.activity com.xxx.activity Activity类 com.xxx.service Service com.xxx.receiver BroadCastReceiver com.xxx.provider ContentProvider com.xxx.base 基类 com.xxx.adapter ViewPager/RecyclerView等适配器 com.xxx.util 各种StringUtil,NetUtil,BitmapUtil等工具类 com.xxx.view 自定义view/第三方开源控件 com.xxx.bean 各种实体类,下面可以再细分VO,PO,DTO com.xxx.db 数据库操作类 注意: 部分特殊的第三方SDK,比如微信支付,Zxing,讯飞语言等对如果对包位置有特殊要求的,按第三方要求来 MyApplication等全局相关的配置类,放在包名目录下 命名规范核心原则 见名知意 禁用拼音 标准统一 类 Activity / Fragment / Adapter / Bean… 类名由一个或多个单词组成，采用 大驼峰命名法 同一界面,不同类型的类,前缀必须一样,比如:HomePageActivity,HomePageFragment,HomePageListAdapter… Listener Listener接口监听事件的命名规范：以On开头Listener作为后缀。具体：On+事件描述+Listener 例如：点击事件：OnClickListener 对应的调用方法：setOnClickListener() 常量常量命名采用 : 全大写 + 下划线方式例如： public static final int LOGIN_FLAG = 1 ; intent标记的key以INTENT 开头 , 各个单词以_隔开,例如： public static final String INTENT_CAR_ID = &quot;intentCarId&quot;; 变量变量以小驼峰式命名法,不同类型的变量又有不同的命名方式. 私有成员变量必须以”ｍ”开头 + 变量名 例如： private int mThemeId = 0; private boolean mIsOpen; private List&lt;Strng&gt; mUrlList; 静态成员变量必须以”s”开头 + 变量名 private static boolean sIsOpen = false; 局部变量小驼峰命名法 public String getUserName(){ String userName = getUserNameFromDB(); ... } 方法方法命名规则采用小驼峰命名法例如: onCreate() / onResume() / onRun() getXX()返回某个值的方法 initXX() 初始化相关方法，比如初始化布局:initView() checkXX()和isXX()方法为boolean值的时候使用is或者check为前缀 saveXX() 保存数据 clearXX()和removeXX() 清除数据 updateXX() 更新数据 processXX() 对数据进行处理 dispalyXX() 显示某某信息 对于方法的其他一些规范 方法的参数尽可能不超过4个，多余4个考虑采用builder模式或者JavaBean形式 注意单一职责原则 方法尽量避免返回null,可以考虑抛异常或空数据,比如Collections.emptyList() 类声明规范区块划分建议使用注释将源文件分为明显的区块，区块划分如下 常量声明区 UI控件成员变量声明区 普通成员变量声明区 内部接口声明区 初始化相关方法区 事件响应方法区 普通逻辑方法区 重载的逻辑方法区 生命周期回调方法区 内部类声明区 类成员排列通用规则按照发生的先后顺序排列 常量按照使用先后排列 UI控件成员变量按照layout文件中的先后顺序排列 普通成员变量按照使用的先后顺序排列 方法基本上都按照调用的先后顺序在各自区块中排列 相关功能作为小区块放在一起（或者作为一个封装体引入） 重载方法永不分离,当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。 资源文件命名规范 Activity对应的布局文件命名:XxxActivity--&gt; activity_xxx.xml,比如MainActivity.java--&gt; activity_main.xml XML中控件命名:控件名界面名作用,例如:tv_homepage_name ,et_login_phone 图片命名,资源文件,控件id命名：activity名称+功能名称（背景bg，按钮bt,图片控件iv等）+自己名称 RecyclerView / ListView中的item布局文件命名规范：以item_list作为前缀，以页面名称作为中缀，以列表描述作为后缀。具体：”itemlist“+页面名称+列表描述,例如：item_list_login_users.xml Dialog布局文件命名规范：以dialog作为前缀，如果是通用的dialog则以common作为中缀以功能描述作为后缀。如果是对应页面定制的dialog,以页面描述作为中缀，dialog描述作为后缀。具体： 通用的dialog：dialog+common+功能描述，例如dialog_common_hint.xml 指定页面的dialog：dialog+页面名称+功能描述，例如dialog_login_pwd_error.xml values下文件命名strings.xml直接以对应的内容的英文单词组合命名.例如： &lt;string name=&quot;buy_ticket&quot;&gt;购票&lt;/string&gt; &lt;string name=&quot;region_list&quot;&gt;景区列表&lt;/string&gt; colors.xml具体：页面+”_”+描述+颜色名称,例如：登录页面登录按钮字体颜色 &lt;!--登录页面登录按钮字体颜色 --&gt; &lt;color name=&quot;login_activity_login_btn_text&quot;&gt;#000000&lt;/color&gt; 当然还有一些APP主题色,规范为:common_描述 ,例如: &lt;!--通用的item字体颜色 --&gt; &lt;color name=&quot;common_item_text&quot;&gt;#33AACC&lt;/color&gt; dimens.xml文件命名&lt;resources&gt; &lt;!-- Default screen margins, per the Android Design guidelines. --&gt; &lt;dimen name=&quot;activity_horizontal_margin&quot;&gt;16dp&lt;/dimen&gt; &lt;dimen name=&quot;activity_vertical_margin&quot;&gt;16dp&lt;/dimen&gt; &lt;/resources&gt; drawable目录下资源文件命名规范：selector文件以selector作为前缀，以某个页面的作为中缀如果是多个页面就以模块名称作为中缀或者是项目通用的就以common作为中缀，以功能描述作为后缀。 具体： selector+页面名称+功能描述 selector+模块名称+功能描述 selector+common+功能描述 例如： 登陆页面的确认按钮：selector_login_confirm_btn.xml（login为页面名称） 所有支付模块购买的按钮：selector_pay_buy_btn.xml(buy为模块名称) 所有通用按钮的背景：selector_common_btn_bg.xml shape图形以shape 作为前缀，如果是通用的以common作为中缀，如果是单独页面的以页面名称作为中缀，或者以模块名称作为中缀，以功能描述作为后缀。 具体形式和selector一样。 图片资源图片资源命名规范 全部小写，采用下划线命名法，加前缀区分 命名模式：可加后缀 _small 表示小图, _big 表示大图，逻辑名称可由多个单词加下划线组成，采用以下规则： 用途_模块名_逻辑名称 用途_模块名_颜色 用途_逻辑名称 用途_颜色 icon图片资源以ic开头； 具体： 前缀+&quot;&quot;+页面名称+&quot;&quot;+描述 （如果页面和描述一致的则不用重复） 欢迎页面背景图 bg_welcome.png 登录页面 登录按钮背景 bg_login_btn.png btn_main_home.png 按键 divider_maket_white.png 分割线 ic_edit.png 图标 bg_main.png 背景 btn_red.png 红色按键 btn_red_big.png 红色大按键 ic_head_small.png 小头像 bg_input.png 输入框背景 divider_white.png 白色分割线 anim目录全部小写，采用下划线命名法，加前缀区分。具体动画采用以下规则： 模块名_逻辑名称逻辑名称 refresh_progress.xml market_cart_add.xml market_cart_remove.xml 普通的tween动画采用如下命名方式: // 前面为动画的类型，后面为方向 动画命名例子 描述 fade_in 淡入 fade_out 淡出 push_down_in 从下方推入 push_down_out 从下方推出 push_left 推向左方 slide_in_from_top 从头部滑动进入 zoom_enter 变形进入 slide_in 滑动进入 shrink_to_middle 中间缩小 代码管理 每完成一个小功能，无论是单个界面的UI，还是某个模块的逻辑，都先本地commit，最后统一push 每天下班之前必须push当天代码 必须确保push到远程仓库的代码是可以正常运行的，不能存在编译错误 使用.gitignore过滤掉自动生成的文件 养成push之前先pull的习惯 技术选型编程框架标配为 RxJava2.0 + Retrofit2.0 + MVP 架构设计以下自选： MVP MVVM 禁用 MVC 万能Activity 备选开源库选择开源库时考虑的因素： 低耦合 单一职责 star 和 issue数 维护频率 图片 Glide Picasso Fresco 禁用 UIL Volley 网络Retrofit + Okhttp 禁用 XUtils Volley 数据库 GreenDao Realm 禁用 XUtils 原生Sqlite 事件总线 EventBus RxBus 如非必须，不用BroadcastReceiver，使用BroadcastReceiver时应用内通信首选LocalBroadcastReceiver. 依赖注入 ButterKnife Dagger2 禁用 XUtils 手动findViewById 其他如发现有其他更加优秀的开源库,欢迎讨论,补充 其他注意事项 定义类或者接口 首行留空格，末尾不留；其次每个逻辑分区都要留单行空格（除普通常量定义外） 定义类或者接口变量时，请使用基类或者顶层接口定义变量 自行控制类、接口、及其成员的访问权限，尽量缩小访问权限 类如果不是为扩展而设计的请加final修饰符 遇到switch语句时，酌情考虑将每个case语句拆分成单个函数调用 接口定义不加“I”前缀，实现添加”impl”后缀，如果有必要请提供默认的实现和其它实现 （默认实现:Default+接口名+impl，其它实现 :具体扩展功能 + 接口 + impl） 具有controller功能的类或者接口定义 都以 功能+“manager” 形式定义 所有表示层设计的实体定义形式为 : 功能+“model” 所有列表展示用RecyclerView，禁用ListView]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速运行Github上的Android开源项目]]></title>
    <url>%2F2017%2F03%2F17%2F%E5%BF%AB%E9%80%9F%E8%BF%90%E8%A1%8CGithub%E4%B8%8A%E7%9A%84Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[从Github上git clone代码以后,做以下两步工作: 1.检查开源项目的 gradle 版本，buildTools 版本以及 compile sdk 版本，确保是本机电脑已经下载好的版本. 2.利用project下的gradlew工具进行如下操作: 12./gradlew clean./gradlew installDebug 常见异常: SDK location not found. Define location with sdk.dir in the local.properties file or with an ANDROID_HOME environment variable. 解决方法: 在project目录下,创建local.properties配置文件,指定SDK目录即可sdk.dir=F\:\\Dev\\sdk]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-技术人成长百科指南]]></title>
    <url>%2F2017%2F02%2F06%2F%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF%E4%BA%BA%E6%88%90%E9%95%BF%E7%99%BE%E7%A7%91%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[做技术到了一定阶段，总会遇到瓶颈，也一直在寻找突破点，无论是广度和深度上，都在努力尝试。偶然看到这篇推送的集合文章 技术人成长百科指南：给你一束光，路在你脚下，收获颇多，非常感谢各位前辈的指导。 天天写「业务代码」，如何成为「技术大牛」?技术提升就像游戏中升级打怪一样，开始打小怪，经验值很高，越到后面经验值越少，打小怪已经不能提升经验值了。这个时候就需要打一些更高级的怪，刷一些有挑战的副本了，没看到哪个游戏只要一直打小怪就能升到顶级的。 错误观点: 1、上班做的都是重复工作，要想提升必须自己额外去学习 2、学习需要大段的连续时间 实际情况 实际上正好相反：首先我们应该在工作中学习和提升，因为学以致用或者有实例参考，学习的效果是最好的；其次工作后学习不需要大段时间，而是要挤出时间，利用时间碎片来学习。 Do more做的更多，做的比你主管安排给你的任务更多。 熟悉更多业务 需求分析时更加精准,提前识别风险,影响,难度 问题处理时更加快速 方案设计时考虑更加周全 熟悉端到端 “系统性”、“全局性”、“综合性”这些字眼看起来比较虚，但其实都是技术大牛的必备的素质，要达到这样的境界，必须去熟悉更多系统、业务、代码。 自学 如果是公司封装好的框架,平时的业务代码确实不需要太多的技术含量,可能就是if else,因此必须要深度自学,以备不时之需 Do Better只要你去想，其实总能发现可以改进的地方的,识别出这些地方，并且给出解决方案，然后向主管提出，一次不行两次，多提几次，只要有一次落地了，这就是你的机会。 如果你觉得系统哪里都没有改进的地方，那就说明你的水平还不够，可以多学习相关技术，多看看业界其它公司怎么做，BAT都怎么做 Do exercise自己可以学习很多知识,但是在实际工作中运用到的却不多,不可能一个人干所有技术点所涉及到得工作,学到得技术如何运用? 1、Learning 注重系统性,建议先通过书籍系统性的学习之后,再去看博客,Google,视频 2、Trying 自己模拟环境,自己写Demo,自己测试.顺便也了解了端到端. 3、Teaching 自学和练习只能学到70%,分享出去,在整理和反馈中才能发现剩余的30%. 先定一个小目标将目标进行三次分解,划分成短期内可以达到的小目标. 一段分解:等级 1）0 ~ 1年：菜鸟，需要别人手把手来教2）1 ~ 3年：初级，需要别人带你做3）3 ~ 5年：高级，能独当一面，可以带初级技术人员了4）5 ~ 8年：资深，能独挡多面5）8 ~ 10年：大牛，统筹规划，高屋建瓴 二段分解:技能 为了达到一段目标，我需要具备什么样的技能.做一个思维导图,哪里不懂补哪里 三段分解：执行 可以根据实际情况,进行顺序的灵活调整 年龄渐长，技术人的发展之路该怎么走？ 编程能力与编程年龄 根据StackOverflow的统计数据,从事编程的人员25-30岁的居多,但是真正的能力输出高峰,确是在40-50岁.也就是说,绝大多数人都止步在了程序员的入门/初级/中级阶段,就止步,转行了. 如果你没有编程到30岁，你还不能成为一个“合格”的程序员。所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门. 程序员技术能力上升是可以到50岁或60岁的。 老程序员在获取新技术上的能力并不比年轻的程序员差。 30岁之前要培养的能力 高效的学习能力 解决问题的能力 一味的埋头加班苦干是没有意义的,一定要在技术基础,深度,广度上加强.宁肯工作延期也要做这些事情. 工作中的Leadership 帮人解问题 被人所依赖]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[笔记-技术小黑屋LIVE-如何写好博客]]></title>
    <url>%2F2017%2F01%2F12%2F%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF%E5%B0%8F%E9%BB%91%E5%B1%8BLIVE-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一直想好好整理一下博客，但是却一直是一拖再拖，一直觉得自己太菜了需要再准备下，明日复明日，却一直没有准备好，最终想写的东西逐渐都淡忘了，也没有落实太多行动，看来永远都没有真正算得上是 “准备好了”的时候。 今天听了技术小黑屋的一场LIVE，讲的挺好，决定无论多垃圾，反正是自己用来记录的，无所谓了，有胜于无，垃圾总比没有好，开始好好整理下吧。 为什么要写博客 记录与备忘 深入理解知识点 在开放的回馈中发现自己理解的不足(技术知识是永无止境的) 开源与分享,提升个人名气和收益 如何写好 能够将一件事情讲清楚 格式清晰 思路清晰 是什么,为什么,怎么做? 如何讲清楚一件事 抓住本质 认清楚彼此的知识差距，照顾下限 联系现实 借鉴质量可靠的文章来理解一些概念(英文原文或大牛文章) 不要引入无关、干扰的概念 文章不要太长，一般人对太长的文章都有本能的排斥 注意无序和有序列表的使用 高亮代码是对程序员最基本的尊重 如何选题 以读者需求为导向 (快速提高关注度) 以个人研究为导向 (提升自我能力) 没有时间怎么办 第一阶段：研究阶段 可以将一个技术切换成零散的点，用零碎的时间去分开研究这些技术点 可以睡觉前、早晨、工作间歇等时间点 第二阶段：书写阶段 最好是连续的时间 博客平台的选择 第三方平台：CSDN、简书 技术成本低 流量获取快 权限低,可控性低 自己搭建 可控性高 前期流量太低,像一个孤岛 技术不太行,先学习还是先写文章 员工想着让老板先涨薪再努力工作,老板想着让员工先努力工作再涨薪.先技术还是先博客,道理一样. 每个阶段都有可以写的文章,一项文章如果自己了解了60%,那么就写这60%,在写的过程中,将会学习到剩下的40%. 看别人写的文章,一点点学习等方式技术进步都略慢.因为自己并没有深入思考,而且会随着时间的推移而忘记,真正的输出知识,才是进步最快的方式. 技术文章写的像文档,怎么区分 进行模块切分 注意引言和总结 做好承前启后的过渡 写博客注意事项 无论如何选择,最好支持Markdown,因为书写效率较高. 尽量少用大块的代码片段,如果需要大量代码,则需要删除一些无用的代码,最后可以给出代码链接. 避免代码横向过长,避免横向水平滚动条 一图胜千言 可以写一系列小而精的文章,而不要写一篇大而全的文章. 需要标明引用或转载 如果是翻译,需要标注原文+获得原作者授权. 如果是转载或参考,则需要加入原文链接.]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发中的TextView技巧点整理]]></title>
    <url>%2F2016%2F12%2F28%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84TextView%E6%8A%80%E5%B7%A7%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本篇文章主要是记录一下日常开发中,对TextView控件的一些使用过的技巧的整理,仅限自己开发中用到的一些点,并不全面,也没有太多技术含量.只是为了方便一些程序员小伙伴用到得时候，搜到之后拿来即用。如发现有错误,烦请帮忙指证,谢谢! 本文主要罗列了以下技巧点： 通过换行符换行 在TextView中引入图片资源 动态变换TextView中的图片资源 设置字体和样式 加载自定义字体 限制TextView字符数 多文字展示中常见的【显示全部-收起】 价格标签与下划线 文字描边与阴影 跑马灯效果 设置字间距与行间距 Demo动态图如下： 1.通过换行符换行非常基础的换行符“\n”的使用，有些时候在一些复杂ItemView中，会有上下两行TextView罗列用来展示内容的情况，如果两行TextView的字体样式一致，并且数据来源固定或统一，此时可以考虑用一个TextView搞定，能少绘制一个TextView，甚至是用来包裹他们的LineaLayout也省了。 代码： 123456&lt;!--普通换行--&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorAccent&quot; android:text=&quot;&apos;好好学习\n天天向上&quot; /&gt; 效果图： 2.在TextView中引入图片资源一个图片+几个文字的的控件搭配在任何项目中都太常见了，比如 这个可以用LineaLayout来水平包裹ImageView+TextView，也可以直接通过TextView的drawableXxx属性来将图片资源嵌入TextView中。其中Xxx是指图片摆放的位置，包括 drawableLeft 左侧 drawableRight 右侧 drawableTop 上方 drawableBottom 下方 drawableStart 控件空间的起始位置 drawableEnd 控件空间的末尾 代码：123456789&lt;TextView android:id=&quot;@+id/tv_drawable&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:drawablePadding=&quot;10dp&quot; android:drawableRight=&quot;@drawable/password_hide&quot; android:gravity=&quot;center&quot; android:text=&quot;点下试试&quot; /&gt; 效果图： 3.动态变换TextView中的图片资源上面谈到的图片+文字的两种布局方式中，LinearLayout水平包裹的方式虽然略显臃肿，但是动态替换其中的图片比较方便，直接操作包裹的ImageView即可。而TextView内嵌图片的方式，在动态替换图片资源时，略显繁琐，不过也很简单，主要是对Drawable对象的操作。 代码：123456//1.通过图片资源获取Drawable对象Drawable showPwdDrawable = getResources().getDrawable(R.drawable.password_show);//2.设置Drawable对象的显示范围showPwdDrawable.setBounds(0, 0, showPwdDrawable.getMinimumWidth(), showPwdDrawable.getMinimumHeight());//3.将Drawable设置给TextView(方法中的4个参数，分别对应Drawable相对于文字而言放置的位置：左上右下四个位置)textview.setCompoundDrawables(null, null, showPwdDrawable, null); 效果图： 4.设置字体和样式TextView的typeface属性可以用来设置字体,默认有4种类型 normal sans serif monospace textStyle属性可以用来设置样式，默认有3种类型： bold 粗体 italic 斜体 normal 正常(默认) 代码： 1234567891011121314151617&lt;!--粗体+serif样式--&gt;&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;@string/study&quot; android:textStyle=&quot;bold&quot; android:typeface=&quot;serif&quot; /&gt;&lt;!--斜体 + monospace样式--&gt;&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;@string/study&quot; android:textStyle=&quot;italic&quot; android:typeface=&quot;monospace&quot; /&gt; 效果图: 5.加载自定义字体除了系统默认提供的几种字体以外,还可以加载自定义的字体.注意:字体文件必须是真正的ttf(TrueTypeFont)文件,否则要么没有效果 , 要么直接抛java.lang.RuntimeException: Font asset not found fonts异常,. 步骤:1.将ttf字体文件放在Module的src/main/assets/fonts/目录下2.加载字体文件到内存,并设置给TextView 1234//通过Typeface的静态方法加载字体资源到内存Typeface typeface = Typeface.createFromAsset(getAssets(), &quot;fonts/华文行楷.ttf&quot;);//将typeface设置给TextViewtvCustomTypeface.setTypeface(typeface); 效果图: 6.限制TextView字符数为了UI效果或者屏幕适配等因素,经常需要对TextView展示出来的字数做限制,其实也很简单通过3个属性就可以搞定: ellipsize 省略位置 maxEms 最大字符数,一个汉字占1个字符,1个英文/符号占半个字符;从第maxEms+1位置开始用省略号代替 maxLines 行数限制(singleLine也行,但是已被标记为Deprecated) 12345678&lt;!--限制字符数--&gt;&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:ellipsize=&quot;end&quot; android:maxLines=&quot;1&quot; android:maxEms=&quot;7&quot; android:text=&quot;@string/study&quot; /&gt; 效果图: 7.多文字展示中常见的【显示全部-收起】这个比较常见,比如看个朋友圈或者微博,不会直接将文字内容全部罗列展示出来,而是末尾有个[更多]or[显示全部],点击后就会将文字内容全部显示出来.(当然也有点击后跳转页面的,跟这次谈的内容无关,这是举个例子) 实现起来也比较简单,通过setMaxLines(int maxLines)方法即可达到目的. 每次点击[显示全部-收起]按钮时 , 执行以下事件 , 即可实现 . 效果图请看文章开头的gif图. 12345678showAll = !showAll;if(showAll)&#123; tvShowAll.setMaxLines(2); btnShowAll.setText(&quot;查看全部&quot;); &#125;else &#123; tvShowAll.setMaxLines(20); btnShowAll.setText(&quot;收起&quot;); &#125; 注意 开发中当碰到上述问题时,同时必然存在一个前提场景,那就是根据数据内容来动态判断是该展示 [显示全部]按钮. 此时需要动态获取textview加载了内容后占据了几行,比如我们需求规定超过3行,末尾就要省略+展示[显示更多] . 此时需要用到TextView的getLineCount()方法. getLineCount() 方法Return the number of lines of text, or 0 if the internal Layout has not been built.返回TextView内容的行数 , 如果没内容则返回0 需要注意的时,此方法不能直接在onCreate()中调用,因为此时TextView的内容可能还没有加载完毕导致获取到得行数为0.可以用如下方式来决定[显示全部]按钮是否显示 12345678910textview.post(new Runnable() &#123; @Override public void run() &#123; if(textview.getLineCount() &gt; 3)&#123; //textview内容大于行数限制,展示[显示全部]按钮&quot; &#125;else &#123; //textview内容小于等于行数限制&quot; &#125; &#125;&#125;); 8.价格标签与下划线在商品交易类模块必然牵扯到商品价格 , 而一般出于促销目的,会在界面上展示出商品原价和现价 ,原价远高于现价, 同时再把原价划上一条横线表示作废以刺激客户消费 . 这是很常见的 价格促销UI. 这个效果需要TextView通过Paint对象来绘制,系统都封装好了,我们简单使用即可. 第一步,正常定义XML 1234567891011121314151617&lt;!--价格标签--&gt;&lt;!--中间横线--&gt;&lt;TextView android:id=&quot;@+id/tv_line_middle&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;￥20.00&quot; android:textColor=&quot;@android:color/holo_red_dark&quot; /&gt;&lt;!--底部横线--&gt;&lt;TextView android:id=&quot;@+id/tv_line_end&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;￥20.00&quot; android:textColor=&quot;@android:color/holo_red_dark&quot; /&gt; 第二步,通过TextView的Paint对象来划线 1234//中间横线tvLineMiddle.getPaint().setFlags(Paint. STRIKE_THRU_TEXT_FLAG );//下划线tvLineEnd.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG); 效果图: 9.文字描边与阴影涉及属性: shadowColor : Place a blurred shadow of text underneath the text, drawn with the specified color.用指定颜色在文字下方绘制模糊的阴影 shadowDx Horizontal offset of the text shadow. 文字阴影的横向/水平偏移量 shadowDy Vertical offset of the text shadow. 文字阴影的纵向/垂直偏移量 shadowRadius Blur radius of the text shadow. 阴影的半径范围 123456789&lt;!--文字描边与阴影--&gt;&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:shadowColor=&quot;#ff0000&quot; android:shadowDx=&quot;5&quot; android:shadowDy=&quot;5&quot; android:shadowRadius=&quot;5&quot; android:text=&quot;@string/study&quot; /&gt; 效果图: 10.跑马灯效果现在这种效果用的越来越少了,不赘述了. 直接上代码,效果图见文章顶部gif: 1234567891011&lt;!--跑马灯效果--&gt;&lt;TextView android:layout_width=&quot;200dp&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_blue_light&quot; android:ellipsize=&quot;marquee&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; android:marqueeRepeatLimit=&quot;marquee_forever&quot; android:singleLine=&quot;true&quot; android:text=&quot;@string/poem&quot; /&gt; 11.设置字间距与行间距涉及属性: letterSpacing 字间距 Must be a floating point value, such as “0.2”. (0.0~1.0 stands for a letter) —–必须是0.0~1.0之间的小数,以一个字母为空间标准 lineSpacingExtra 行距 Must be a dimension value, which is a floating point number appended with a unit such as “14.5sp”. Available units are: px (pixels), dp (density-independent pixels), sp (scaled pixels based on preferred font size), in (inches), mm (millimeters). —–直接通过px,dp,sp等单位指定行距,例如14.5sp lineSpacingMultiplier 行间距的倍数 Must be a floating point value, such as “1.2”.—-比如1.2倍 直接使用上述属性,即可达到设置字间距,行间距的目的,代码如下,效果图见文章顶部gif 12345678910111213141516171819202122232425 &lt;!--字间距0.5字符--&gt;&lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@android:color/darker_gray&quot; android:letterSpacing=&quot;0.5&quot; android:text=&quot;@string/poem&quot; /&gt; &lt;!--行间距10sp--&gt;&lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@android:color/holo_green_light&quot; android:lineSpacingExtra=&quot;10sp&quot; android:text=&quot;@string/poem&quot; /&gt;&lt;!--行间距1.8倍--&gt;&lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:lineSpacingMultiplier=&quot;1.8&quot; android:text=&quot;@string/poem&quot; /&gt; Demo下载地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewPager+Fragment组合的预加载和懒加载]]></title>
    <url>%2F2016%2F12%2F23%2FViewPager%2BFragment%E7%BB%84%E5%90%88%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[预加载介绍ViewPager+Fragment的搭配在日常开发中也比较常见,可用于切换展示不同类别的页面,我们日常所见的咨询、购物、金融、社交等类型的APP都有机会用到这种控件组合. 例如: ViewPager控件有个特有的预加载机制,即默认情况下当前页面左右两侧的1个页面会被加载,以方便用户滑动切换到相邻的界面时,可以更加顺畅的显示出来. 通过ViewPager的setOffscreenPageLimit(int limit)可以设置预加载页面数量，当前页面相邻的limit个页面会被预加载进内存. 效果如下:注意看Log输出 懒加载介绍所谓的懒加载,其实也就是延迟加载,就是等到该页面的UI展示给用户时,再加载该页面的数据(从网络、数据库等),而不是依靠ViewPager预加载机制提前加载两三个,甚至更多页面的数据.这样可以提高所属Activity的初始化速度,也可以为用户节省流量.而这种懒加载的方式也已经/正在被诸多APP所采用. 但是通过ViewPager方法setOffscreenPageLimit(int limit)的源码可以发现,ViewPager通过一定的逻辑判断来确保至少会预加载左右两侧相邻的1个页面,也就是说无法通过简单的配置做到懒加载的效果. ViewPager方法setOffscreenPageLimit(int limit) 相关源码 //默认的缓存页面数量(常量) private static final int DEFAULT_OFFSCREEN_PAGES = 1; //缓存页面数量(变量) private int mOffscreenPageLimit = DEFAULT_OFFSCREEN_PAGES; public void setOffscreenPageLimit(int limit) { //当我们手动设置的limit数小于默认值1时,limit值会自动被赋值为默认值1(即DEFAULT_OFFSCREEN_PAGES) if (limit &lt; DEFAULT_OFFSCREEN_PAGES) { Log.w(TAG, &quot;Requested offscreen page limit &quot; + limit + &quot; too small; defaulting to &quot;+ DEFAULT_OFFSCREEN_PAGES); limit = DEFAULT_OFFSCREEN_PAGES; } if (limit != mOffscreenPageLimit) { //经过前面的拦截判断后,将limit的值设置给mOffscreenPageLimit,用于 mOffscreenPageLimit = limit; populate(); } } 关于变量mOffscreenPageLimit到底是什么.可以从其get方法注释中略见端倪 /** * 返回空闲状态下的视图层级中,当前页面任何一侧保存的页面数量,默认是1 * Returns the number of pages that will be retained to either side of the * current page in the view hierarchy in an idle state. Defaults to 1. * * @return How many pages will be kept offscreen on either side * @see #setOffscreenPageLimit(int) */ public int getOffscreenPageLimit() { return mOffscreenPageLimit; } 至于mOffscreenPageLimit到底是怎么影响ViewPager控件预加载的,暂不追查,因为此次的目的并不是ViewPager运行原理分析. 如何做到懒加载既然通过ViewPager无法达到我们想要的懒加载效果,那么就得从Fragment自身入手了. Fragment为我们提供了一个方法setUserVisibleHint(boolean isVisibleToUser),其中的参数isVisibleToUser就是表示该Fragment的UI对于用户是否可见 Fragment的方法 setUserVisibleHint(boolean isVisibleToUser) /** * Set a hint to the system about whether this fragment&apos;s UI is currently visible * to the user. This hint defaults to true and is persistent across fragment instance * state save and restore. * * &lt;p&gt;An app may set this to false to indicate that the fragment&apos;s UI is * scrolled out of visibility or is otherwise not directly visible to the user. * This may be used by the system to prioritize operations such as fragment lifecycle updates * or loader ordering behavior.&lt;/p&gt; * * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This method may be called outside of the fragment lifecycle. * and thus has no ordering guarantees with regard to fragment lifecycle method calls.&lt;/p&gt; * * @param isVisibleToUser true if this fragment&apos;s UI is currently visible to the user (default), * false if it is not. */ public void setUserVisibleHint(boolean isVisibleToUser) { if (!mUserVisibleHint &amp;&amp; isVisibleToUser &amp;&amp; mState &lt; STARTED &amp;&amp; mFragmentManager != null &amp;&amp; isAdded()) { mFragmentManager.performPendingDeferredStart(this); } mUserVisibleHint = isVisibleToUser; mDeferStart = mState &lt; STARTED &amp;&amp; !isVisibleToUser; } 大意就是通过此方法来设置Fragment的UI对用户是否可见,当该页面对用户可见/不可见时,系统都会回调此方法. 我们可以重写此方法，然后根据回调的isVisibleToUser参数来进行相关的逻辑判断,以达到懒加载的效果,比如如果isVisibleToUser==true的话表示当前Fragment对用户可见，此时再去加载页面数据. 由于ViewPager内会装载多个Fragment,而这种懒加载机制对于各个Fragment属于共同操作,因此适合将其抽取到BaseFragment中. 注意 setUserVisibleHint(boolean isVisibleToUser)方法会多次回调,而且可能会在onCreateView()方法执行完毕之前回调.如果isVisibleToUser==true,然后进行数据加载和控件数据填充,但是onCreateView()方法并未执行完毕,此时就会出现NullPointerException空指针异常. 基于以上原因,我们进行数据懒加载的时机需要满足两个条件 onCreateView()方法执行完毕 setUserVisibleHint(boolean isVisibleToUser)方法返回true 所以在BaseFragment中用两个布尔型标记来记录这两个条件的状态.只有同时满足了,才能加载数据 //Fragment的View加载完毕的标记 private boolean isViewCreated; //Fragment对用户可见的标记 private boolean isUIVisible; 第一步,改变isViewCreated标记 当onViewCreated()方法执行时,表明View已经加载完毕,此时改变isViewCreated标记为true,并调用lazyLoad()方法 @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); isViewCreated = true; lazyLoad(); } 第二步,改变isUIVisible标记 当setUserVisibleHint(boolean isVisibleToUser)回调为true时,改变isUIVisible标记为true,并调用lazyLoad()方法 @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); //isVisibleToUser这个boolean值表示:该Fragment的UI 用户是否可见 if (isVisibleToUser) { isUIVisible = true; lazyLoad(); } else { isUIVisible = false; } } 第三步: 在lazyLoad()方法中进行双重标记判断,通过后即可进行数据加载 private void lazyLoad() { //这里进行双重标记判断,是因为setUserVisibleHint会多次回调,并且会在onCreateView执行前回调,必须确保onCreateView加载完毕且页面可见,才加载数据 if (isViewCreated &amp;&amp; isUIVisible) { loadData(); //数据加载完毕,恢复标记,防止重复加载 isViewCreated = false; isUIVisible = false; printLog(mTextviewContent+&quot;可见,加载数据&quot;); } } 第四步:定义抽象方法loadData(),具体加载数据的工作,交给子类去完成 protected abstract void loadData(); 注意: 数据加载完毕要恢复标记,防止数据重复加载 效果如下: Demo源码Github源码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio的Gradle配置]]></title>
    <url>%2F2016%2F11%2F23%2FAndroidStudio%E7%9A%84Gradle%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Gradle官网 签名配置可以在debug模式下测试第三方登录,注册,支付等等,不用再每次都先打包再测试了 123456789101112131415signingConfigs&#123; debug &#123; storeFile file("D://test.keystore") storePassword "123456" keyAlias "test" keyPassword "123456" &#125; release &#123; storeFile file("D://test.keystore") storePassword "123456" keyAlias "test" keyPassword "123456" &#125;&#125; 指定jni目录12345sourceSets &#123; main &#123; jniLibs.srcDirs = ['src/main/jniLibs'] &#125;&#125; 配置.so支持平台arm平台下的.so可以兼容其他平台 所以如果.so平台丰富导致包体积过大,可以只保留armeabi-v7a和x86两个包下的.so(会略微影响性能) ndk { abiFilters &apos;armeabi&apos;,&apos;armeabi-v7a&apos;, &apos;arm64-v8a&apos;, &apos;x86&apos;, &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos; } exit values 2报出exit values 2 之类的错误,这时候一般是由于添加了重复的依赖包.以下方法可能会有帮助 1.检查build.gradle中的dependencies配置,去除重复的依赖包 1compile fileTree(include: ['*.jar'], dir: 'libs',exclude:'android-support-v4.jar') 2.build.gradle的Android节点下,配置 12345packagingOptions &#123; exclude 'META-INF/NOTICE' // will not include NOTICE file exclude 'META-INF/LICENSE' // will not include LICENSE file exclude 'META-INF/services/javax.annotation.processing.Processor'&#125; 编译版本号 compileSdkVersion：这个主要是我们编译app时候用的sdk版本，就我们在AndroidStudio上面点击运行时候的编译时候的环境。记住这个只是在编译时候选择的版本，不涉及到运行时候的行为。由于androidStudio有预编译的功能所以会提示一些警告，提前了解新的sdk minSdkVersion:这个就是程序运行的最低的要求的Sdk，就是给说如果我设置的minSdkVersion是15的话那么如果你系统低于这个SdkVersion是安装不上的。还有一个好处就是。例如你设置miniSdk是3.0的话，你写的方法只有在4.0后才有的方法，这个时候就会提示你在3.0的时候是没有这个方法的。 targetSdkVersion:targetSdk主要是提供向前兼容的作用]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[笔记-代码家学习经验分享]]></title>
    <url>%2F2016%2F10%2F02%2F%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E5%AE%B6%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[在微信公众号上看了代码家的分享文章 分享一些自己的学习历程和学习建议 ,了解到了大神的学习方法，颇有收获。 对比自己，发现确实是二手知识获取的太多了，一手知识和自主思考太少了，学习时越轻松，工作时越麻烦，而真正应有的学习方式应该是反过来。 技术永无止境，而学习方式也尤其重要，整理阅读笔记如下： 学习的三个阶段 第一阶段：消费者阶段 第二阶段：实践者阶段 第三阶段：创造者阶段 真正的学习学习的过程都是伴随着思考和痛苦的，如果你边笑边学习（学习过程非常轻松），那你真的得醒醒了 目标和激励很重要用小Demo做目标,而不是一味的学习，一味的输入知识.有激励才有动力,持续的输入而没有输出,会很快丧失兴趣和动力. 用适度的成果输出来激励自己，能更高的提升知识输入的效率和效果。 你永远无法一步达到完美以最低成本去展现你想法的核心部分，后期再迭代，而非直接做一个大而全的方案 赶在兴趣消失之前，马上开始学习新知识如果对哪门新技术产生了兴趣，不要往后拖,赶紧去入个门,否则这个兴趣会很快消失,而自己也失去了一次了解新知识的机会. 少看别人写的文章，多看优秀的代码慢慢减少对二手知识的依赖,多学习官方文档,源码,更加全面的培养自主知识体系和解决问题的能力 收藏的意义不大 以后不会看的,没有时间. 如果以后用到了,再去Google就可以了,说不定能找到更好的. 培养一些对产品的感觉 培养产品经理的思维,而不是一味的做一个码农 每个人都应该有个 idea list 争取去更优秀的地方顾名思义]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio使用中的问题记录]]></title>
    <url>%2F2016%2F06%2F03%2FAndroidStudio%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Android Studio在使用过程中遇到了各种各样的小问题 , 记录在此 , 方便备查 , 后续若再有新问题 , 也追加到这里. 首次安装AS，卡在downloading Components界面 从任务管理器中强制退出 在AndroidStudio安装目录的bin目录下，打开 idea.properties 文件 在文件末尾追加 disable.android.first.run=true 即可 卡在Refreshing …gradle project这是因为AS去联网下载对应的gradle了，如果网速比较慢的话 , 这个过程可能需要消耗很长时间 . 解决:可以选择去gradle网站下载好安装包，然后再复制到C:\Users\Administrator.gradle\wrapper\dists目录下即可.gradle安装包下载地址（不用翻墙，可用） It is currently in use by another Gradle instance123456Error:Timeout waiting to lock artifact cache (C:\Users\Crocutax\.gradle\caches\modules-2). It is currently in use by another Gradle instance.Owner PID: 16896Our PID: 10860Owner Operation: resolve configuration ':classpath'Our operation: resolve configuration ':classpath'Lock file: C:\Users\Crocutax\.gradle\caches\modules-2\modules-2.lock 解决方法: 去往指定目录C:\Users\Crocutax.gradle\caches\modules-2 删除modules-2.lock文件,此时会提示该文件被Java占用,无法删除 调出任务管理器,将跟Java相关的进程杀死,即可正常删除该文件 Android Studio 重新Build即可 gradle project refresh failed Error： “Invalid argument”app/build.gradle里dependencies有错误 , 看看是不是小手一抖,把某个依赖的名字改错了. Failed to resolve dependenciesgradle添加远程依赖时,出现 Failed to resolve dependencies xxx 1.看看是不是网络不行,看github能否访问,用vpn试试 2.在project/build.gradle中添加仓库地址123456789101112131415161718192021allprojects &#123; repositories &#123; jcenter() maven &#123; url 'https://jitpack.io' &#125; &#125;&#125;``` # Plugin with id 'android-library' not found在项目的build.gradle中添加如下代码```java buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.1' &#125; &#125; OutOfMemoryError Error:UNEXPECTED TOP-LEVEL ERROR:Error:java.lang.OutOfMemoryError: GC overhead limit exceeded 编译时内存溢出,需要为为虚拟机分配更大的内存,在module的builg.gradle文件中 12345678android&#123; ... dexOptions &#123; //incremental true javaMaxHeapSize "2048M" &#125;&#125; Error:(147) Apostrophe not preceded by \ (in Cost can’t be empty)项目中的一个strings.xml文件里有某个string标签中的字符串含有 “ ’ “ 符号，我们只要在 “ ’ “ 符号 之前加 “\” 进行转义就可以解决这个错误，比如把Can’t修改为Can\’t就可以了。 &lt;string name=&quot;cost_no_empty&quot;&gt;Cost can&apos;t be empty&lt;/string&gt; 错误 &lt;string name=&quot;cost_no_empty&quot;&gt;Cost can\&apos;t be empty&lt;/string&gt; 正确 XML中无法预览提示 Rendering Problems Missing styles解决 :选一个App Theme即可,比如 Black.No TitleBar 识别不到Genymotion Device 打开genymotion.exe , settings -&gt; ADB -&gt; Use custom Android SDK tools 设置sdk的目录位置为你Android studio使用的sdk的目录 , 例如 D:\Dev\Android\sdk 将Genymotion Device和AndroidStudio 都重启 !zip.isFile()gradle编译时报如下异常 1Error:Execution failed for task &apos;:app:packageDebug&apos;. &gt; !zip.isFile() 顶部工具栏 Clean and Rebuild project 完事 Find in Path全局搜索失败Ctrl+Shift+F 调出Find in path全局搜索页面,输入关键字搜索时,发现明明项目里有这个内容,但是却在Preview界面没有任何结果展示. 解决方案: Find in path-&gt;Options-&gt;File name filter,把File masks的对勾去掉.就可以正常使用了. .AndroidStudio2.X目录移动至其他目录.AndroidStudio2.X 默认放在C盘的C:\Users{yourUsername}/目录下,轻轻松松占用几个G的磁盘空间,不过一般C盘是系统盘,所以希望保留足够的剩余空间.此时可以将此目录剪切到任何地方.然后做如下配置修改: 1.在AndroidStudio安装目录(比如D:\Dev\Android\Android Studio\bin),找到idea.properties配置文件 里面有两个默认配置如下 #--------------------------------------------------------------------- # Uncomment this option if you want to customize path to IDE config folder. Make sure you&apos;re using forward slashes. #--------------------------------------------------------------------- # idea.config.path=${user.home}/.AndroidStudio/config #--------------------------------------------------------------------- # Uncomment this option if you want to customize path to IDE system folder. Make sure you&apos;re using forward slashes. #--------------------------------------------------------------------- # idea.system.path=${user.home}/.AndroidStudio/system 2.针对于idea.config.path 和 idea.system.path,可以修改原有默认配置,或者新增均可,然后取消前面的注释符号#即可.比如修改后为 idea.config.path=D:\cache\.AndroidStudio2.3\config idea.system.path=D:\cache\.AndroidStudio2.3\system]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio自定义配置]]></title>
    <url>%2F2016%2F05%2F06%2FAndroidStudio%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[AndroidStudio主题官方主题站,另外还有一个 国内站点 ,下载速度会快一些. 将主题jar包下载下来 , AS中点击左上角File–&gt;,import settings,导入jar包即可. AS项目中哪些文件需要保留,哪些是自动生成的?需要保留的有: Project下,3个 app build.gradle settings.gradle Module下 , 4个 libs src build.gradle proguard-rules.pro 其他全部都是自动生成的 , 均可删除 . 如果要将代码备份留存 , 保留以上文件即可 , 这样可以极大的缩小体积. 取消Android Studio启动时自动打开上次关闭时的界面Settings–&gt;Appearance Behavior–&gt;System Settings–&gt;取消勾选 Reopen last project on startup 这个如果勾选 , 启动后会直接进入上次退出时正在编辑的界面. 如果不勾选,就会进入初始化主界面. 格式化代码不换行File–&gt;Code Style–&gt;java –&gt;Wrapping and Braces –&gt;line breaks把这勾勾去掉 就可以了 Offline离线模式Settings –&gt;Build,Execution,Deployment–&gt;Gradle–&gt;勾选Offline work优点 : 提高项目的编译效率,不用每次都去联网更新.缺点 : 当导入一些其他项目时,可能需要去下载一些依赖,如果离线,则无限下载.导致项目无法使用. 而且很多远程依赖会定期更新,采用离线模式无法达到及时更新. 修改字体大小1.修改编辑区字体大小Settings–&gt;Editor–&gt;Colors&amp;Fonts–&gt;Font–&gt;Save AS 保存自己的风格.然后就可以修改字体,并使用自定义的风格了. 2.修改工程目录区字体大小Settings–&gt;Appearance–&gt;修改字体大小即可 添加/更换字体Settings–&gt;Editor–&gt;Colors&amp;Fonts–&gt;Font–&gt;Editor Font选项 选择字体喜欢的字体. Show only monospace fonts 表示是否 [只显示等宽字体] 另外,可以去网上搜索下载自己喜欢的字体样式,然后按照如下方式配置 下载字体文件,Windows下使用 ttf 格式的字体文件 安装字体文件 方式1:直接双击ttf文件-&gt;安装(推荐方式) 方式2:把该字体复制粘贴到C:\Windows\Fonts目录下,系统会自动把该字体安装 重启AndroidStudio AndroidStudio的字体默认也是从系统字体中选择的,经过以上配置,就可以使用自己想要的字体了. 个人比较喜欢的字体样式有: consolas Fira menlo monaco UbuntuMono Source Code Pro 下载地址: AndroidStudio常用字体备份 代码块/方法分割线Settings–&gt;Editor–&gt;General–&gt;Appearance–&gt;Show Method separators 每行代码最大容量Settings–&gt;Editor–&gt;Code Style–&gt;Default Options–&gt;Right margin(columns) 代码提示时忽略大小写Settings–&gt;Editor–&gt;General–&gt;Code Completion–&gt;Case sensitive completion–&gt;选择None即可(默认是First Letters) 自定义字体颜色Settings–&gt;Editor–&gt;Colors&amp;Fonts–&gt;Language Defaults 点击示例文本中的关键字,可以自动选择名称,修改颜色. 修改代码区背景色Settings–&gt;Edito–&gt;colors &amp; fonts–&gt;General–&gt;Text–&gt;default text在右侧选择前景色 , 背景色 个人喜欢使用专家们建议的豆沙绿（RGB：#BEEDBE）or （204,232,207） 修改控制台Logcat颜色File–&gt;Settings–&gt;Editor –&gt; Colors &amp;Fonts –&gt; Android Logcat将Use Inberited attributes 去掉勾选 ,然后就可以根据Logcat级别自定义颜色了 自定义文件注释模板Settings–&gt;Editor–&gt;File and Code Templates–&gt;Includes–&gt;File Header在里面自定义即可. 比如我的模板是12345/** * Created by wangxiwen on $&#123;DATE&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;. * E-mail : wangxw725@gmail.com * Function : */ 那么每当新创建一个类时,就会带上这个文件头12345/** * Created by wangxiwen on 2017/4/15 06:44. * E-mail : wangxw725@gmail.com * Function : */ 全屏编辑代码View–&gt;Enter Presentation Mode 恢复已删除的文件VCS–&gt;Local History–&gt;Show History 修改缓存文件目录.gradleFile–&gt;Settings–&gt;Build,Execution,Deployment–&gt;Gradle–&gt;Service directory path , 这里设置指定的缓存目录即可. .AndroidStudio2.3定位到AndroidStudio/bin/idea.properties文件,找到如下内容 # idea.config.path=${user.home}/.AndroidStudio/config # idea.system.path=${user.home}/.AndroidStudio/system 去掉注释,将路径修改到自定义的目录即可.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>经验总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础-位运算符回顾]]></title>
    <url>%2F2016%2F04%2F01%2FJava%E5%9F%BA%E7%A1%80-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[撸代码时间越长，越体会到的基础知识的重要性，研究原理越多，越感觉到数据结构和算法的重要性。这些东西在日常的业务代码中体会不是很明显，但是一旦稍微往深了研究，立刻就能发现自己不足。 今天在看源码的时候，发现居然忘记了位运算符是怎么玩的了，赶紧回顾了一下，顺便写个笔记记录一下，加深下印象。 位运算符主要针对二进制数，包括以下几种： &amp; 与运算符 | 或运算符 ^ 异或运算符 ~ 非运算符 &amp; 与运算符 规则:两个二进数对应bit位上的数都为1时,值为1,否则为0.类似于求1的交集. 例如:128的二进制表示:00000000 00000000 00000000 10000000129的二进制表示:00000000 00000000 00000000 10000001128&amp;129的结果 :00000000 00000000 00000000 10000000 (十进制值为 128) | 或运算符 规则:两个二进数对应bit位上的数只要有一个为1,则值为1,否则为0.类似于求1的并集. 例如:128的二进制表示:00000000 00000000 00000000 10000000129的二进制表示:00000000 00000000 00000000 10000001128 | 129的结果 :00000000 00000000 00000000 10000001 (十进制值为 129) ^ 异或运算符 规则:两个二进数对应bit位上的数,相同则为0,不同则为1. 例如:128的二进制表示:00000000 00000000 00000000 10000000129的二进制表示:00000000 00000000 00000000 10000001128 ^ 129的结果:00000000 00000000 00000000 00000001 (十进制值为 1) ~ 非运算符 规则:如果该bit位上数值是0,则为1;如果是1,则为0.也就是取反运算. 例如:129的二进制表示:00000000 00000000 00000000 10000001~129的计算结果 :11111111 11111111 11111111 01111110 (注意此时仍为补码)根据补码求反码 : 11111111 11111111 11111111 01111101根据反码求原码 : 10000000 00000000 00000000 10000010 (十进制值为 -130) 取反公式: ~(x) = -1*(x+1); 例: 6取反=-7 ; 9取反=-10 ; 129取反=-130 代码测试12345678910public class Test &#123; public static void main(String[] args) &#123; int a = 128; int b = 129; System.out.println("128 &amp; 129: "+(128 &amp; 129)); System.out.println("128 | 129: "+(128 | 129)); System.out.println("128 ^ 129: "+(128 ^ 129)); System.out.println("~129 : "+(~129)); &#125;&#125; Log输出:1234128 &amp; 129: 128128 | 129: 129128 ^ 129: 1~129 : -130]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github Pages搭建个人博客]]></title>
    <url>%2F2016%2F03%2F10%2FHexo%2BGithub%20Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Github Pages仓库创建官方教程：Github Pages官方教程里已经有很详细的步骤了，这里只是把几个需要注意的地方记录一下。 首先必须得有Github账号，作为世界上最大的同性交友网站，越早注册越好，带你进入一个全新的世界！ New Repository时，必须以username.github.io命名，username就是指自己的用户名，例如crocutax.github.io，注意必须严格按照这个格式来命名，否则无效.官网给出的警告是: If the first part of the repository doesn’t exactly match your username, it won’t work, so make sure to get it right. 3.为仓库配置SSH keys,后期以更加安全的SSH方式管理远程仓库(毕竟是个人博客,还是SSH方式好些) 在电脑任意位置右键打开Git bash窗口（必须已安装Git），输入ssh-keygen -t rsa -C &quot;youremailAddress（你的邮箱地址）&quot;， 此时会提示创建密码，此密码会在之后向仓库push时使用，如果为空的话之后push时就不用输入。 如下图： 生成好之后，第二个红圈表示SSH keys生成的位置，在C盘的用户目录下，比如我的是C:\Users\Crocutax\.ssh\，找到该文件夹的位置 将其中的id_rsa.pub （公匙）用文本编辑器打开，复制其中的内容，打开刚刚创建的Github Repository，位置如下：crocutax.github.io–&gt;Settings–&gt;Deploy keys–&gt;Add key 个人域名解析购买了域名之后，添加域名解析，即将自己的域名指向哪个具体的主机 IP。 打开dos窗口，输入ping xxx.github.io ，获取到主机IP，如图所示 获取到主机IP后，在域名管理后台进行添加 添加完毕后，如下图所示： 除了这里进行域名解析的设置，要想正常通过http://www.crocutax.com 来访问http://crocutax.github.io 的内容，还需要在Repository–&gt;Settings–&gt;Options–&gt;GitHub Pages-Custom domain中进行配置 如图： 这样配置之后，后面等到Hexo初始化完毕后，再完成最后一步：在source/目录下创建一个CNAME文件（后面再说），就可以直接通过http://www.crocutax.com 来访问http://crocutax.github.io 的内容了。不过现在我们github仓库里是空的，接下来就开始搭建Hexo环境了。 搭建Hexo环境Hexo的运行依靠Node.js，因此需要先 安装Node.js 。 $ npm install -g hexo 然后继续开启Git bash窗口，输入npm install -g hexo，开始安装Hexo。这里我碰到了一个问题，就是提示 npm WARN deprecated swig@1.4.2: This package is no longer maintained 如下图： 起初以为是报了个错误，于是网上一顿搜，各种更新各种折腾。后来发现，其实一直是在安装中，只是速度慢而已，导致我认为出了错误。通过google，通过npm config set registry &quot;https://registry.npm.taobao.org&quot;设置淘宝镜像源后，很快就安装完毕了，弹出了如下界面 安装hexo插件 123456789$ npm install hexo-generator-index --save #索引生成器$ npm install hexo-generator-archive --save #归档生成器$ npm install hexo-generator-category --save #分类生成器$ npm install hexo-generator-tag --save #标签生成器$ npm install hexo-server --save #本地服务,4000端口$ npm install hexo-deployer-git --save #hexo通过git发布（必装）$ npm install hexo-baidu-url-submit --save # 百度搜索主动推送$ npm install hexo-renderer-stylus@0.3.0 --save #渲染器$ npm install hexo-wordcount --save # 字数,阅读时长统计工具 $ hexo init Hexo安装完毕后，创建一个想要在此创建网站目录的文件夹，比如我的是D:\Blog，在此处打开Git bash窗口，输入hexo init 进行初始化。 输出以下两个命令$ hexo g$ hexo s 第一个命令用于生成静态文件，第二个命令用于启动本地服务器，此时用浏览器打开http://localhost:4000 ，就可以看到hexo内置样式的Blog了。 创建CNAME文件 前面提到等Hexo初始化完毕后，需要在source/目录下创建一个CNAME文件，才能最终完成独立域名与Github Pages的绑定。关于CNAME的具体知识我现在还没有去深入的了解，这里只记录使用方法，注意： CNAME文件名全部为大写字母 文件没有后缀名，注意不要创建成CNAME.txt了 文件内容为你的域名，不带http://，比如www.crocutax.com即可 其实此时整个基础环境已经搭建完毕了，新建文章，deploy到远程仓库就可以了，但是一般我们都不会满足于hexo默认提供的主题样式，所以接下来开始选择主题。 选择主题如果要自定义主题，还是需要耗点时间的，所以为了快速的先把环境搭建起来，最好的方式是用前辈们创建好的主题，有很多官网主题都有漂亮，自己选一个吧！ 根据主题提供者的安装，配置步骤，一步一步来就行了。 由于自己长期做Android开发，所以对Material Design风格情有独钟，就选用了indigo主题，感谢前辈的付出。 Hexo常用命令可以在官网学习Hexo 指令,常用的有 hexo clean (清除缓存文件 (db.json) 和已生成的public目录下的静态文件，在某些情况下，尤其是更换主题后，如果发现对站点的更改无论如何也不生效，可能需要运行该命令) hexo g (hexo generate的简化命令，用于生成静态文件) hexo s (hexo server的简化命令，用于启动本地服务器，一般用于测试) hexo d (hexo deploy的简化命令，用将本地内容部署到远程仓库) 注意事项 在_config.yml 文件的配置中,必须注意yml文件的语法格式 : 字段＋冒号＋空格＋内容，比如url: http://www.crocutax.com/ ,这个空格一定不能省,否则会报错 通过hexo s 运行起本地服务之后 ,git bash会显示如下内容INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. ,此时按Ctrl+C 是停止运行的作用,而不是我们常用的复制,在这里可以再git bash窗口中通过鼠标右键+copy来复制. 踩坑记录Github pages 的custom domain重置问题为了使用http://www.corcutax.com替代http://corcutax.github.io来访问我们的博客,除了需要设置DNS解析之外,还需要在Github pages–&gt;Settings–&gt;Custom domain中设置. 但是在使用过程中发现 , 每次hexo deploy 之后 , http://www.corcutax.com 都会出现404,而http://corcutax.github.io 则访问正常.再次来到Github pages–&gt;Settings–&gt;Custom domain , 发现Custom domain已经重置了 . 需要手动再次重新关联. google了一下 , 网上小伙伴们遇到了同样的问题 , 比如:https://github.com/hexojs/hexo/issues/2446https://www.zhihu.com/question/28814437 问题原因 : CNAME文件每次部署都被自动删除.解决方案 : 将CNAME文件放在source目录下. 如图: CNAME文件内容为 : www.crocutax.com完事! npm comman not found环境变量问题,参考 http://caibaojian.com/nodejs-roll-back.html 部署过程中参考到的网址有：设置DNS解析CNAME记录第一次搭建Hexo搭建Hexo博客搭建Hexo博客中碰到的坑 还有一些后期在性能优化上可能会用到，先在此记录：为博客添加运行时间解决访问次数限制Hexo进阶MD插件库如何自己制作主题]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么一定要捯饬个人网站]]></title>
    <url>%2F2016%2F03%2F01%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E6%8D%AF%E9%A5%AC%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[个人对于知识整理的行为 , 经历了如下过程 : 不做笔记阶段刚入行的时候，什么都不懂，学着、用着、扔着。 结果：由于知识点特别多,所以很多不常用到的知识和技能点迅速的忘记。 只做笔记阶段在这个过程中，无论是工作中问题的解决，但是自学中的知识点，还是技术类文章中的扩展性技能点，都会简单的记录下来，少则两句话，几行代码，多则百十个字。 或许也是由于这个阶段，自己实在是菜鸟中的菜鸟，所以也不敢发表一些个人对某些技术的理解到公共的平台上。 结果：工作中遇到任何之前遇到过、或类似的问题 , 都能够通过搜索笔记来迅速定位、解决 。但是发现对很多技术点而言，无论是系统性还是深度上，都没有更好的认知和理解。 尝试在博客平台写博客阶段虽然博客在信息传播方面早已被短平快的微博所取代，但是对于知识梳理而言，依然有着不可替代的作用和优势，所以尤其在技术相关的领域，博客目前依然是重要的信息获取和发布媒介。 个人也从底层菜鸟，逐渐成长到 虽然离大神很远但是自认为也不能算是菜鸟的阶段了。 之所以决定写博客有以下因素考虑： 从Android角度而言，基础的APP已经没有任何压力了，所有的问题都可以解决，所有的业务需求都可以满足，只是时间长短的问题。但是在深度上还有很长的路要走，而且也很想更进一步。不奢望多么了解Linux内核层，但是想更全面、系统的了解FrameWork层。而记笔记作用很有限，虽然能记录和速查，但是系统性和深度不足。 由于文章是公开发布，而不仅仅是停留在自己的笔记里，所以写作的时候，会更加谨慎，会尽可能从多方面考虑，而在这个过程中，自己无形中在加深了认知，会有更好的学习效果。 能够得到其他人对于该技术点的反馈，发现自己认知上的漏洞、错误。 可以用来装逼、吹牛逼。笔记毕竟只是个人的，没有人知道，吹牛逼也没法吹啊。 总体而言，对一个技术点的认知，如果全面认知是10分，个人笔记阶段只是记录自己遇到的某个方面的问题，认知可能只达到了3分，而在准备博客的过程中，会发现更多问题，再学习、再整理，就到了6分7分。发布之后，根据读者对自己的反馈，再学习，可能就到了8分9分。而此时，比之于最初的3分，其实已经进步很多了。 尝试做个人网站阶段在使用博客平台过程中，逐渐发现了一些问题，比如： 一个博客平台成长到一定阶段，为了企业的收入，注定会引入广告，可能是各种形式，不同位置的广告，比如顶部栏，比如侧边栏，比如悬浮窗…… 从企业角度考虑，这也是无可厚非的。所以无论是从看博客的人来说，还是把这一片空间当做自己家园的写作者来说，都是只能忍。 从最开始走上技术道路到现在，发现自己经常混迹的地方是在不断变化的。无论是技术论坛，还是博客平台。所以虽然目前【简书】是自己比较喜欢的平台，但是……3年后呢？ 5年后呢？（自己5年后还在做技术吗？不知道，是不是想太远了……） 使用博客平台，虽然自己省了太多事，只需要专注写文章就可以了，而且也会有更好的流量，而这种流量也会是激励自己继续研究技术，继续写文章的动力。而且背靠平台也可以更好的吹牛逼，比如：CSDN专家！但是无论如何，还是会受博客平台本身的各种限制，比如内容审核，比如网站版式，比如各种细节处理…… 各类平台一般术业有专攻，比如在掘金，CSDN上聊聊生活合适吗？比如【简书】上虽然也有很多技术文章，但是从各种订阅号的更新频率、内容、阅读量来看，明显生活类的文章才是王道啊。 最终决定做了多种尝试，也考虑了诸多因素以后，最终决定： 自建网站 + 第三方博客平台 自己的大本营永远不变，而且可以随心所欲的自定义 第三方平台同步发布，引流+ 文件托管。无耻的微笑：） 自主域名 + Hexo搭建 + Github Pages托管 必须把crocutax这个域名给用上，就是喜欢，任性！ 选择Hexo，是因为感觉它更Geek，而且目前能力也有限，搞不了太多自定义 Github官方鼓励 + 目前流行 + 不用白不用 + 起步阶段，就先Github Pages吧！ 差不多就这样，下一篇记录下初步搭建的过程，基础设施的完善 + 重分利用轮子 + 前辈们把轮子都造的很好 = 搭建起来并不费劲。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
